{"version":3,"file":"voca.min.js","sources":["../src/helper/object/is_nil.js","../src/helper/boolean/coerce_to_boolean.js","../src/query/is_string.js","../src/helper/string/coerce_to_string.js","../src/case/capitalize.js","../src/case/lower_case.js","../src/helper/string/to_string.js","../src/split/words.js","../src/case/swap_case.js","../src/helper/number/clip_number.js","../src/helper/number/to_integer.js","../src/chop/truncate.js","../src/helper/string/surrogate_pair.js","../src/chop/code_point_at.js","../src/chop/prune.js","../src/count/count_where.js","../src/manipulate/repeat.js","../src/manipulate/pad_left.js","../src/manipulate/pad_right.js","../src/helper/format/type_format/float.js","../src/helper/format/type_format/integer_base.js","../src/helper/format/replacement/compute.js","../src/helper/format/replacement/match.js","../src/index/search.js","../src/manipulate/insert.js","../src/helper/string/diacritics_map.js","../src/manipulate/pad.js","../src/query/includes.js","../src/manipulate/replace_all.js","../src/manipulate/reverse_grapheme.js","../src/manipulate/splice.js","../src/manipulate/tr.js","../src/manipulate/trim_left.js","../src/manipulate/trim_right.js","../src/manipulate/word_wrap.js","../src/query/ends_with.js","../src/query/matches.js","../src/strip/strip_bom.js","../src/helper/strip/parse_tag_name.js","../src/strip/strip_tags.js","../src/util/version.js","../src/chain/wrapper.js","../src/helper/reg_exp/const.js","../src/helper/format/const.js","../src/functions.js"],"sourcesContent":["/**\r\n * Checks if `value` is `null` or `undefined`\r\n *\r\n * @ignore\r\n * @function isNil\r\n * @param {*} value The object to check\r\n * @return {boolean} Returns `true` is `value` is `undefined` or `null`, `false` otherwise\r\n */\r\nexport default function isNil(value) {\r\n  return value === undefined || value === null;\r\n}","import isNil from 'helper/object/is_nil';\r\n\r\n/**\r\n * Converts the `value` to a boolean. If `value` is `undefined` or `null`, returns `defaultValue`.\r\n *\r\n * @ignore\r\n * @function toBoolean\r\n * @param {*} value The value to convert.\r\n * @param {boolean} [defaultValue=false] The default value.\r\n * @return {boolean} Returns the coercion to boolean.\r\n */\r\nexport default function coerceToBoolean(value, defaultValue = false) {\r\n  if (isNil(value)) {\r\n    return defaultValue;\r\n  }\r\n  return Boolean(value);\r\n}","/**\r\n * Checks whether `subject` is a string primitive type.\r\n *\r\n * @function isString\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Query\r\n * @param {string} subject The value to verify.\r\n * @return {boolean} Returns `true` if `subject` is string primitive type or `false` otherwise.\r\n * @example\r\n * v.isString('vacation');\r\n * // => true\r\n *\r\n * v.isString(560);\r\n * // => false\r\n */\r\nexport default function isString(subject) {\r\n  return typeof subject === 'string';\r\n}","import isNil from 'helper/object/is_nil';\r\nimport isString from 'query/is_string';\r\n\r\n/**\r\n * Get the string representation of the `value`.\r\n * Converts the `value` to string.\r\n * If `value` is `null` or `undefined`, return `defaultValue`.\r\n *\r\n * @ignore\r\n * @function toString\r\n * @param {*} value             The value to convert.\r\n * @param {*} [defaultValue=''] The default value to return.\r\n * @return {string|null}        Returns the string representation of `value`. Returns `defaultValue` if `value` is\r\n *                              `null` or `undefined`.\r\n */\r\nexport default function coerceToString(value, defaultValue = '') {\r\n  if (isNil(value)) {\r\n    return defaultValue;\r\n  }\r\n  if (isString(value)) {\r\n    return value;\r\n  }\r\n  return String(value);\r\n}","import coerceToBoolean from 'helper/boolean/coerce_to_boolean';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Converts the first character of `subject` to upper case. If `restToLower` is `true`, convert the rest of\r\n * `subject` to lower case.\r\n *\r\n * @function capitalize\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Case\r\n * @param  {string}  [subject='']        The string to capitalize.\r\n * @param  {boolean} [restToLower=false] Convert the rest of `subject` to lower case.\r\n * @return {string}                      Returns the capitalized string.\r\n * @example\r\n * v.capitalize('apple');\r\n * // => 'Apple'\r\n *\r\n * v.capitalize('aPPle', true);\r\n * // => 'Apple'\r\n */\r\nexport default function capitalize(subject, restToLower) {\r\n  let subjectString = coerceToString(subject);\r\n  const restToLowerCaseBoolean = coerceToBoolean(restToLower);\r\n  if (subjectString === '') {\r\n    return '';\r\n  }\r\n  if (restToLowerCaseBoolean) {\r\n    subjectString = subjectString.toLowerCase();\r\n  }\r\n  return subjectString.substr(0, 1).toUpperCase() + subjectString.substr(1);\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Converts the `subject` to lower case.\r\n *\r\n * @function lowerCase\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Case\r\n * @param  {string} [subject=''] The string to convert to lower case.\r\n * @return {string}              Returns the lower case string.\r\n * @example\r\n * v.lowerCase('Green');\r\n * // => 'green'\r\n *\r\n * v.lowerCase('BLUE');\r\n * // => 'blue'\r\n */\r\nexport default function lowerCase(subject) {\r\n  const subjectString = coerceToString(subject, '');\r\n  return subjectString.toLowerCase();\r\n}\r\n","import isNil from 'helper/object/is_nil';\r\nimport isString from 'query/is_string';\r\n\r\n/**\r\n * Get the string representation of the `value`.\r\n * Converts the `value` to string.\r\n *\r\n * @ignore\r\n * @function toString\r\n * @param {*} value             The value to convert.\r\n * @return {string|null}        Returns the string representation of `value`.\r\n */\r\nexport default function toString(value) {\r\n  if (isNil(value)) {\r\n    return null;\r\n  }\r\n  if (isString(value)) {\r\n    return value;\r\n  }\r\n  return String(value);\r\n}","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport nilDefault from 'helper/undefined/nil_default';\r\nimport toString from 'helper/string/to_string';\r\n\r\n/**\r\n * Splits `subject` into an array of words.\r\n *\r\n * @function words\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Split\r\n * @param {string} [subject=''] The string to split into words.\r\n * @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\r\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\r\n * @return {Array} Returns the array of words.\r\n * @example\r\n * v.words('gravity can cross dimensions');\r\n * // => ['gravity', 'can', 'cross', 'dimensions']\r\n *\r\n * v.words('GravityCanCrossDimensions');\r\n * // => ['Gravity', 'Can', 'Cross', 'Dimensions']\r\n *\r\n * v.words('Gravity - can cross dimensions!');\r\n * // => ['Gravity', 'can', 'cross', 'dimensions']\r\n *\r\n * v.words('Earth gravity', /[^\\s]+/g);\r\n * // => ['Earth', 'gravity']\r\n */\r\nexport default function words(subject, pattern, flags) {\r\n  const subjectString = coerceToString(subject);\r\n  let patternRegExp;\r\n  if (isNil(pattern)) {\r\n    patternRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\r\n  } else if (pattern instanceof RegExp) {\r\n    patternRegExp = pattern;\r\n  } else {\r\n    const flagsString = toString(nilDefault(flags, ''));\r\n    patternRegExp = new RegExp(toString(pattern), flagsString);\r\n  }\r\n  return nilDefault(subjectString.match(patternRegExp), []);\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Converts the uppercase alpha caracters of `subject` to lowercase and lowercase \r\n * characters to uppercase.\r\n *\r\n * @function swapCase\r\n * @static\r\n * @since 1.3.0\r\n * @memberOf Case\r\n * @param  {string} [subject=''] The string to swap the case.\r\n * @return {string}              Returns the converted string.\r\n * @example\r\n * v.swapCase('League of Shadows');\r\n * // => 'lEAGUE OF sHADOWS'\r\n *\r\n * v.swapCase('2 Bees');\r\n * // => '2 bEES'\r\n */\r\nexport default function swapCase(subject) {\r\n  const subjectString = coerceToString(subject);\r\n  return subjectString.split('').reduce(swapAndConcat, '');\r\n}\r\n\r\nfunction swapAndConcat(swapped, character) {\r\n  const lowerCase = character.toLowerCase();\r\n  const upperCase = character.toUpperCase();\r\n  return swapped + (character === lowerCase ? upperCase : lowerCase);\r\n}","/**\r\n * Clip the number to interval `downLimit` to `upLimit`.\r\n *\r\n * @ignore\r\n * @function clipNumber\r\n * @param {number} value The number to clip\r\n * @param {number} downLimit The down limit\r\n * @param {number} upLimit The upper limit\r\n * @return {number} The clipped number\r\n */\r\nexport default function clipNumber(value, downLimit, upLimit) {\r\n  if (value <= downLimit) {\r\n    return downLimit;\r\n  }\r\n  if (value >= upLimit) {\r\n    return upLimit;\r\n  }\r\n  return value;\r\n}","import { MAX_SAFE_INTEGER } from 'helper/number/const';\r\n\r\n/**\r\n * Transforms `value` to an integer.\r\n *\r\n * @ignore\r\n * @function toInteger\r\n * @param {number} value The number to transform.\r\n * @returns {number} Returns the transformed integer.\r\n */\r\nexport default function toInteger(value) {\r\n  if (value === Infinity) {\r\n    return MAX_SAFE_INTEGER;\r\n  }\r\n  if (value === -Infinity) {\r\n    return - MAX_SAFE_INTEGER;\r\n  }\r\n  return ~~value;\r\n}","import clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Truncates `subject` to a new `length`.\r\n *\r\n * @function truncate\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Chop\r\n * @param  {string} [subject=''] The string to truncate.\r\n * @param  {int}    length       The length to truncate the string.\r\n * @param  {string} [end='...']  The string to be added at the end.\r\n * @return {string}              Returns the truncated string.\r\n * @example\r\n * v.truncate('Once upon a time', 7);\r\n * // => 'Once...'\r\n *\r\n * v.truncate('Good day, Little Red Riding Hood', 14, ' (...)');\r\n * // => 'Good day (...)'\r\n *\r\n * v.truncate('Once upon', 10);\r\n * // => 'Once upon'\r\n */\r\nexport default function truncate(subject, length, end) {\r\n  const subjectString = coerceToString(subject);\r\n  const lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\r\n  const endString = coerceToString(end, '...');\r\n  if (lengthInt >= subjectString.length) {\r\n    return subjectString;\r\n  }\r\n  return subjectString.substr(0, length - endString.length) + endString;\r\n}","const HIGH_SURROGATE_START = 0xD800;\r\nconst HIGH_SURROGATE_END = 0xDBFF;\r\nconst LOW_SURROGATE_START = 0xDC00;\r\nconst LOW_SURROGATE_END = 0xDFFF;\r\n\r\n/**\r\n * Checks if `codePoint` is a high-surrogate number from range 0xD800 to 0xDBFF.\r\n *\r\n * @ignore\r\n * @param {number} codePoint The code point number to be verified\r\n * @return {boolean} Returns a boolean whether `codePoint` is a high-surrogate number.\r\n */\r\nexport function isHighSurrogate(codePoint) {\r\n  return codePoint >= HIGH_SURROGATE_START && codePoint <= HIGH_SURROGATE_END;\r\n}\r\n\r\n/**\r\n * Checks if `codePoint` is a low-surrogate number from range 0xDC00 to 0xDFFF.\r\n *\r\n * @ignore\r\n * @param {number} codePoint The code point number to be verified\r\n * @return {boolean} Returns a boolean whether `codePoint` is a low-surrogate number.\r\n */\r\nexport function isLowSurrogate(codePoint) {\r\n  return codePoint >= LOW_SURROGATE_START && codePoint <= LOW_SURROGATE_END;\r\n}\r\n\r\n/**\r\n * Get the astral code point number based on surrogate pair numbers.\r\n *\r\n * @ignore\r\n * @param {number} highSurrogate The high-surrogate code point number.\r\n * @param {number} lowSurrogate The low-surrogate code point number.\r\n * @return {number} Returns the astral symbol number.\r\n */\r\nexport function getAstralNumberFromSurrogatePair(highSurrogate, lowSurrogate) {\r\n  return (highSurrogate - HIGH_SURROGATE_START) * 0x400 + lowSurrogate - LOW_SURROGATE_START + 0x10000;\r\n}","import { getAstralNumberFromSurrogatePair, isHighSurrogate, isLowSurrogate } from 'helper/string/surrogate_pair';\r\nimport coerceToNumber from 'helper/number/coerce_to_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport nanDefault from 'helper/number/nan_default';\r\n\r\n/**\r\n * Get the Unicode code point value of the character at `position`. <br/>\r\n * If a valid UTF-16 <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">\r\n * surrogate pair</a> starts at `position`, the\r\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#astralplanes\">astral code point</a>\r\n * value at `position` is returned.\r\n *\r\n * @function codePointAt\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Chop\r\n * @param  {string} [subject=''] The string to extract from.\r\n * @param  {number} position The position to get the code point number.\r\n * @return {number} Returns a non-negative number less than or equal to `0x10FFFF`.\r\n * @example\r\n * v.codePointAt('rain', 1);\r\n * // => 97, or 0x0061\r\n *\r\n * v.codePointAt('\\uD83D\\uDE00 is smile', 0); // or 'ðŸ˜€ is smile'\r\n * // => 128512, or 0x1F600\r\n */\r\nexport default function codePointAt(subject, position) {\r\n  const subjectString = coerceToString(subject);\r\n  const subjectStringLength = subjectString.length;\r\n  let positionNumber = coerceToNumber(position);\r\n  positionNumber = nanDefault(positionNumber, 0);\r\n  if (positionNumber < 0 || positionNumber >= subjectStringLength) {\r\n    return undefined;\r\n  }\r\n  const firstCodePoint = subjectString.charCodeAt(positionNumber);\r\n  let secondCodePoint;\r\n  if (isHighSurrogate(firstCodePoint) && subjectStringLength > positionNumber + 1) {\r\n    secondCodePoint = subjectString.charCodeAt(positionNumber + 1);\r\n    if (isLowSurrogate(secondCodePoint)) {\r\n      return getAstralNumberFromSurrogatePair(firstCodePoint, secondCodePoint);\r\n    }\r\n  }\r\n  return firstCodePoint;\r\n}","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\r\nimport clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Truncates `subject` to a new `length` and does not break the words. Guarantees that the truncated string is no longer\r\n * than `length`.\r\n *\r\n * @static\r\n * @function prune\r\n * @since 1.0.0\r\n * @memberOf Chop\r\n * @param  {string} [subject=''] The string to prune.\r\n * @param  {int}    length       The length to prune the string.\r\n * @param  {string} [end='...']  The string to be added at the end.\r\n * @return {string}              Returns the pruned string.\r\n * @example\r\n * v.prune('Once upon a time', 7);\r\n * // => 'Once...'\r\n *\r\n * v.prune('Good day, Little Red Riding Hood', 16, ' (more)');\r\n * // => 'Good day (more)'\r\n *\r\n * v.prune('Once upon', 10);\r\n * // => 'Once upon'\r\n */\r\nexport default function prune(subject, length, end) {\r\n  const subjectString = coerceToString(subject);\r\n  const lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\r\n  const endString = coerceToString(end, '...');\r\n  if (lengthInt >= subjectString.length) {\r\n    return subjectString;\r\n  }\r\n  const pattern = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\r\n  let truncatedLength = 0;\r\n  subjectString.replace(pattern, function(word, offset) {\r\n    const wordInsertLength = offset + word.length;\r\n    if (wordInsertLength <= lengthInt - endString.length) {\r\n      truncatedLength = wordInsertLength;\r\n    }\r\n  });\r\n  return subjectString.substr(0, truncatedLength) + endString;\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\n\r\nconst reduce = Array.prototype.reduce;\r\n\r\n/**\r\n * Counts the characters in `subject` for which `predicate` returns truthy.\r\n *\r\n * @function  countWhere\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Count\r\n * @param  {string}   [subject=''] The string to count characters.\r\n * @param  {Function} predicate    The predicate function invoked on each character with parameters `(character, index, string)`.\r\n * @param  {Object}   [context]    The context to invoke the `predicate`.\r\n * @return {number}                Returns the number of characters for which `predicate` returns truthy.\r\n * @example\r\n * v.countWhere('hola!', v.isAlpha);\r\n * // => 4\r\n *\r\n * v.countWhere('2022', function(character, index, str) {\r\n *   return character === '2';\r\n * });\r\n * // => 3\r\n */\r\nexport default function countWhere(subject, predicate, context) {\r\n  const subjectString = coerceToString(subject);\r\n  if (subjectString === '' || typeof predicate !== 'function') {\r\n    return 0;\r\n  }\r\n  const predicateWithContext = predicate.bind(context);\r\n  return reduce.call(subjectString, function(countTruthy, character, index) {\r\n    return predicateWithContext(character, index, subjectString) ? countTruthy + 1 : countTruthy;\r\n  }, 0);\r\n}","import clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Repeats the `subject` number of `times`.\r\n *\r\n * @function repeat\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to repeat.\r\n * @param {number} [times=1] The number of times to repeat.\r\n * @return {string} Returns the repeated string.\r\n * @example\r\n * v.repeat('w', 3);\r\n * // => 'www'\r\n *\r\n * v.repeat('world', 0);\r\n * // => ''\r\n */\r\nexport default function repeat(subject, times) {\r\n  let subjectString = coerceToString(subject);\r\n  let timesInt = isNil(times) ? 1 : clipNumber(toInteger(times), 0, MAX_SAFE_INTEGER);\r\n  let repeatString = '';\r\n  while (timesInt) {\r\n    if (timesInt & 1) {\r\n      repeatString += subjectString;\r\n    }\r\n    if (timesInt > 1) {\r\n      subjectString += subjectString;\r\n    }\r\n    timesInt >>= 1;\r\n  }\r\n  return repeatString;\r\n}","import buildPadding from 'helper/string/build_padding';\r\nimport clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Pads `subject` from left to a new `length`.\r\n *\r\n * @function padLeft\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to pad.\r\n * @param {int} [length=0] The length to left pad the string. No changes are made if `length` is less than `subject.length`.\r\n * @param {string} [pad=' '] The string to be used for padding.\r\n * @return {string} Returns the left padded string.\r\n * @example\r\n * v.padLeft('dog', 5);\r\n * // => '  dog'\r\n *\r\n * v.padLeft('bird', 6, '-');\r\n * // => '--bird'\r\n *\r\n * v.padLeft('cat', 6, '-=');\r\n * // => '-=-cat'\r\n */\r\nexport default function padLeft(subject, length, pad) {\r\n  const subjectString = coerceToString(subject);\r\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\r\n  const padString = coerceToString(pad, ' ');\r\n  if (lengthInt <= subjectString.length) {\r\n    return subjectString;\r\n  }\r\n  return buildPadding(padString, lengthInt - subjectString.length) + subjectString;\r\n}","import buildPadding from 'helper/string/build_padding';\r\nimport clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Pads `subject` from right to a new `length`.\r\n *\r\n * @function padRight\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to pad.\r\n * @param {int} [length=0] The length to right pad the string. No changes are made if `length` is less than `subject.length`.\r\n * @param {string} [pad=' '] The string to be used for padding.\r\n * @return {string} Returns the right padded string.\r\n * @example\r\n * v.padRight('dog', 5);\r\n * // => 'dog  '\r\n *\r\n * v.padRight('bird', 6, '-');\r\n * // => 'bird--'\r\n *\r\n * v.padRight('cat', 6, '-=');\r\n * // => 'cat-=-'\r\n */\r\nexport default function padRight(subject, length, pad) {\r\n  const subjectString = coerceToString(subject);\r\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\r\n  const padString = coerceToString(pad, ' ');\r\n  if (lengthInt <= subjectString.length) {\r\n    return subjectString;\r\n  }\r\n  return subjectString + buildPadding(padString, lengthInt - subjectString.length);\r\n}","import {\r\n  TYPE_FLOAT,\r\n  TYPE_FLOAT_SCIENTIFIC,\r\n  TYPE_FLOAT_SCIENTIFIC_UPPERCASE,\r\n  TYPE_FLOAT_SHORT,\r\n  TYPE_FLOAT_SHORT_UPPERCASE\r\n} from 'helper/format/const';\r\nimport addSignToFormattedNumber from 'helper/format/type_format/add_sign_to_formatted_number';\r\nimport coerceToNumber from 'helper/number/coerce_to_number';\r\nimport { REGEXP_TRAILING_ZEROS } from 'helper/reg_exp/const';\r\nimport toString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Formats a float type according to specifiers.\r\n *\r\n * @ignore\r\n * @param  {string} replacement The string to be formatted.\r\n * @param  {ConversionSpecification} conversion The conversion specification object.\r\n * @return {string} Returns the formatted string.\r\n */\r\n\r\nexport default function float(replacement, conversion) {\r\n  let replacementNumber = parseFloat(replacement);\r\n  let formattedReplacement;\r\n  if (isNaN(replacementNumber)) {\r\n    replacementNumber = 0;\r\n  }\r\n  const precision = coerceToNumber(conversion.precision, 6);\r\n  switch (conversion.typeSpecifier) {\r\n    case TYPE_FLOAT:\r\n      formattedReplacement = replacementNumber.toFixed(precision);\r\n      break;\r\n    case TYPE_FLOAT_SCIENTIFIC:\r\n      formattedReplacement = replacementNumber.toExponential(precision);\r\n      break;\r\n    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:\r\n      formattedReplacement = replacementNumber.toExponential(precision).toUpperCase();\r\n      break;\r\n    case TYPE_FLOAT_SHORT:\r\n    case TYPE_FLOAT_SHORT_UPPERCASE:\r\n      formattedReplacement = formatFloatAsShort(replacementNumber, precision, conversion);\r\n      break;\r\n  }\r\n  formattedReplacement = addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion);\r\n  return toString(formattedReplacement);\r\n}\r\n\r\n/**\r\n * Formats the short float.\r\n *\r\n * @ignore\r\n * @param  {number} replacementNumber The number to format.\r\n * @param  {number} precision The precision to format the float.\r\n * @param  {ConversionSpecification} conversion The conversion specification object.\r\n * @return {string}  Returns the formatted short float.\r\n */\r\nfunction formatFloatAsShort(replacementNumber, precision, conversion) {\r\n  if (replacementNumber === 0) {\r\n    return '0';\r\n  }\r\n  const nonZeroPrecision = precision === 0 ? 1 : precision;\r\n  let formattedReplacement = replacementNumber\r\n    .toPrecision(nonZeroPrecision)\r\n    .replace(REGEXP_TRAILING_ZEROS, '');\r\n  if (conversion.typeSpecifier === TYPE_FLOAT_SHORT_UPPERCASE) {\r\n    formattedReplacement = formattedReplacement.toUpperCase();\r\n  }\r\n  return formattedReplacement;\r\n}","import {\r\n  RADIX_BINARY,\r\n  RADIX_HEXADECIMAL,\r\n  RADIX_OCTAL,\r\n  TYPE_INTEGER_ASCII_CHARACTER,\r\n  TYPE_INTEGER_BINARY,\r\n  TYPE_INTEGER_HEXADECIMAL,\r\n  TYPE_INTEGER_HEXADECIMAL_UPPERCASE,\r\n  TYPE_INTEGER_OCTAL\r\n} from 'helper/format/const';\r\nimport toString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Formats an integer type according to specifiers.\r\n *\r\n * @ignore\r\n * @param  {string} replacement The string to be formatted.\r\n * @param  {ConversionSpecification} conversion The conversion specification object.\r\n * @return {string} Returns the formatted string.\r\n */\r\n\r\nexport default function integerBase(replacement, conversion) {\r\n  let integer = parseInt(replacement);\r\n  if (isNaN(integer)) {\r\n    integer = 0;\r\n  }\r\n  integer = integer >>> 0;\r\n  switch (conversion.typeSpecifier) {\r\n    case TYPE_INTEGER_ASCII_CHARACTER:\r\n      integer = String.fromCharCode(integer);\r\n      break;\r\n    case TYPE_INTEGER_BINARY:\r\n      integer = integer.toString(RADIX_BINARY);\r\n      break;\r\n    case TYPE_INTEGER_OCTAL:\r\n      integer = integer.toString(RADIX_OCTAL);\r\n      break;\r\n    case TYPE_INTEGER_HEXADECIMAL:\r\n      integer = integer.toString(RADIX_HEXADECIMAL);\r\n      break;\r\n    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:\r\n      integer = integer.toString(RADIX_HEXADECIMAL).toUpperCase();\r\n      break;\r\n  }\r\n  return toString(integer);\r\n}","import {\r\n  TYPE_FLOAT,\r\n  TYPE_FLOAT_SCIENTIFIC,\r\n  TYPE_FLOAT_SCIENTIFIC_UPPERCASE,\r\n  TYPE_FLOAT_SHORT,\r\n  TYPE_FLOAT_SHORT_UPPERCASE,\r\n  TYPE_INTEGER,\r\n  TYPE_INTEGER_ASCII_CHARACTER,\r\n  TYPE_INTEGER_BINARY,\r\n  TYPE_INTEGER_DECIMAL,\r\n  TYPE_INTEGER_HEXADECIMAL,\r\n  TYPE_INTEGER_HEXADECIMAL_UPPERCASE,\r\n  TYPE_INTEGER_OCTAL,\r\n  TYPE_INTEGER_UNSIGNED_DECIMAL,\r\n  TYPE_STRING\r\n} from 'helper/format/const';\r\nimport alignAndPad from 'helper/format/align_and_pad';\r\nimport formatFloat from 'helper/format/type_format/float';\r\nimport formatIntegerBase from 'helper/format/type_format/integer_base';\r\nimport formatIntegerDecimal from 'helper/format/type_format/integer_decimal';\r\nimport formatString from 'helper/format/type_format/string';\r\n\r\n/**\r\n * Returns the computed string based on format specifiers.\r\n *\r\n * @ignore\r\n * @name computeReplacement\r\n * @param {string} replacement The replacement value.\r\n * @param {ConversionSpecification} conversion The conversion specification object.\r\n * @return {string} Returns the computed string.\r\n */\r\nexport default function compute(replacement, conversion) {\r\n  let formatFunction;\r\n  switch (conversion.typeSpecifier) {\r\n    case TYPE_STRING:\r\n      formatFunction = formatString;\r\n      break;\r\n    case TYPE_INTEGER_DECIMAL:\r\n    case TYPE_INTEGER:\r\n      formatFunction = formatIntegerDecimal;\r\n      break;\r\n    case TYPE_INTEGER_ASCII_CHARACTER:\r\n    case TYPE_INTEGER_BINARY:\r\n    case TYPE_INTEGER_OCTAL:\r\n    case TYPE_INTEGER_HEXADECIMAL:\r\n    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:\r\n    case TYPE_INTEGER_UNSIGNED_DECIMAL:\r\n      formatFunction = formatIntegerBase;\r\n      break;\r\n    case TYPE_FLOAT:\r\n    case TYPE_FLOAT_SCIENTIFIC:\r\n    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:\r\n    case TYPE_FLOAT_SHORT:\r\n    case TYPE_FLOAT_SHORT_UPPERCASE:\r\n      formatFunction = formatFloat;\r\n      break;\r\n  }\r\n  const formattedString = formatFunction(replacement, conversion);\r\n  return alignAndPad(formattedString, conversion);\r\n}","import coerceToNumber from 'helper/number/coerce_to_number';\r\nimport computeReplacement from 'helper/format/replacement/compute';\r\nimport ConversionSpecification from 'helper/format/conversion_specification';\r\nimport validateReplacement from 'helper/format/replacement/validate';\r\n\r\n/**\r\n * Return the replacement for regular expression match of the conversion specification.\r\n *\r\n * @ignore\r\n * @name matchReplacement\r\n * @param {ReplacementIndex} replacementIndex The replacement index object.\r\n * @param {string[]} replacements The array of replacements.\r\n * @param {string} conversionSpecification The conversion specification.\r\n * @param {string} percent The percent characters from conversion specification.\r\n * @param {string} position The position to insert the replacement.\r\n * @param {string} signSpecifier The sign specifier to force a sign to be used on a number.\r\n * @param {string} paddingSpecifier The padding specifier that says what padding character will be used.\r\n * @param {string} alignmentSpecifier The alignment specifier that says if the result should be left-justified or right-justified.\r\n * @param {string} widthSpecifier The width specifier how many characters this conversion should result in.\r\n * @param {string} precisionSpecifier The precision specifier says how many decimal digits should be displayed for floating-point numbers.\r\n * @param {string} typeSpecifier The type specifier says what type the argument data should be treated as.\r\n * @return {string} Returns the computed replacement.\r\n */\r\nexport default function match(replacementIndex, replacements, conversionSpecification, percent, position, signSpecifier,\r\n  paddingSpecifier, alignmentSpecifier, widthSpecifier, precisionSpecifier, typeSpecifier) {\r\n  const conversion = new ConversionSpecification({\r\n    percent,\r\n    signSpecifier,\r\n    paddingSpecifier,\r\n    alignmentSpecifier,\r\n    width: coerceToNumber(widthSpecifier, null),\r\n    precision: coerceToNumber(precisionSpecifier, null),\r\n    typeSpecifier\r\n  });\r\n  if (conversion.isPercentLiteral()) {\r\n    return conversionSpecification.slice(1);\r\n  }\r\n  const actualReplacementIndex = replacementIndex.getIndexByPosition(position);\r\n  replacementIndex.incrementOnEmptyPosition(position);\r\n  validateReplacement(actualReplacementIndex, replacements.length, conversion);\r\n  return computeReplacement(replacements[actualReplacementIndex], conversion);\r\n}","import clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Returns the first index of a `pattern` match in `subject`.\r\n *\r\n * @function search\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Index\r\n * @param {string} [subject=''] The string where to search.\r\n * @param {string|RegExp} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern)`.\r\n * @param {number} [fromIndex=0] The index to start searching.\r\n * @return {number} Returns the first match index or `-1` if not found.\r\n * @example\r\n * v.search('morning', /rn/);\r\n * // => 2\r\n *\r\n * v.search('evening', '/\\d/');\r\n * // => -1\r\n */\r\nexport default function search(subject, pattern, fromIndex) {\r\n  const subjectString = coerceToString(subject);\r\n  const fromIndexNumber = isNil(fromIndex) ? 0 : clipNumber(toInteger(fromIndex), 0, subjectString.length);\r\n  let matchIndex  = subjectString.substr(fromIndexNumber).search(pattern);\r\n  if (matchIndex !== -1 && !isNaN(fromIndexNumber)) {\r\n    matchIndex += fromIndexNumber;\r\n  }\r\n  return matchIndex;\r\n}","import coerceToNumber from 'helper/number/coerce_to_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Inserts into `subject` a string `toInsert` at specified `position`.\r\n *\r\n * @function insert\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string where to insert.\r\n * @param {string} [toInsert=''] The string to be inserted.\r\n * @param {number} [position=0] The position to insert.\r\n * @return {string} Returns the string after insertion.\r\n * @example\r\n * v.insert('ct', 'a', 1);\r\n * // => 'cat'\r\n *\r\n * v.insert('sunny', ' day', 5);\r\n * // => 'sunny day'\r\n */\r\nexport default function insert(subject, toInsert, position) {\r\n  const subjectString = coerceToString(subject);\r\n  const toInsertString = coerceToString(toInsert);\r\n  const positionNumber = coerceToNumber(position);\r\n  if (positionNumber < 0 || positionNumber > subjectString.length || toInsertString === '') {\r\n    return subjectString;\r\n  }\r\n  return subjectString.slice(0, positionNumber) + toInsertString + subjectString.slice(positionNumber);\r\n}","/**\r\n * Generated diacritics map. See bellow the base code.\r\n * @ignore\r\n * @see http://stackoverflow.com/a/18391901/1894471\r\n * @type Object\r\n */\r\n\r\nconst diacritics = {\r\n  \"3\": \"\\u039e\\u03be\",\r\n  \"8\": \"\\u0398\\u03b8\",\r\n  \"A\": \"\\x41\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226\\u023a\\u1e00\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u24b6\\u2c6f\\uff21\\u0386\\u0391\\u0410\",\r\n  \"B\": \"\\x42\\u0181\\u0182\\u0243\\u1e02\\u1e04\\u1e06\\u24b7\\uff22\\u0392\\u0411\",\r\n  \"C\": \"\\x43\\xc7\\u0106\\u0108\\u010a\\u010c\\u0187\\u023b\\u1e08\\u24b8\\ua73e\\uff23\\u0426\",\r\n  \"D\": \"\\x44\\u010e\\u0110\\u0189\\u018a\\u018b\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u24b9\\ua779\\uff24\\xd0\\u0394\\u0414\",\r\n  \"E\": \"\\x45\\xc8\\xc9\\xca\\xcb\\u0112\\u0114\\u0116\\u0118\\u011a\\u018e\\u0190\\u0204\\u0206\\u0228\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1eb8\\u1eba\\u1ebc\\u1ebe\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u24ba\\uff25\\u0388\\u0395\\u0415\\u042d\",\r\n  \"F\": \"\\x46\\u0191\\u1e1e\\u24bb\\ua77b\\uff26\\u03a6\\u0424\",\r\n  \"G\": \"\\x47\\u011c\\u011e\\u0120\\u0122\\u0193\\u01e4\\u01e6\\u01f4\\u1e20\\u24bc\\ua77d\\ua77e\\ua7a0\\uff27\\u0393\\u0413\\u0490\",\r\n  \"H\": \"\\x48\\u0124\\u0126\\u021e\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u24bd\\u2c67\\u2c75\\ua78d\\uff28\\u0389\\u0397\\u0425\",\r\n  \"I\": \"\\x49\\xcc\\xcd\\xce\\xcf\\u0128\\u012a\\u012c\\u012e\\u0130\\u0197\\u01cf\\u0208\\u020a\\u1e2c\\u1e2e\\u1ec8\\u1eca\\u24be\\uff29\\u038a\\u0399\\u03aa\\u0406\\u0418\",\r\n  \"J\": \"\\x4a\\u0134\\u0248\\u24bf\\uff2a\\u0419\",\r\n  \"K\": \"\\x4b\\u0136\\u0198\\u01e8\\u1e30\\u1e32\\u1e34\\u24c0\\u2c69\\ua740\\ua742\\ua744\\ua7a2\\uff2b\\u039a\\u041a\",\r\n  \"L\": \"\\x4c\\u0139\\u013b\\u013d\\u013f\\u0141\\u023d\\u1e36\\u1e38\\u1e3a\\u1e3c\\u24c1\\u2c60\\u2c62\\ua746\\ua748\\ua780\\uff2c\\u039b\\u041b\",\r\n  \"M\": \"\\x4d\\u019c\\u1e3e\\u1e40\\u1e42\\u24c2\\u2c6e\\uff2d\\u039c\\u041c\",\r\n  \"N\": \"\\x4e\\xd1\\u0143\\u0145\\u0147\\u019d\\u01f8\\u0220\\u1e44\\u1e46\\u1e48\\u1e4a\\u24c3\\ua790\\ua7a4\\uff2e\\u039d\\u041d\",\r\n  \"O\": \"\\x4f\\xd2\\xd3\\xd4\\xd5\\xd6\\xd8\\u014c\\u014e\\u0150\\u0186\\u019f\\u01a0\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\\u022e\\u0230\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u24c4\\ua74a\\ua74c\\uff2f\\u038c\\u039f\\u041e\",\r\n  \"P\": \"\\x50\\u01a4\\u1e54\\u1e56\\u24c5\\u2c63\\ua750\\ua752\\ua754\\uff30\\u03a0\\u041f\",\r\n  \"Q\": \"\\x51\\u024a\\u24c6\\ua756\\ua758\\uff31\",\r\n  \"R\": \"\\x52\\u0154\\u0156\\u0158\\u0210\\u0212\\u024c\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u24c7\\u2c64\\ua75a\\ua782\\ua7a6\\uff32\\u03a1\\u0420\",\r\n  \"S\": \"\\x53\\u015a\\u015c\\u015e\\u0160\\u0218\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e9e\\u24c8\\u2c7e\\ua784\\ua7a8\\uff33\\u03a3\\u0421\",\r\n  \"T\": \"\\x54\\u0162\\u0164\\u0166\\u01ac\\u01ae\\u021a\\u023e\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u24c9\\ua786\\uff34\\u03a4\\u0422\",\r\n  \"U\": \"\\x55\\xd9\\xda\\xdb\\xdc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01af\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216\\u0244\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u24ca\\uff35\\u0423\\u042a\",\r\n  \"V\": \"\\x56\\u01b2\\u0245\\u1e7c\\u1e7e\\u24cb\\ua75e\\uff36\\u0412\",\r\n  \"W\": \"\\x57\\u0174\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u24cc\\u2c72\\uff37\\u038f\\u03a9\",\r\n  \"X\": \"\\x58\\u1e8a\\u1e8c\\u24cd\\uff38\\u03a7\",\r\n  \"Y\": \"\\x59\\xdd\\u0176\\u0178\\u01b3\\u0232\\u024e\\u1e8e\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1efe\\u24ce\\uff39\\u038e\\u03a5\\u03ab\\u042b\",\r\n  \"Z\": \"\\x5a\\u0179\\u017b\\u017d\\u01b5\\u0224\\u1e90\\u1e92\\u1e94\\u24cf\\u2c6b\\u2c7f\\ua762\\uff3a\\u0396\\u0417\",\r\n  \"a\": \"\\x61\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227\\u0250\\u1e01\\u1e9a\\u1ea1\\u1ea3\\u1ea5\\u1ea7\\u1ea9\\u1eab\\u1ead\\u1eaf\\u1eb1\\u1eb3\\u1eb5\\u1eb7\\u24d0\\u2c65\\uff41\\u03ac\\u03b1\\u0430\",\r\n  \"b\": \"\\x62\\u0180\\u0183\\u0253\\u1e03\\u1e05\\u1e07\\u24d1\\uff42\\u03b2\\u0431\",\r\n  \"c\": \"\\x63\\xe7\\u0107\\u0109\\u010b\\u010d\\u0188\\u023c\\u1e09\\u2184\\u24d2\\ua73f\\uff43\\u0446\",\r\n  \"d\": \"\\x64\\u010f\\u0111\\u018c\\u0256\\u0257\\u1e0b\\u1e0d\\u1e0f\\u1e11\\u1e13\\u24d3\\ua77a\\uff44\\xf0\\u03b4\\u0434\",\r\n  \"e\": \"\\x65\\xe8\\xe9\\xea\\xeb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229\\u0247\\u025b\\u1e15\\u1e17\\u1e19\\u1e1b\\u1e1d\\u1eb9\\u1ebb\\u1ebd\\u1ebf\\u1ec1\\u1ec3\\u1ec5\\u1ec7\\u24d4\\uff45\\u03ad\\u03b5\\u0435\\u044d\",\r\n  \"f\": \"\\x66\\u0192\\u1e1f\\u24d5\\ua77c\\uff46\\u03c6\\u0444\",\r\n  \"g\": \"\\x67\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5\\u0260\\u1d79\\u1e21\\u24d6\\ua77f\\ua7a1\\uff47\\u03b3\\u0433\\u0491\",\r\n  \"h\": \"\\x68\\u0125\\u0127\\u021f\\u0265\\u1e23\\u1e25\\u1e27\\u1e29\\u1e2b\\u1e96\\u24d7\\u2c68\\u2c76\\uff48\\u03ae\\u03b7\\u0445\",\r\n  \"i\": \"\\x69\\xec\\xed\\xee\\xef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b\\u0268\\u1e2d\\u1e2f\\u1ec9\\u1ecb\\u24d8\\uff49\\u0390\\u03af\\u03b9\\u03ca\\u0438\\u0456\",\r\n  \"j\": \"\\x6a\\u0135\\u01f0\\u0249\\u24d9\\uff4a\\u0439\",\r\n  \"k\": \"\\x6b\\u0137\\u0199\\u01e9\\u1e31\\u1e33\\u1e35\\u24da\\u2c6a\\ua741\\ua743\\ua745\\ua7a3\\uff4b\\u03ba\\u043a\",\r\n  \"l\": \"\\x6c\\u013a\\u013c\\u013e\\u0140\\u0142\\u017f\\u019a\\u026b\\u1e37\\u1e39\\u1e3b\\u1e3d\\u24db\\u2c61\\ua747\\ua749\\ua781\\uff4c\\u03bb\\u043b\",\r\n  \"m\": \"\\x6d\\u026f\\u0271\\u1e3f\\u1e41\\u1e43\\u24dc\\uff4d\\u03bc\\u043c\",\r\n  \"n\": \"\\x6e\\xf1\\u0144\\u0146\\u0148\\u0149\\u019e\\u01f9\\u0272\\u1e45\\u1e47\\u1e49\\u1e4b\\u24dd\\ua791\\ua7a5\\uff4e\\u03bd\\u043d\",\r\n  \"o\": \"\\x6f\\xf2\\xf3\\xf4\\xf5\\xf6\\xf8\\u014d\\u014f\\u0151\\u01a1\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\\u022f\\u0231\\u0254\\u0275\\u1e4d\\u1e4f\\u1e51\\u1e53\\u1ecd\\u1ecf\\u1ed1\\u1ed3\\u1ed5\\u1ed7\\u1ed9\\u1edb\\u1edd\\u1edf\\u1ee1\\u1ee3\\u24de\\ua74b\\ua74d\\uff4f\\u03bf\\u03cc\\u043e\",\r\n  \"p\": \"\\x70\\u01a5\\u1d7d\\u1e55\\u1e57\\u24df\\ua751\\ua753\\ua755\\uff50\\u03c0\\u043f\",\r\n  \"q\": \"\\x71\\u024b\\u24e0\\ua757\\ua759\\uff51\",\r\n  \"r\": \"\\x72\\u0155\\u0157\\u0159\\u0211\\u0213\\u024d\\u027d\\u1e59\\u1e5b\\u1e5d\\u1e5f\\u24e1\\ua75b\\ua783\\ua7a7\\uff52\\u03c1\\u0440\",\r\n  \"s\": \"\\x73\\xdf\\u015b\\u015d\\u015f\\u0161\\u0219\\u023f\\u1e61\\u1e63\\u1e65\\u1e67\\u1e69\\u1e9b\\u24e2\\ua785\\ua7a9\\uff53\\u03c2\\u03c3\\u0441\",\r\n  \"t\": \"\\x74\\u0163\\u0165\\u0167\\u01ad\\u021b\\u0288\\u1e6b\\u1e6d\\u1e6f\\u1e71\\u1e97\\u24e3\\u2c66\\ua787\\uff54\\u03c4\\u0442\",\r\n  \"u\": \"\\x75\\xf9\\xfa\\xfb\\xfc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01b0\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217\\u0289\\u1e73\\u1e75\\u1e77\\u1e79\\u1e7b\\u1ee5\\u1ee7\\u1ee9\\u1eeb\\u1eed\\u1eef\\u1ef1\\u24e4\\uff55\\u0443\\u044a\",\r\n  \"v\": \"\\x76\\u028b\\u028c\\u1e7d\\u1e7f\\u24e5\\ua75f\\uff56\\u0432\",\r\n  \"w\": \"\\x77\\u0175\\u1e81\\u1e83\\u1e85\\u1e87\\u1e89\\u1e98\\u24e6\\u2c73\\uff57\\u03c9\\u03ce\",\r\n  \"x\": \"\\x78\\u1e8b\\u1e8d\\u24e7\\uff58\\u03c7\",\r\n  \"y\": \"\\x79\\xfd\\xff\\u0177\\u01b4\\u0233\\u024f\\u1e8f\\u1e99\\u1ef3\\u1ef5\\u1ef7\\u1ef9\\u1eff\\u24e8\\uff59\\u03b0\\u03c5\\u03cb\\u03cd\\u044b\",\r\n  \"z\": \"\\x7a\\u017a\\u017c\\u017e\\u01b6\\u0225\\u0240\\u1e91\\u1e93\\u1e95\\u24e9\\u2c6c\\ua763\\uff5a\\u03b6\\u0437\",\r\n  \"OE\": \"\\x8c\\u0152\",\r\n  \"oe\": \"\\x9c\\u0153\",\r\n  \"AE\": \"\\xc6\\u01e2\\u01fc\",\r\n  \"ae\": \"\\xe6\\u01e3\\u01fd\",\r\n  \"hv\": \"\\u0195\",\r\n  \"OI\": \"\\u01a2\",\r\n  \"oi\": \"\\u01a3\",\r\n  \"DZ\": \"\\u01c4\\u01f1\",\r\n  \"Dz\": \"\\u01c5\\u01f2\",\r\n  \"dz\": \"\\u01c6\\u01f3\",\r\n  \"LJ\": \"\\u01c7\",\r\n  \"Lj\": \"\\u01c8\",\r\n  \"lj\": \"\\u01c9\",\r\n  \"NJ\": \"\\u01ca\",\r\n  \"Nj\": \"\\u01cb\",\r\n  \"nj\": \"\\u01cc\",\r\n  \"OU\": \"\\u0222\",\r\n  \"ou\": \"\\u0223\",\r\n  \"TZ\": \"\\ua728\",\r\n  \"tz\": \"\\ua729\",\r\n  \"AA\": \"\\ua732\",\r\n  \"aa\": \"\\ua733\",\r\n  \"AO\": \"\\ua734\",\r\n  \"ao\": \"\\ua735\",\r\n  \"AU\": \"\\ua736\",\r\n  \"au\": \"\\ua737\",\r\n  \"AV\": \"\\ua738\\ua73a\",\r\n  \"av\": \"\\ua739\\ua73b\",\r\n  \"AY\": \"\\ua73c\",\r\n  \"ay\": \"\\ua73d\",\r\n  \"OO\": \"\\ua74e\",\r\n  \"oo\": \"\\ua74f\",\r\n  \"VY\": \"\\ua760\",\r\n  \"vy\": \"\\ua761\",\r\n  \"TH\": \"\\xde\",\r\n  \"th\": \"\\xfe\",\r\n  \"PS\": \"\\u03a8\",\r\n  \"ps\": \"\\u03c8\",\r\n  \"Yo\": \"\\u0401\",\r\n  \"Ye\": \"\\u0404\",\r\n  \"Yi\": \"\\u0407\",\r\n  \"Zh\": \"\\u0416\",\r\n  \"Ch\": \"\\u0427\",\r\n  \"Sh\": \"\\u0428\\u0429\",\r\n  \"\": \"\\u042c\\u044c\",\r\n  \"Yu\": \"\\u042e\",\r\n  \"Ya\": \"\\u042f\",\r\n  \"zh\": \"\\u0436\",\r\n  \"ch\": \"\\u0447\",\r\n  \"sh\": \"\\u0448\\u0449\",\r\n  \"yu\": \"\\u044e\",\r\n  \"ya\": \"\\u044f\",\r\n  \"yo\": \"\\u0451\",\r\n  \"ye\": \"\\u0454\",\r\n  \"yi\": \"\\u0457\"\r\n};\r\n\r\nlet diacriticsMap = null;\r\n\r\n/**\r\n * Creates a map of the diacritics.\r\n *\r\n * @ignore\r\n * @returns {Object} Returns the diacritics map.\r\n */\r\nfunction getDiacriticsMap() {\r\n  if (diacriticsMap !== null) {\r\n    return diacriticsMap;\r\n  }\r\n  diacriticsMap = {};\r\n  Object.keys(diacritics).forEach(function(key) {\r\n    const characters = diacritics[key];\r\n    for (let index = 0; index < characters.length; index++) {\r\n      const character = characters[index];\r\n      diacriticsMap[character] = key;\r\n    }\r\n  });\r\n  return diacriticsMap;\r\n}\r\n\r\n/**\r\n * Get the latin character from character with diacritics.\r\n *\r\n * @ignore\r\n * @param   {string} character The character with diacritics.\r\n * @returns {string}           Returns the character without diacritics.\r\n */\r\nexport function getLatinCharacter(character) {\r\n  const characterWithoutDiacritic = getDiacriticsMap()[character];\r\n  return characterWithoutDiacritic ? characterWithoutDiacritic : character;\r\n}","import buildPadding from 'helper/string/build_padding';\r\nimport clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Pads `subject` to a new `length`.\r\n *\r\n * @function pad\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to pad.\r\n * @param {int} [length=0] The length to pad the string. No changes are made if `length` is less than `subject.length`.\r\n * @param {string} [pad=' '] The string to be used for padding.\r\n * @return {string} Returns the padded string.\r\n * @example\r\n * v.pad('dog', 5);\r\n * // => ' dog '\r\n *\r\n * v.pad('bird', 6, '-');\r\n * // => '-bird-'\r\n *\r\n * v.pad('cat', 6, '-=');\r\n * // => '-cat-='\r\n */\r\nexport default function pad(subject, length, pad) {\r\n  const subjectString = coerceToString(subject);\r\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\r\n  const padString = coerceToString(pad, ' ');\r\n  if (lengthInt <= subjectString.length) {\r\n    return subjectString;\r\n  }\r\n  const paddingLength = lengthInt - subjectString.length;\r\n  const paddingSideLength = toInteger(paddingLength / 2);\r\n  const paddingSideRemainingLength = paddingLength % 2;\r\n  return buildPadding(padString, paddingSideLength) + subjectString +\r\n      buildPadding(padString, paddingSideLength + paddingSideRemainingLength);\r\n}","import clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport toInteger from 'helper/number/to_integer';\r\nimport toString from 'helper/string/to_string';\r\n\r\n/**\r\n * Checks whether `subject` includes `search` starting from `position`.\r\n *\r\n * @function includes\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Query\r\n * @param {string} [subject=''] The string where to search.\r\n * @param {string} search The string to search.\r\n * @param {number} [position=0] The position to start searching.\r\n * @return {boolean} Returns `true` if `subject` includes `search` or `false` otherwise.\r\n * @example\r\n * v.includes('starship', 'star');\r\n * // => true\r\n *\r\n * v.includes('galaxy', 'g', 1);\r\n * // => false\r\n */\r\nexport default function includes(subject, search, position) {\r\n  const subjectString = coerceToString(subject);\r\n  const searchString = toString(search);\r\n  if (searchString === null) {\r\n    return false;\r\n  }\r\n  if (searchString === '') {\r\n    return true;\r\n  }\r\n  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);\r\n  return subjectString.indexOf(searchString, position) !== -1;\r\n}","import appendFlagToRegularExpression from 'helper/reg_exp/append_flag_to_reg_exp';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport escapeRegExp from 'escape/escape_reg_exp';\r\n\r\n/**\r\n * Replaces all matches of `pattern` with `replacement`. <br/>\r\n *\r\n * @function replaceAll\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to verify.\r\n * @param {string|RegExp} pattern The pattern which match is replaced. If `pattern` is a string, a simple string match is evaluated.\r\n * All matches are replaced.\r\n * @param {string|Function} replacement The string or function which invocation result replaces `pattern` match.\r\n * @return {string} Returns the replacement result.\r\n * @example\r\n * v.replaceAll('good morning', 'o', '*');\r\n * // => 'g**d m*rning'\r\n * v.replaceAll('evening', /n/, 's');\r\n * // => 'evesisg'\r\n *\r\n */\r\nexport default function replaceAll(subject, pattern, replacement) {\r\n  const subjectString = coerceToString(subject);\r\n  let regExp = pattern;\r\n  if (!(pattern instanceof RegExp)) {\r\n    regExp = new RegExp(escapeRegExp(pattern), 'g');\r\n  } else if (!pattern.global) {\r\n    regExp = appendFlagToRegularExpression(pattern, 'g');\r\n  }\r\n  return subjectString.replace(regExp, replacement);\r\n}","import { REGEXP_COMBINING_MARKS, REGEXP_SURROGATE_PAIRS } from 'helper/reg_exp/const';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Reverses the `subject` taking care of\r\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\r\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\r\n *\r\n * @function reverseGrapheme\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to reverse.\r\n * @return {string} Returns the reversed string.\r\n * @example\r\n * v.reverseGrapheme('summer');\r\n * // => 'remmus'\r\n *\r\n * v.reverseGrapheme('ðŒ† bar maÃ±ana manÌƒana');\r\n * // => 'ananÌƒam anaÃ±am rab ðŒ†'\r\n */\r\nexport default function reverseGrapheme(subject) {\r\n  let subjectString = coerceToString(subject);\r\n  /**\r\n   * @see https://github.com/mathiasbynens/esrever\r\n   */\r\n  subjectString = subjectString\r\n    .replace(REGEXP_COMBINING_MARKS, function($0, $1, $2) {\r\n      return reverseGrapheme($2) + $1;\r\n    })\r\n    .replace(REGEXP_SURROGATE_PAIRS, '$2$1');\r\n  let reversedString = '';\r\n  let index = subjectString.length;\r\n  while (index--) {\r\n    reversedString += subjectString.charAt(index);\r\n  }\r\n  return reversedString;\r\n}","import coerceToNumber from 'helper/number/coerce_to_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\n\r\n/**\r\n * Changes `subject` by deleting `deleteCount` of characters starting at position `start`. Places a new string\r\n * `toAdd` instead of deleted characters.\r\n *\r\n * @function splice\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string where to insert.\r\n * @param {string} start The position to start changing the string. For a negative position will start from the end of\r\n * the string.\r\n * @param {number} [deleteCount=subject.length-start] The number of characters to delete from string.\r\n * @param {string} [toAdd=''] The string to be added instead of deleted characters.\r\n * @return {string} Returns the modified string.\r\n * @example\r\n * v.splice('new year', 0, 4);\r\n * // => 'year'\r\n *\r\n * v.splice('new year', 0, 3, 'happy');\r\n * // => 'happy year'\r\n *\r\n * v.splice('new year', -4, 4, 'day');\r\n * // => 'new day'\r\n */\r\nexport default function splice(subject, start, deleteCount, toAdd) {\r\n  const subjectString = coerceToString(subject);\r\n  const toAddString = coerceToString(toAdd);\r\n  let startPosition = coerceToNumber(start);\r\n  if (startPosition < 0) {\r\n    startPosition = subjectString.length + startPosition;\r\n    if (startPosition < 0) {\r\n      startPosition = 0;\r\n    }\r\n  } else if (startPosition > subjectString.length) {\r\n    startPosition = subjectString.length;\r\n  }\r\n  let deleteCountNumber = coerceToNumber(deleteCount, subjectString.length - startPosition);\r\n  if (deleteCountNumber < 0) {\r\n    deleteCountNumber = 0;\r\n  }\r\n  return subjectString.slice(0, startPosition) + toAddString + subjectString.slice(startPosition + deleteCountNumber);\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\nimport isString from 'query/is_string';\r\nimport nilDefault from 'helper/undefined/nil_default';\r\n\r\n/**\r\n * Translates characters or replaces substrings in `subject`.\r\n *\r\n * @function tr\r\n * @static\r\n * @since 1.3.0\r\n * @memberOf Manipulate\r\n * @param  {string} [subject=''] The string to translate.\r\n * @param  {string|Object} from The string of characters to translate from. Or an object, then the object keys are replaced with corresponding values (longest keys are tried first).\r\n * @param  {string} to The string of characters to translate to. Ignored when `from` is an object.\r\n * @return {string} Returns the translated string.\r\n * @example\r\n * v.tr('hello', 'el', 'ip');\r\n * // => 'hippo'\r\n * \r\n * v.tr('lÃ©gÃ¨retÃ©', 'Ã©Ã¨', 'ee');\r\n * // => 'legerete'\r\n * \r\n * v.tr('Yes. The fire rises.', {\r\n *   'Yes': 'Awesome',\r\n *   'fire': 'flame'\r\n * })\r\n * // => 'Awesome. The flame rises.'\r\n * \r\n * v.tr(':where is the birthplace of :what', {\r\n *   ':where': 'Africa',\r\n *   ':what': 'Humanity'\r\n * });\r\n * // => 'Africa is the birthplace of Humanity'\r\n * \r\n */\r\nexport default function tr(subject, from, to) {\r\n  const subjectString = coerceToString(subject);\r\n  let keys;\r\n  let values;\r\n  if (isString(from) && isString(to)) {\r\n    keys = from.split('');\r\n    values = to.split('');\r\n  } else {\r\n    [keys, values] = extractKeysAndValues(nilDefault(from, {}));\r\n  }\r\n  const keysLength = keys.length;\r\n  if (keysLength === 0) {\r\n    return subjectString;\r\n  }\r\n  let result = '';\r\n  const valuesLength = values.length;\r\n  for (let index = 0; index < subjectString.length; index++) {\r\n    let isMatch = false;\r\n    let matchValue;\r\n    for (let keyIndex = 0; keyIndex < keysLength && keyIndex < valuesLength; keyIndex++) {\r\n      const key = keys[keyIndex];\r\n      if (subjectString.substr(index, key.length) === key) {\r\n        isMatch = true;\r\n        matchValue = values[keyIndex];\r\n        index = index + key.length - 1;\r\n        break;\r\n      }\r\n    }\r\n    result += isMatch ? matchValue : subjectString[index];\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction extractKeysAndValues(object) {\r\n  const keys = Object.keys(object);\r\n  const values = keys.sort(sortStringByLength).map(function (key) {\r\n    return object[key];\r\n  });\r\n  return [keys, values];\r\n}\r\n\r\nfunction sortStringByLength(str1, str2) {\r\n  if (str1.length === str2.length) {\r\n    return 0;\r\n  }\r\n  return str1.length < str2.length ? 1 : -1;\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\nimport includes from 'query/includes';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { REGEXP_TRIM_LEFT } from 'helper/reg_exp/const';\r\nimport toString from 'helper/string/to_string';\r\n\r\nconst reduce = Array.prototype.reduce;\r\n\r\n/**\r\n * Removes whitespaces from the left side of the `subject`.\r\n *\r\n * @function trimLeft\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to trim.\r\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\r\n * @return {string} Returns the trimmed string.\r\n * @example\r\n * v.trimLeft('  Starship Troopers');\r\n * // => 'Starship Troopers'\r\n *\r\n * v.trimLeft('***Mobile Infantry', '*');\r\n * // => 'Mobile Infantry'\r\n */\r\nexport default function trimLeft(subject, whitespace) {\r\n  const subjectString = coerceToString(subject);\r\n  if (whitespace === '' || subjectString === '') {\r\n    return subjectString;\r\n  }\r\n  const whitespaceString = toString(whitespace);\r\n  if (isNil(whitespaceString)) {\r\n    return subjectString.replace(REGEXP_TRIM_LEFT, '');\r\n  }\r\n  let matchWhitespace = true;\r\n  return reduce.call(subjectString, function(trimmed, character) {\r\n    if (matchWhitespace && includes(whitespaceString, character)) {\r\n      return trimmed;\r\n    }\r\n    matchWhitespace = false;\r\n    return trimmed + character;\r\n  }, '');\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\nimport includes from 'query/includes';\r\nimport isNil from 'helper/object/is_nil';\r\nimport { REGEXP_TRIM_RIGHT } from 'helper/reg_exp/const';\r\nimport toString from 'helper/string/to_string';\r\n\r\nconst reduceRight = Array.prototype.reduceRight;\r\n\r\n/**\r\n * Removes whitespaces from the right side of the `subject`.\r\n *\r\n * @function trimRight\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param {string} [subject=''] The string to trim.\r\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\r\n * @return {string} Returns the trimmed string.\r\n * @example\r\n * v.trimRight('the fire rises   ');\r\n * // => 'the fire rises'\r\n *\r\n * v.trimRight('do you feel in charge?!!!', '!');\r\n * // => 'do you feel in charge?'\r\n */\r\nexport default function trimRight(subject, whitespace) {\r\n  const subjectString = coerceToString(subject);\r\n  if (whitespace === '' || subjectString === '') {\r\n    return subjectString;\r\n  }\r\n  const whitespaceString = toString(whitespace);\r\n  if (isNil(whitespaceString)) {\r\n    return subjectString.replace(REGEXP_TRIM_RIGHT, '');\r\n  }\r\n  let matchWhitespace = true;\r\n  return reduceRight.call(subjectString, function(trimmed, character) {\r\n    if (matchWhitespace && includes(whitespaceString, character)) {\r\n      return trimmed;\r\n    }\r\n    matchWhitespace = false;\r\n    return character + trimmed;\r\n  }, '');\r\n}","import coerceToBoolean from 'helper/boolean/coerce_to_boolean';\r\nimport coerceToNumber from 'helper/number/coerce_to_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\n\r\nconst OPTION_WIDTH = 'width';\r\nconst OPTION_NEW_LINE = 'newLine';\r\nconst OPTION_INDENT = 'indent';\r\nconst OPTION_CUT = 'cut';\r\n\r\n/**\r\n * Wraps `subject` to a given number of characters using a string break character.\r\n *\r\n * @function wordWrap\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Manipulate\r\n * @param  {string} [subject=''] The string to wrap.\r\n * @param  {Object} [options={}] The wrap options.\r\n * @param  {number} [options.width=75] The number of characters at which to wrap.\r\n * @param  {string} [options.newLine='\\n'] The string to add at the end of line.\r\n * @param  {string} [options.indent='']  The string to intend the line.\r\n * @param  {boolean} [options.cut=false] When `false` (default) does not split the word even if word length is bigger than `width`. <br/>\r\n *                                       When `true` breaks the word that has length bigger than `width`.\r\n *\r\n * @return {string} Returns wrapped string.\r\n * @example\r\n * v.wordWrap('Hello world', {\r\n *   width: 5\r\n * });\r\n * // => 'Hello\\nworld'\r\n *\r\n * v.wordWrap('Hello world', {\r\n *   width: 5,\r\n *   newLine: '<br/>',\r\n *   indent: '__'\r\n * });\r\n * // => '__Hello<br/>__world'\r\n *\r\n * v.wordWrap('Wonderful world', {\r\n *   width: 5,\r\n *   cut: true\r\n * });\r\n * // => 'Wonde\\nrful\\nworld'\r\n *\r\n */\r\nexport default function wordWrap(subject, options = {}) {\r\n  const subjectString = coerceToString(subject);\r\n  const { width, newLine, indent, cut } = determineOptions(options);\r\n  if (subjectString === '' || width <= 0) {\r\n    return indent;\r\n  }\r\n  const subjectLength = subjectString.length;\r\n  const substring = subjectString.substring.bind(subjectString);\r\n  let offset = 0;\r\n  let wrappedLine = '';\r\n  while ((subjectLength - offset) > width) {\r\n    if (subjectString[offset] === ' ') {\r\n      offset++;\r\n      continue;\r\n    }\r\n    let spaceToWrapAt = subjectString.lastIndexOf(' ', width + offset);\r\n    if (spaceToWrapAt >= offset) {\r\n      wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;\r\n      offset = spaceToWrapAt + 1;\r\n    } else {\r\n      if (cut) {\r\n        wrappedLine += indent + substring(offset, width + offset) + newLine;\r\n        offset += width;\r\n      } else {\r\n        spaceToWrapAt = subjectString.indexOf(' ', width + offset);\r\n        if (spaceToWrapAt >= 0) {\r\n          wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;\r\n          offset = spaceToWrapAt + 1;\r\n        } else {\r\n          wrappedLine += indent + substring(offset);\r\n          offset = subjectLength;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (offset < subjectLength) {\r\n    wrappedLine += indent + substring(offset);\r\n  }\r\n  return wrappedLine;\r\n}\r\n\r\n/**\r\n * Determine the word wrap options. The missing values are filled with defaults.\r\n *\r\n * @param  {Object} options  The options object.\r\n * @return {Object}          The word wrap options, with default settings if necessary.\r\n * @ignore\r\n */\r\nfunction determineOptions(options) {\r\n  return {\r\n    width: coerceToNumber(options[OPTION_WIDTH], 75),\r\n    newLine: coerceToString(options[OPTION_NEW_LINE], '\\n'),\r\n    indent: coerceToString(options[OPTION_INDENT], ''),\r\n    cut: coerceToBoolean(options[OPTION_CUT], false)\r\n  };\r\n}","import clipNumber from 'helper/number/clip_number';\r\nimport coerceToString from 'helper/string/coerce_to_string';\r\nimport isNil from 'helper/object/is_nil';\r\nimport toInteger from 'helper/number/to_integer';\r\n\r\n/**\r\n * Checks whether `subject` ends with `end`.\r\n *\r\n * @function endsWith\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Query\r\n * @param {string} [subject=''] The string to verify.\r\n * @param {string} end The ending string.\r\n * @param {number} [position=subject.length] Search within `subject` as if the string were only `position` long.\r\n * @return {boolean} Returns `true` if `subject` ends with `end` or `false` otherwise.\r\n * @example\r\n * v.endsWith('red alert', 'alert');\r\n * // => true\r\n *\r\n * v.endsWith('metro south', 'metro');\r\n * // => false\r\n *\r\n * v.endsWith('Murphy', 'ph', 5);\r\n * // => true\r\n */\r\nexport default function endsWith(subject, end, position) {\r\n  if (isNil(end)) {\r\n    return false;\r\n  }\r\n  const subjectString = coerceToString(subject);\r\n  const endString = coerceToString(end);\r\n  if (endString === '') {\r\n    return true;\r\n  }\r\n  position = isNil(position) ? subjectString.length : clipNumber(toInteger(position), 0, subjectString.length);\r\n  position -= endString.length;\r\n  const lastIndex = subjectString.indexOf(endString, position);\r\n  return lastIndex !== -1 && lastIndex === position;\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\nimport toString from 'helper/string/to_string';\r\n\r\n/**\r\n * Checks whether `subject` matches the regular expression `pattern`.\r\n *\r\n * @function matches\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Query\r\n * @param {string} [subject=''] The string to verify.\r\n * @param {RegExp|string} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\r\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\r\n * @return {boolean} Returns `true` if `subject` matches `pattern` or `false` otherwise.\r\n * @example\r\n * v.matches('pluto', /plu.{2}/);\r\n * // => true\r\n *\r\n * v.matches('sun', 'S', 'i');\r\n * // => true\r\n *\r\n * v.matches('apollo 11', '\\\\d{3}');\r\n * // => false\r\n */\r\nexport default function matches(subject, pattern, flags) {\r\n  const subjectString = coerceToString(subject);\r\n  const flagsString = coerceToString(flags);\r\n  let patternString;\r\n  if (!(pattern instanceof RegExp)) {\r\n    patternString = toString(pattern);\r\n    if (patternString === null) {\r\n      return false;\r\n    }\r\n    pattern = new RegExp(patternString, flagsString);\r\n  }\r\n  return pattern.test(subjectString);\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\n\r\nconst BYRE_ORDER_MARK = '\\uFEFF';\r\n\r\n/**\r\n * Strips the byte order mark (BOM) from the beginning of `subject`.\r\n *\r\n * @function stripBom\r\n * @static\r\n * @since 1.2.0\r\n * @memberOf Strip\r\n * @param {string} [subject=''] The string to strip from.\r\n * @return {string} Returns the stripped string.\r\n * @example\r\n *\r\n * v.stripBom('\\uFEFFsummertime sadness');\r\n * // => 'summertime sadness'\r\n *\r\n * v.stripBom('summertime happiness');\r\n * // => 'summertime happiness'\r\n *\r\n */\r\nexport default function trim(subject) {\r\n  const subjectString = coerceToString(subject);\r\n  if (subjectString === '') {\r\n    return '';\r\n  }\r\n  if (subjectString[0] === BYRE_ORDER_MARK) {\r\n    return subjectString.substring(1);\r\n  }\r\n  return subjectString;\r\n}","import { REGEXP_WHITESPACE } from 'helper/reg_exp/const';\r\n\r\nconst STATE_START_TAG = 0;\r\nconst STATE_NON_WHITESPACE = 1;\r\nconst STATE_DONE = 2;\r\n\r\n/**\r\n * Parses the tag name from html content.\r\n *\r\n * @ignore\r\n * @param {string} tagContent The tag content.\r\n * @return {string} Returns the tag name.\r\n */\r\nexport default function parseTagName(tagContent) {\r\n  let state = STATE_START_TAG;\r\n  let tagName = '';\r\n  let index = 0;\r\n  while (state !== STATE_DONE) {\r\n    const char = tagContent[index++].toLowerCase();\r\n    switch (char) {\r\n      case '<':\r\n        break;\r\n      case '>':\r\n        state = STATE_DONE;\r\n        break;\r\n      default:\r\n        if (REGEXP_WHITESPACE.test(char)) {\r\n          if (state === STATE_NON_WHITESPACE) {\r\n            state = STATE_DONE;\r\n          }\r\n        } else {\r\n          if (state === STATE_START_TAG) {\r\n            state = STATE_NON_WHITESPACE;\r\n          }\r\n          if (char !== '/') {\r\n            tagName += char;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n  }\r\n  return tagName;\r\n}","import coerceToString from 'helper/string/coerce_to_string';\r\nimport hasSubstringAtIndex from 'helper/string/has_substring_at_index';\r\nimport parseTagList from 'helper/strip/parse_tag_list';\r\nimport parseTagName from 'helper/strip/parse_tag_name';\r\n\r\nconst STATE_OUTPUT = 0;\r\nconst STATE_HTML = 1;\r\nconst STATE_EXCLAMATION = 2;\r\nconst STATE_COMMENT = 3;\r\n\r\n/**\r\n * Strips HTML tags from `subject`.\r\n *\r\n * @function stripTags\r\n * @static\r\n * @since 1.1.0\r\n * @memberOf Strip\r\n * @param {string} [subject=''] The string to strip from.\r\n * @param {string|Array} [allowableTags] The string `'<tag1><tag2>'` or array `['tag1', 'tag2']` of tags that should not be stripped.\r\n * @param {string} [replacement=''] The string to replace the stripped tag.\r\n * @return {string} Returns the stripped string.\r\n * @example\r\n *\r\n * v.stripTags('<span><a href=\"#\">Summer</a> is nice</span>');\r\n * // => 'Summer is nice'\r\n *\r\n * v.stripTags('<span><i>Winter</i> is <b>cold</b></span>', ['b', 'i']);\r\n * // => '<i>Winter</i> is <b>cold</b>'\r\n *\r\n * v.stripTags('Sun<br/>set', '', '-');\r\n * // => 'Sun-set'\r\n */\r\nexport default function trim(subject, allowableTags, replacement) {\r\n  subject = coerceToString(subject);\r\n  if (subject === '') {\r\n    return '';\r\n  }\r\n  if (!Array.isArray(allowableTags)) {\r\n    const allowableTagsString = coerceToString(allowableTags);\r\n    allowableTags = allowableTagsString === '' ? [] : parseTagList(allowableTagsString);\r\n  }\r\n  const replacementString = coerceToString(replacement);\r\n  const length = subject.length;\r\n  const hasAllowableTags = allowableTags.length > 0;\r\n  const hasSubstring = hasSubstringAtIndex.bind(null, subject);\r\n  let state = STATE_OUTPUT;\r\n  let depth = 0;\r\n  let output = '';\r\n  let tagContent = '';\r\n  let quote = null;\r\n  for (let index = 0; index < length; index++) {\r\n    const char = subject[index];\r\n    let advance = false;\r\n    switch (char) {\r\n      case '<':\r\n        if (quote) {\r\n          break;\r\n        }\r\n        if (hasSubstring('< ', index, false)) {\r\n          advance = true;\r\n          break;\r\n        }\r\n        if (state === STATE_OUTPUT) {\r\n          advance = true;\r\n          state = STATE_HTML;\r\n          break;\r\n        }\r\n        if (state === STATE_HTML) {\r\n          depth++;\r\n          break;\r\n        }\r\n        advance = true;\r\n        break;\r\n      case '!':\r\n        if (state === STATE_HTML && hasSubstring('<!', index)) {\r\n          state = STATE_EXCLAMATION;\r\n          break;\r\n        }\r\n        advance = true;\r\n        break;\r\n      case '-':\r\n        if (state === STATE_EXCLAMATION && hasSubstring('!--', index)) {\r\n          state = STATE_COMMENT;\r\n          break;\r\n        }\r\n        advance = true;\r\n        break;\r\n      case '\"':\r\n      case \"'\":\r\n        if (state === STATE_HTML) {\r\n          if (quote === char) {\r\n            quote = null;\r\n          } else if (!quote) {\r\n            quote = char;\r\n          }\r\n        }\r\n        advance = true;\r\n        break;\r\n      case 'E':\r\n      case 'e':\r\n        if (state === STATE_EXCLAMATION && hasSubstring('doctype', index)) {\r\n          state = STATE_HTML;\r\n          break;\r\n        }\r\n        advance = true;\r\n        break;\r\n      case '>':\r\n        if (depth > 0) {\r\n          depth--;\r\n          break;\r\n        }\r\n        if (quote) {\r\n          break;\r\n        }\r\n        if (state === STATE_HTML) {\r\n          quote = null;\r\n          state = STATE_OUTPUT;\r\n          if (hasAllowableTags) {\r\n            tagContent += '>';\r\n            const tagName = parseTagName(tagContent);\r\n            if (allowableTags.indexOf(tagName.toLowerCase()) !== -1) {\r\n              output += tagContent;\r\n            } else {\r\n              output += replacementString;\r\n            }\r\n            tagContent = '';\r\n          } else {\r\n            output += replacementString;\r\n          }\r\n          break;\r\n        }\r\n        if (state === STATE_EXCLAMATION || state === STATE_COMMENT && hasSubstring('-->', index)) {\r\n          quote = null;\r\n          state = STATE_OUTPUT;\r\n          tagContent = '';\r\n          break;\r\n        }\r\n        advance = true;\r\n        break;\r\n      default:\r\n        advance = true;\r\n    }\r\n    if (advance) {\r\n      switch (state) {\r\n        case STATE_OUTPUT:\r\n          output += char;\r\n          break;\r\n        case STATE_HTML:\r\n          if (hasAllowableTags) {\r\n            tagContent += char;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  return output;\r\n}","/**\r\n * A property that contains the library <a href=\"http://semver.org/\">semantic version number</a>.\r\n * @name version\r\n * @static\r\n * @since 1.0.0\r\n * @memberOf Util\r\n * @type string\r\n * @example\r\n * v.version\r\n * // => '1.4.0'\r\n */\r\nconst version = '1.4.0';\r\n\r\nexport default version;","import functions from 'functions';\r\n\r\n\r\n/**\r\n * The chain wrapper constructor.\r\n *\r\n * @ignore\r\n * @param  {string}       subject               The string to be wrapped.\r\n * @param  {boolean}      [explicitChain=false] A boolean that indicates if the chain sequence is explicit or implicit.\r\n * @return {ChainWrapper}                       Returns a new instance of `ChainWrapper`\r\n * @constructor\r\n */\r\nfunction ChainWrapper(subject, explicitChain) {\r\n  this._wrappedValue = subject;\r\n  this._explicitChain = explicitChain;\r\n}\r\n\r\n/**\r\n * Unwraps the chain sequence wrapped value.\r\n *\r\n * @memberof Chain\r\n * @since 1.0.0\r\n * @function __proto__value\r\n * @return {*} Returns the unwrapped value.\r\n * @example\r\n * v\r\n *  .chain('Hello world')\r\n *  .replace('Hello', 'Hi')\r\n *  .lowerCase()\r\n *  .slugify()\r\n *  .value()\r\n * // => 'hi-world'\r\n *\r\n * v(' Space travel ')\r\n *  .trim()\r\n *  .truncate(8)\r\n *  .value()\r\n * // => 'Space...'\r\n */\r\nChainWrapper.prototype.value = function() {\r\n  return this._wrappedValue;\r\n};\r\n\r\n/**\r\n * Override the default object valueOf().\r\n *\r\n * @ignore\r\n * @return {*} Returns the wrapped value.\r\n */\r\nChainWrapper.prototype.valueOf = function() {\r\n  return this.value();\r\n};\r\n\r\n/**\r\n * Returns the wrapped value to be used in JSON.stringify().\r\n *\r\n * @ignore\r\n * @return {*} Returns the wrapped value.\r\n */\r\nChainWrapper.prototype.toJSON = function() {\r\n  return this.value();\r\n};\r\n\r\n/**\r\n * Returns the string representation of the wrapped value.\r\n *\r\n * @ignore\r\n * @return {string} Returns the string representation.\r\n */\r\nChainWrapper.prototype.toString = function() {\r\n  return String(this.value());\r\n};\r\n\r\n/**\r\n * Creates a new chain object that enables <i>explicit</i> chain sequences.\r\n * Use `v.prototype.value()` to unwrap the result. <br/>\r\n * Does not modify the wrapped value.\r\n *\r\n * @memberof Chain\r\n * @since 1.0.0\r\n * @function __proto__chain\r\n * @return {Object} Returns the wrapper in <i>explicit</i> mode.\r\n * @example\r\n * v('Back to School')\r\n *  .chain()\r\n *  .lowerCase()\r\n *  .words()\r\n *  .value()\r\n * // => ['back', 'to', 'school']\r\n *\r\n * v(\" Back to School \")\r\n *  .chain()\r\n *  .trim()\r\n *  .truncate(7)\r\n *  .value()\r\n * // => 'Back...'\r\n */\r\nChainWrapper.prototype.chain = function() {\r\n  return new ChainWrapper(this._wrappedValue, true);\r\n};\r\n\r\n/**\r\n * Modifies the wrapped value with the invocation result of `changer` function. The current wrapped value is the\r\n * argument of `changer` invocation.\r\n *\r\n * @memberof Chain\r\n * @since 1.0.0\r\n * @function __proto__thru\r\n * @param  {Function} changer The function to invoke.\r\n * @return {Object}           Returns the new wrapper that wraps the invocation result of `changer`.\r\n * @example\r\n * v\r\n *  .chain('sun is shining')\r\n *  .words()\r\n *  .thru(function(words) {\r\n *    return words[0];\r\n *  })\r\n *  .value()\r\n * // => 'sun'\r\n *\r\n */\r\nChainWrapper.prototype.thru = function(changer) {\r\n  if (typeof changer === 'function') {\r\n    return new ChainWrapper(changer(this._wrappedValue), this._explicitChain);\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * A boolean that indicates if the chain sequence is explicit or implicit.\r\n * @ignore\r\n * @type {boolean}\r\n * @private\r\n */\r\nChainWrapper.prototype._explicitChain = true;\r\n\r\n/**\r\n * Make a voca function chainable.\r\n *\r\n * @ignore\r\n * @param  {Function} functionInstance The function to make chainable\r\n * @return {Function}                  Returns the chainable function\r\n */\r\nfunction makeFunctionChainable(functionInstance) {\r\n  return function(...args) {\r\n    const result = functionInstance(this._wrappedValue, ...args);\r\n    if (this._explicitChain || typeof result === 'string') {\r\n      return new ChainWrapper(result, this._explicitChain);\r\n    } else {\r\n      return result;\r\n    }\r\n  };\r\n}\r\n\r\nObject.keys(functions).forEach(function(name) {\r\n  ChainWrapper.prototype[name] = makeFunctionChainable(functions[name]);\r\n});\r\n\r\n\r\nexport default ChainWrapper;","/**\r\n * A regular expression string matching digits\r\n *\r\n * @type {string}\r\n * @ignore\r\n */\r\nexport const digit = '\\\\d';\r\n\r\n/**\r\n * A regular expression string matching whitespace\r\n *\r\n * @type {string}\r\n * @ignore\r\n */\r\nexport const whitespace = '\\\\s\\\\uFEFF\\\\xA0';\r\n\r\n/**\r\n * A regular expression string matching high surrogate\r\n *\r\n * @type {string}\r\n * @ignore\r\n */\r\nexport const highSurrogate = '\\\\uD800-\\\\uDBFF';\r\n\r\n/**\r\n * A regular expression string matching low surrogate\r\n *\r\n * @type {string}\r\n * @ignore\r\n */\r\nexport const lowSurrogate = '\\\\uDC00-\\\\uDFFF';\r\n\r\n/**\r\n * A regular expression string matching diacritical mark\r\n *\r\n * @type {string}\r\n * @ignore\r\n */\r\nexport const diacriticalMark = '\\\\u0300-\\\\u036F\\\\u1AB0-\\\\u1AFF\\\\u1DC0-\\\\u1DFF\\\\u20D0-\\\\u20FF\\\\uFE20-\\\\uFE2F';\r\n\r\n/**\r\n * A regular expression to match the base character for a combining mark\r\n *\r\n * @type {string}\r\n * @ignore\r\n */\r\nexport const base = '\\\\0-\\\\u02FF\\\\u0370-\\\\u1AAF\\\\u1B00-\\\\u1DBF\\\\u1E00-\\\\u20CF\\\\u2100-\\\\uD7FF\\\\uE000-\\\\uFE1F\\\\uFE30-\\\\uFFFF';\r\n\r\n/**\r\n * Regular expression to match combining marks\r\n *\r\n * @see http://unicode.org/faq/char_combmark.html\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_COMBINING_MARKS = new RegExp('([' + base + ']|[' + highSurrogate + '][' + lowSurrogate + ']|[' + highSurrogate + '](?![' + lowSurrogate + '])|(?:[^' + highSurrogate + ']|^)[' + lowSurrogate + '])([' + diacriticalMark + ']+)', 'g');\r\n\r\n/**\r\n * Regular expression to match surrogate pairs\r\n *\r\n * @see http://www.unicode.org/faq/utf_bom.html#utf16-2\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_SURROGATE_PAIRS = new RegExp('([' + highSurrogate + '])([' + lowSurrogate + '])', 'g');\r\n\r\n/**\r\n * Regular expression to match a unicode character\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_UNICODE_CHARACTER = new RegExp(\r\n  '((?:[' + base + ']|[' + highSurrogate + '][' + lowSurrogate + ']|[' + highSurrogate + '](?![' + lowSurrogate + '])|(?:[^' + highSurrogate + ']|^)[' + lowSurrogate + '])(?:[' + diacriticalMark + ']+))|\\\r\n([' + highSurrogate + '][' + lowSurrogate + '])|\\\r\n([\\\\n\\\\r\\\\u2028\\\\u2029])|\\\r\n(.)', 'g');\r\n\r\n/**\r\n * Regular expression to match whitespaces\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_WHITESPACE = new RegExp('[' + whitespace + ']');\r\n\r\n/**\r\n * Regular expression to match whitespaces from the left side\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_TRIM_LEFT = new RegExp('^[' + whitespace + ']+');\r\n\r\n/**\r\n * Regular expression to match whitespaces from the right side\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_TRIM_RIGHT = new RegExp('[' + whitespace + ']+$');\r\n\r\n/**\r\n * Regular expression to match digit characters\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_DIGIT = new RegExp('^' + digit + '+$');\r\n\r\n/**\r\n * Regular expression to match regular expression special characters\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_SPECIAL_CHARACTERS = /[-[\\]{}()*+!<=:?./\\\\^$|#,]/g;\r\n\r\n/**\r\n * Regular expression to match not latin characters\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_NON_LATIN = /[^A-Za-z0-9]/g;\r\n\r\n/**\r\n * Regular expression to match HTML special characters.\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_HTML_SPECIAL_CHARACTERS = /[<>&\"'`]/g;\r\n\r\n/**\r\n * Regular expression to match sprintf format string\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_CONVERSION_SPECIFICATION = /(%{1,2})(?:(\\d+)\\$)?(\\+)?([ 0]|'.{1})?(-)?(\\d+)?(?:\\.(\\d+))?([bcdiouxXeEfgGs])?/g;\r\n\r\n/**\r\n * Regular expression to match trailing zeros in a number\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_TRAILING_ZEROS = /\\.?0+$/g;\r\n\r\n/**\r\n * Regular expression to match flags from a regular expression.\r\n *\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\nexport const REGEXP_FLAGS = /[gimuy]*$/;\r\n\r\n/**\r\n * Regular expression to match a list of tags.\r\n *\r\n * @see https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-name\r\n * @type {RegExp}\r\n * @ignore\r\n */\r\n\r\nexport const REGEXP_TAG_LIST = /<([A-Za-z0-9]+)>/g;","// Type specifiers\r\nexport const TYPE_INTEGER                       = 'i';\r\nexport const TYPE_INTEGER_BINARY                = 'b';\r\nexport const TYPE_INTEGER_ASCII_CHARACTER       = 'c';\r\nexport const TYPE_INTEGER_DECIMAL               = 'd';\r\nexport const TYPE_INTEGER_OCTAL                 = 'o';\r\nexport const TYPE_INTEGER_UNSIGNED_DECIMAL      = 'u';\r\nexport const TYPE_INTEGER_HEXADECIMAL           = 'x';\r\nexport const TYPE_INTEGER_HEXADECIMAL_UPPERCASE = 'X';\r\nexport const TYPE_FLOAT_SCIENTIFIC              = 'e';\r\nexport const TYPE_FLOAT_SCIENTIFIC_UPPERCASE    = 'E';\r\nexport const TYPE_FLOAT                         = 'f';\r\nexport const TYPE_FLOAT_SHORT                   = 'g';\r\nexport const TYPE_FLOAT_SHORT_UPPERCASE         = 'G';\r\nexport const TYPE_STRING                        = 's';\r\n\r\n// Simple literals\r\nexport const LITERAL_PERCENT           = '%';\r\nexport const LITERAL_SINGLE_QUOTE      = \"'\";\r\nexport const LITERAL_PLUS              = '+';\r\nexport const LITERAL_MINUS             = '-';\r\nexport const LITERAL_PERCENT_SPECIFIER = '%%';\r\n\r\n// Radix constants to format numbers\r\nexport const RADIX_BINARY      = 2;\r\nexport const RADIX_OCTAL       = 8;\r\nexport const RADIX_DECIMAL     = 10;\r\nexport const RADIX_HEXADECIMAL = 16;","/* eslint sort-imports: \"off\" */\r\n\r\n/**\r\n * Functions to change the case\r\n * @namespace Case\r\n */\r\nimport camelCase from './case/camel_case';\r\nimport capitalize from './case/capitalize';\r\nimport decapitalize from './case/decapitalize';\r\nimport kebabCase from './case/kebab_case';\r\nimport lowerCase from './case/lower_case';\r\nimport snakeCase from './case/snake_case';\r\nimport upperCase from './case/upper_case';\r\nimport swapCase from './case/swap_case';\r\nimport titleCase from './case/title_case';\r\nimport truncate from './chop/truncate';\r\n\r\n/**\r\n * Chain functions\r\n * @namespace Chain\r\n */\r\n\r\n/**\r\n * Functions to cut a string\r\n * @namespace Chop\r\n */\r\nimport charAt from './chop/char_at';\r\nimport codePointAt from './chop/code_point_at';\r\nimport first from './chop/first';\r\nimport graphemeAt from './chop/grapheme_at';\r\nimport last from './chop/last';\r\nimport prune from './chop/prune';\r\nimport slice from './chop/slice';\r\nimport substr from './chop/substr';\r\nimport substring from './chop/substring';\r\n\r\n/**\r\n * Functions to count characters in a string\r\n * @namespace Count\r\n */\r\nimport count from './count/count';\r\nimport countGraphemes from './count/count_graphemes';\r\nimport countSubstrings from './count/count_substrings';\r\nimport countWhere from './count/count_where';\r\nimport countWords from './count/count_words';\r\n\r\n/**\r\n * Functions to format\r\n * @namespace Format\r\n */\r\nimport sprintf from './format/sprintf';\r\nimport vprintf from './format/vprintf';\r\n\r\n/**\r\n * Functions to escape RegExp special characters\r\n * @namespace Escape\r\n */\r\nimport escapeHtml from './escape/escape_html';\r\nimport escapeRegExp from './escape/escape_reg_exp';\r\nimport unescapeHtml from './escape/unescape_html';\r\n\r\n/**\r\n * Functions to find index\r\n * @namespace Index\r\n */\r\nimport indexOf from './index/index_of';\r\nimport lastIndexOf from './index/last_index_of';\r\nimport search from './index/search';\r\n\r\n/**\r\n * Functions to manipulate a string\r\n * @namespace Manipulate\r\n */\r\nimport insert from './manipulate/insert';\r\nimport latinise from './manipulate/latinise';\r\nimport pad from './manipulate/pad';\r\nimport padLeft from './manipulate/pad_left';\r\nimport padRight from './manipulate/pad_right';\r\nimport repeat from './manipulate/repeat';\r\nimport replace from './manipulate/replace';\r\nimport replaceAll from './manipulate/replace_all';\r\nimport reverse from './manipulate/reverse';\r\nimport reverseGrapheme from './manipulate/reverse_grapheme';\r\nimport slugify from './manipulate/slugify';\r\nimport splice from './manipulate/splice';\r\nimport tr from './manipulate/tr';\r\nimport trim from './manipulate/trim';\r\nimport trimLeft from './manipulate/trim_left';\r\nimport trimRight from './manipulate/trim_right';\r\nimport wordWrap from './manipulate/word_wrap';\r\n\r\n/**\r\n * Functions to query a string\r\n * @namespace Query\r\n */\r\nimport endsWith from './query/ends_with';\r\nimport includes from './query/includes';\r\nimport isAlpha from './query/is_alpha';\r\nimport isAlphaDigit from './query/is_alpha_digit';\r\nimport isBlank from './query/is_blank';\r\nimport isDigit from './query/is_digit';\r\nimport isEmpty from './query/is_empty';\r\nimport isLowerCase from './query/is_lower_case';\r\nimport isNumeric from './query/is_numeric';\r\nimport isPalindrome from './query/is_palindrome';\r\nimport isString from './query/is_string';\r\nimport isUpperCase from './query/is_upper_case';\r\nimport matches from './query/matches';\r\nimport startsWith from './query/starts_with';\r\n\r\n/**\r\n * Functions to split a string\r\n * @namespace Split\r\n */\r\nimport chars from './split/chars';\r\nimport codePoints from './split/code_points';\r\nimport graphemes from './split/graphemes';\r\nimport split from './split/split';\r\nimport words from './split/words';\r\n\r\n/**\r\n * Functions to strip a string\r\n * @namespace Strip\r\n */\r\nimport stripBom from './strip/strip_bom';\r\nimport stripTags from './strip/strip_tags';\r\n\r\n/**\r\n * Util functions and properties\r\n * @namespace Util\r\n */\r\nimport noConflict from './util/no_conflict';\r\nimport version from './util/version';\r\n\r\nexport default {\r\n  camelCase,\r\n  capitalize,\r\n  decapitalize,\r\n  kebabCase,\r\n  lowerCase,\r\n  snakeCase,\r\n  swapCase,\r\n  titleCase,\r\n  upperCase,\r\n\r\n  count,\r\n  countGraphemes,\r\n  countSubstrings,\r\n  countWhere,\r\n  countWords,\r\n\r\n  escapeHtml,\r\n  escapeRegExp,\r\n  unescapeHtml,\r\n\r\n  sprintf,\r\n  vprintf,\r\n\r\n  indexOf,\r\n  lastIndexOf,\r\n  search,\r\n\r\n  charAt,\r\n  codePointAt,\r\n  first,\r\n  graphemeAt,\r\n  last,\r\n  prune,\r\n  slice,\r\n  substr,\r\n  substring,\r\n  truncate,\r\n\r\n  insert,\r\n  latinise,\r\n  pad,\r\n  padLeft,\r\n  padRight,\r\n  repeat,\r\n  replace,\r\n  replaceAll,\r\n  reverse,\r\n  reverseGrapheme,\r\n  slugify,\r\n  splice,\r\n  tr,\r\n  trim,\r\n  trimLeft,\r\n  trimRight,\r\n  wordWrap,\r\n\r\n  endsWith,\r\n  includes,\r\n  isAlpha,\r\n  isAlphaDigit,\r\n  isBlank,\r\n  isDigit,\r\n  isEmpty,\r\n  isLowerCase,\r\n  isNumeric,\r\n  isPalindrome,\r\n  isString,\r\n  isUpperCase,\r\n  matches,\r\n  startsWith,\r\n\r\n  chars,\r\n  codePoints,\r\n  graphemes,\r\n  split,\r\n  words,\r\n\r\n  stripBom,\r\n  stripTags,\r\n\r\n  noConflict,\r\n  version\r\n};"],"names":["isNil","value","undefined","coerceToBoolean","defaultValue","Boolean","isString","subject","coerceToString","String","capitalize","restToLower","subjectString","restToLowerCaseBoolean","toLowerCase","substr","toUpperCase","lowerCase","words","toString","character","toInteger","firstCodePoint","charCodeAt","secondCodePoint","isHighSurrogate","truncatedLength","pattern","clipNumber","buildPadding","replacementNumber","TYPE_FLOAT_SHORT_UPPERCASE","formatFloatAsShort","TYPE_INTEGER_ASCII_CHARACTER","TYPE_INTEGER","formatIntegerDecimal","TYPE_INTEGER_HEXADECIMAL","TYPE_INTEGER_HEXADECIMAL_UPPERCASE","TYPE_FLOAT","TYPE_FLOAT_SCIENTIFIC","TYPE_FLOAT_SCIENTIFIC_UPPERCASE","TYPE_FLOAT_SHORT","formatFloat","alignAndPad","coerceToNumber","percent","matchIndex","getDiacriticsMap","diacriticsMap","lengthInt","paddingSideLength","paddingSideRemainingLength","indexOf","reversedString","tr","matchValue","object","matchWhitespace","indent","subjectLength","substring","offset","newLine","lastIndex","STATE_DONE","match","REGEXP_WHITESPACE","char","hasSubstringAtIndex","tagContent","quote","state","STATE_HTML","STATE_EXCLAMATION","index","STATE_COMMENT","depth","STATE_OUTPUT","functionInstance","arguments","result","lowSurrogate","diacriticalMark","base","REGEXP_COMBINING_MARKS","RegExp","REGEXP_SURROGATE_PAIRS","REGEXP_UNICODE_CHARACTER","ReplacementIndex","this","TYPE_STRING","LITERAL_SINGLE_QUOTE","LITERAL_PLUS","LITERAL_MINUS","LITERAL_PERCENT_SPECIFIER","RADIX_HEXADECIMAL","unescapeHtml"],"mappings":";;;;;;;6KAQA,SAAwBA,EAAMC,eACXC,IAAVD,GAAiC,OAAVA,ECEhC,SAAwBE,EAAgBF,OAAOG,iEACzCJ,EAAMC,GACDG,EAEFC,QAAQJ,GCCjB,SAAwBK,EAASC,SACL,iBAAZA,ECFhB,SAAwBC,EAAeP,OAAOG,yDAAe,UACvDJ,EAAMC,GACDG,EAELE,EAASL,GACJA,EAEFQ,OAAOR,GCDhB,SAAwBS,EAAWH,EAASI,OACtCC,EAAgBJ,EAAeD,GAC7BM,EAAyBV,EAAgBQ,SACzB,KAAlBC,EACK,IAELC,MACcD,EAAcE,eAEzBF,EAAcG,OAAO,EAAG,GAAGC,cAAgBJ,EAAcG,OAAO,ICZzE,SAAwBE,EAAUV,UACVC,EAAeD,EAAS,IACzBO,0DCDdL,gDCkBAS,eACeC,wBAGJP,8dCfAQ,8RCTXnB,yCCAAoB,iDCiBAT,4GChCT,uUCgCQU,IAA+BC,GACjCC,WACAC,mBACgB,IACCD,8aCDjBE,WACkBC,YAAgCC,4iBCR/ChB,wNCCaJ,SACCI,KAAjBgB,sICGGC,qGCAAjB,6TCLoBkB,mGASpBC,KACoBC,+QCZpBC,aACOxB,qKAePU,0OCNAe,kBACcC,+BAEdF,kBAGAG,QACAC,0BAIAC,QACAC,QACAC,QACAC,QACAV,KACcW,6BAIdC,2gBC3BMC,oCANbC,+5BCKOC,mHCFAlC,uGC0GAmC,uCAKAC,sPCxGeC,SAChBC,OACAC,0BACyBD,gOCJVE,wKCHd7C,gLCAH8C,sQCYuBzC,oGCDpB0C,qQAqBeC,+DAOPA,+FAQNC,4GC5Ca,KAAlBC,yKCAkB,KAAlBA,kQCaoBC,qFAIlBC,YACAC,WACFC,sBAEJ,kIAcsBC,0FAYID,qLC5CpBE,kxBCFN,ibCLAvD,mQC1BIwD,OAANC,+FAsBYC,uDAQEC,yHCUSC,yCAIjBC,OACAC,0DAMa,4DAOPC,sDASMC,YAGND,IAAUC,iBAIJ,YAEP,OACCD,IAAUE,cAAyCC,GAC7CC,YAGA,YAEP,qEASHH,sBAIID,6BAMD,OACCK,yDAOAL,oCAOE,8IAmBIM,oGC5IlB,yHCkJ+BC,4EAGzBC,wHAKNC,gGCpJA,IAwBaC,GAAe,kBAQfC,GAAkB,8EAQlBC,GAAO,wGASPC,GAAyB,IAAIC,OAAO,KAAOF,GAAO,uBAA+BF,GAAe,0BAAkCA,GAAe,+BAAuCA,GAAe,OAASC,GAAkB,MAAO,KASzOI,GAAyB,IAAID,OAAO,yCAAqD,KAQzFE,GAA2B,IAAIF,OAC1C,QAAUF,GAAO,uBAA+BF,GAAe,0BAAkCA,GAAe,+BAAuCA,GAAe,SAAWC,GAAkB,8wGCtErMM,uDACkDC,gBAIlD,IAAapD,OACAE,OACAC,OACAF,OACAG,OACAV,GAAN,IACM2D,4BAIAC,OACAC,OACAC,OACAC,cAMAC,khBlBZN,OACA,OACA,0CACA,gBACA,kBACA,sBACA,uCACA,aACA,uBACA,sBACA,8BACA,WACA,qBACA,yBACA,eACA,uBACA,mDACA,iBACA,WACA,wBACA,wBACA,sBACA,yCACA,cACA,iBACA,WACA,wBACA,qBACA,2CACA,gBACA,mBACA,sBACA,wCACA,aACA,uBACA,uBACA,+BACA,YACA,qBACA,0BACA,eACA,wBACA,mDACA,iBACA,WACA,wBACA,qLAQC,QACA,QACA,SACA,SACA,OACA,OACA,OACA,QACA,QACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cAEA,OACA,OACA,OACA,OACA,OACA,gBAEA,OACA,OACA,4hCmBkBOC"}