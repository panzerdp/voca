{"version":3,"file":"voca.min.js","sources":["../src/helper/object/is_nil.js","../src/helper/boolean/coerce_to_boolean.js","../src/query/is_string.js","../src/helper/string/coerce_to_string.js","../src/case/capitalize.js","../src/case/lower_case.js","../src/helper/undefined/nil_default.js","../src/helper/string/to_string.js","../src/split/words.js","../src/case/camel_case.js","../src/case/decapitalize.js","../src/case/kebab_case.js","../src/case/snake_case.js","../src/case/upper_case.js","../src/case/swap_case.js","../src/case/title_case.js","../src/helper/number/clip_number.js","../src/helper/number/to_integer.js","../src/chop/truncate.js","../src/chop/char_at.js","../src/helper/string/surrogate_pair.js","../src/helper/number/coerce_to_number.js","../src/helper/number/nan_default.js","../src/chop/code_point_at.js","../src/chop/first.js","../src/chop/grapheme_at.js","../src/chop/last.js","../src/chop/prune.js","../src/chop/slice.js","../src/chop/substr.js","../src/chop/substring.js","../src/count/count.js","../src/count/count_graphemes.js","../src/count/count_substrings.js","../src/count/count_where.js","../src/count/count_words.js","../src/helper/format/replacement/index.js","../src/manipulate/repeat.js","../src/helper/string/build_padding.js","../src/manipulate/pad_left.js","../src/manipulate/pad_right.js","../src/helper/format/align_and_pad.js","../src/helper/format/type_format/add_sign_to_formatted_number.js","../src/helper/format/type_format/float.js","../src/helper/format/type_format/integer_base.js","../src/helper/format/type_format/integer_decimal.js","../src/helper/format/type_format/string.js","../src/helper/format/replacement/compute.js","../src/helper/format/conversion_specification.js","../src/helper/format/replacement/validate.js","../src/helper/format/replacement/match.js","../src/format/sprintf.js","../src/format/vprintf.js","../src/escape/escape_html.js","../src/escape/escape_reg_exp.js","../src/escape/unescape_html.js","../src/index/index_of.js","../src/index/last_index_of.js","../src/index/search.js","../src/manipulate/insert.js","../src/helper/string/diacritics_map.js","../src/manipulate/latinise.js","../src/manipulate/pad.js","../src/manipulate/replace.js","../src/helper/reg_exp/get_reg_exp_flags.js","../src/query/includes.js","../src/helper/reg_exp/append_flag_to_reg_exp.js","../src/manipulate/replace_all.js","../src/manipulate/reverse.js","../src/manipulate/reverse_grapheme.js","../src/manipulate/slugify.js","../src/manipulate/splice.js","../src/manipulate/tr.js","../src/manipulate/trim_left.js","../src/manipulate/trim_right.js","../src/manipulate/trim.js","../src/manipulate/word_wrap.js","../src/query/ends_with.js","../src/query/is_alpha.js","../src/query/is_alpha_digit.js","../src/query/is_blank.js","../src/query/is_digit.js","../src/query/is_empty.js","../src/query/is_lower_case.js","../src/query/is_numeric.js","../src/query/is_upper_case.js","../src/query/matches.js","../src/query/starts_with.js","../src/split/chars.js","../src/split/code_points.js","../src/split/graphemes.js","../src/split/split.js","../src/strip/strip_bom.js","../src/helper/string/has_substring_at_index.js","../src/helper/strip/parse_tag_list.js","../src/helper/strip/parse_tag_name.js","../src/strip/strip_tags.js","../src/util/no_conflict.js","../src/chain/wrapper.js","../src/chain/chain.js","../src/index.js","../src/helper/reg_exp/const.js","../src/helper/reg_exp/const_extended.js","../src/helper/number/const.js","../src/helper/format/const.js","../src/helper/object/get_global.js","../src/util/version.js"],"sourcesContent":["/**\n * Checks if `value` is `null` or `undefined`\n *\n * @ignore\n * @function isNil\n * @param {*} value The object to check\n * @return {boolean} Returns `true` is `value` is `undefined` or `null`, `false` otherwise\n */\nexport default function isNil(value) {\n  return value === undefined || value === null;\n}","import isNil from 'helper/object/is_nil';\n\n/**\n * Converts the `value` to a boolean. If `value` is `undefined` or `null`, returns `defaultValue`.\n *\n * @ignore\n * @function toBoolean\n * @param {*} value The value to convert.\n * @param {boolean} [defaultValue=false] The default value.\n * @return {boolean} Returns the coercion to boolean.\n */\nexport default function coerceToBoolean(value, defaultValue = false) {\n  if (isNil(value)) {\n    return defaultValue;\n  }\n  return Boolean(value);\n}","/**\n * Checks whether `subject` is a string primitive type.\n *\n * @function isString\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} subject The value to verify.\n * @return {boolean} Returns `true` if `subject` is string primitive type or `false` otherwise.\n * @example\n * v.isString('vacation');\n * // => true\n *\n * v.isString(560);\n * // => false\n */\nexport default function isString(subject) {\n  return typeof subject === 'string';\n}","import isNil from 'helper/object/is_nil';\nimport isString from 'query/is_string';\n\n/**\n * Get the string representation of the `value`.\n * Converts the `value` to string.\n * If `value` is `null` or `undefined`, return `defaultValue`.\n *\n * @ignore\n * @function toString\n * @param {*} value             The value to convert.\n * @param {*} [defaultValue=''] The default value to return.\n * @return {string|null}        Returns the string representation of `value`. Returns `defaultValue` if `value` is\n *                              `null` or `undefined`.\n */\nexport default function coerceToString(value, defaultValue = '') {\n  if (isNil(value)) {\n    return defaultValue;\n  }\n  if (isString(value)) {\n    return value;\n  }\n  return String(value);\n}","import coerceToBoolean from 'helper/boolean/coerce_to_boolean';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the first character of `subject` to upper case. If `restToLower` is `true`, convert the rest of\n * `subject` to lower case.\n *\n * @function capitalize\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string}  [subject='']        The string to capitalize.\n * @param  {boolean} [restToLower=false] Convert the rest of `subject` to lower case.\n * @return {string}                      Returns the capitalized string.\n * @example\n * v.capitalize('apple');\n * // => 'Apple'\n *\n * v.capitalize('aPPle', true);\n * // => 'Apple'\n */\nexport default function capitalize(subject, restToLower) {\n  let subjectString = coerceToString(subject);\n  const restToLowerCaseBoolean = coerceToBoolean(restToLower);\n  if (subjectString === '') {\n    return '';\n  }\n  if (restToLowerCaseBoolean) {\n    subjectString = subjectString.toLowerCase();\n  }\n  return subjectString.substr(0, 1).toUpperCase() + subjectString.substr(1);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the `subject` to lower case.\n *\n * @function lowerCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to lower case.\n * @return {string}              Returns the lower case string.\n * @example\n * v.lowerCase('Green');\n * // => 'green'\n *\n * v.lowerCase('BLUE');\n * // => 'blue'\n */\nexport default function lowerCase(subject) {\n  const subjectString = coerceToString(subject, '');\n  return subjectString.toLowerCase();\n}\n","/**\n * Verifies if `value` is `undefined` or `null` and returns `defaultValue`. In other case returns `value`.\n *\n * @ignore\n * @function nilDefault\n * @param {*} value The value to verify.\n * @param {*} defaultValue The default value.\n * @return {*} Returns `defaultValue` if `value` is `undefined` or `null`, otherwise `defaultValue`.\n */\nexport default function nilDefault(value, defaultValue) {\n  return value == null ? defaultValue : value;\n}","import isNil from 'helper/object/is_nil';\nimport isString from 'query/is_string';\n\n/**\n * Get the string representation of the `value`.\n * Converts the `value` to string.\n *\n * @ignore\n * @function toString\n * @param {*} value             The value to convert.\n * @return {string|null}        Returns the string representation of `value`.\n */\nexport default function toString(value) {\n  if (isNil(value)) {\n    return null;\n  }\n  if (isString(value)) {\n    return value;\n  }\n  return String(value);\n}","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport nilDefault from 'helper/undefined/nil_default';\nimport toString from 'helper/string/to_string';\n\n/**\n * Splits `subject` into an array of words.\n *\n * @function words\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into words.\n * @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\n * @return {Array} Returns the array of words.\n * @example\n * v.words('gravity can cross dimensions');\n * // => ['gravity', 'can', 'cross', 'dimensions']\n *\n * v.words('GravityCanCrossDimensions');\n * // => ['Gravity', 'Can', 'Cross', 'Dimensions']\n *\n * v.words('Gravity - can cross dimensions!');\n * // => ['Gravity', 'can', 'cross', 'dimensions']\n *\n * v.words('Earth gravity', /[^\\s]+/g);\n * // => ['Earth', 'gravity']\n */\nexport default function words(subject, pattern, flags) {\n  const subjectString = coerceToString(subject);\n  let patternRegExp;\n  if (isNil(pattern)) {\n    patternRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\n  } else if (pattern instanceof RegExp) {\n    patternRegExp = pattern;\n  } else {\n    const flagsString = toString(nilDefault(flags, ''));\n    patternRegExp = new RegExp(toString(pattern), flagsString);\n  }\n  return nilDefault(subjectString.match(patternRegExp), []);\n}","import capitalize from 'case/capitalize';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport lowerCase from 'case/lower_case';\nimport words from 'split/words';\n\n/**\n * Transforms the `word` into camel case chunk.\n *\n * @param  {string} word  The word string\n * @param  {number} index The index of the word in phrase.\n * @return {string}       The transformed word.\n * @ignore\n */\nfunction wordToCamel(word, index) {\n  return index === 0 ? lowerCase(word) : capitalize(word, true);\n}\n\n/**\n * Converts the `subject` to <a href=\"https://en.wikipedia.org/wiki/CamelCase\">camel case</a>.\n *\n * @function camelCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to camel case.\n * @return {string}              The camel case string.\n * @example\n * v.camelCase('bird flight');\n * // => 'birdFlight'\n *\n * v.camelCase('BirdFlight');\n * // => 'birdFlight'\n *\n * v.camelCase('-BIRD-FLIGHT-');\n * // => 'birdFlight'\n */\nexport default function camelCase(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return words(subjectString).map(wordToCamel).join('');\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the first character of `subject` to lower case.\n *\n * @function decapitalize\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to decapitalize.\n * @return {string}              Returns the decapitalized string.\n * @example\n * v.decapitalize('Sun');\n * // => 'sun'\n *\n * v.decapitalize('moon');\n * // => 'moon'\n */\nexport default function decapitalize(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return subjectString.substr(0, 1).toLowerCase() + subjectString.substr(1);\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport lowerCase from 'case/lower_case';\nimport words from 'split/words';\n\n/**\n * Converts the `subject` to <a href=\"https://en.wikipedia.org/wiki/Letter_case#cite_ref-13\">kebab case</a>,\n * also called <i>spinal case</i> or <i>lisp case</i>.\n *\n * @function kebabCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to kebab case.\n * @return {string}              Returns the kebab case string.\n * @example\n * v.kebabCase('goodbye blue sky');\n * // => 'goodbye-blue-sky'\n *\n * v.kebabCase('GoodbyeBlueSky');\n * // => 'goodbye-blue-sky'\n *\n * v.kebabCase('-Goodbye-Blue-Sky-');\n * // => 'goodbye-blue-sky'\n */\nexport default function kebabCase(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return words(subjectString).map(lowerCase).join('-');\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport lowerCase from 'case/lower_case';\nimport words from 'split/words';\n\n/**\n * Converts the `subject` to <a href=\"https://en.wikipedia.org/wiki/Snake_case\">snake case</a>.\n *\n * @function snakeCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to snake case.\n * @return {string}              Returns the snake case string.\n * @example\n * v.snakeCase('learning to fly');\n * // => 'learning_to_fly'\n *\n * v.snakeCase('LearningToFly');\n * // => 'learning_to_fly'\n *\n * v.snakeCase('-Learning-To-Fly-');\n * // => 'learning_to_fly'\n */\nexport default function snakeCase(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return words(subjectString).map(lowerCase).join('_');\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the `subject` to upper case.\n *\n * @function upperCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to upper case.\n * @return {string}              Returns the upper case string.\n * @example\n * v.upperCase('school');\n * // => 'SCHOOL'\n */\nexport default function upperCase(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.toUpperCase();\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the uppercase alpha caracters of `subject` to lowercase and lowercase \n * characters to uppercase.\n *\n * @function swapCase\n * @static\n * @since 1.3.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to swap the case.\n * @return {string}              Returns the converted string.\n * @example\n * v.swapCase('League of Shadows');\n * // => 'lEAGUE OF sHADOWS'\n *\n * v.swapCase('2 Bees');\n * // => '2 bEES'\n */\nexport default function swapCase(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split('').reduce(swapAndConcat, '');\n}\n\nfunction swapAndConcat(swapped, character) {\n  const lowerCase = character.toLowerCase();\n  const upperCase = character.toUpperCase();\n  return swapped + (character === lowerCase ? upperCase : lowerCase);\n}","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\nimport capitalize from 'case/capitalize';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the subject to title case.\n *\n * @function titleCase\n * @static\n * @since 1.4.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to title case.\n * @param  {Array}  [noSplit]    Do not split words at the specified characters.\n * @return {string}              Returns the title case string.\n * @example\n * v.titleCase('learning to fly');\n * // => 'Learning To Fly'\n *\n * v.titleCase('jean-luc is good-looking', ['-']);\n * // => 'Jean-luc Is Good-looking'\n */\nexport default function titleCase(subject, noSplit) {\n  const subjectString = coerceToString(subject);\n  const noSplitArray = Array.isArray(noSplit) ? noSplit : [];\n  const wordsRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\n  return subjectString.replace(wordsRegExp, function(word, index) {\n    const isNoSplit = index > 0 && noSplitArray.indexOf(subjectString[index - 1]) >= 0;\n    return isNoSplit ? word.toLowerCase() : capitalize(word, true);\n  });\n}","/**\n * Clip the number to interval `downLimit` to `upLimit`.\n *\n * @ignore\n * @function clipNumber\n * @param {number} value The number to clip\n * @param {number} downLimit The down limit\n * @param {number} upLimit The upper limit\n * @return {number} The clipped number\n */\nexport default function clipNumber(value, downLimit, upLimit) {\n  if (value <= downLimit) {\n    return downLimit;\n  }\n  if (value >= upLimit) {\n    return upLimit;\n  }\n  return value;\n}","import { MAX_SAFE_INTEGER } from 'helper/number/const';\n\n/**\n * Transforms `value` to an integer.\n *\n * @ignore\n * @function toInteger\n * @param {number} value The number to transform.\n * @returns {number} Returns the transformed integer.\n */\nexport default function toInteger(value) {\n  if (value === Infinity) {\n    return MAX_SAFE_INTEGER;\n  }\n  if (value === -Infinity) {\n    return - MAX_SAFE_INTEGER;\n  }\n  return ~~value;\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Truncates `subject` to a new `length`.\n *\n * @function truncate\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to truncate.\n * @param  {int}    length       The length to truncate the string.\n * @param  {string} [end='...']  The string to be added at the end.\n * @return {string}              Returns the truncated string.\n * @example\n * v.truncate('Once upon a time', 7);\n * // => 'Once...'\n *\n * v.truncate('Good day, Little Red Riding Hood', 14, ' (...)');\n * // => 'Good day (...)'\n *\n * v.truncate('Once upon', 10);\n * // => 'Once upon'\n */\nexport default function truncate(subject, length, end) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const endString = coerceToString(end, '...');\n  if (lengthInt >= subjectString.length) {\n    return subjectString;\n  }\n  return subjectString.substr(0, length - endString.length) + endString;\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Access a character from `subject` at specified `position`.\n *\n * @function charAt\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {numbers} position The position to get the character.\n * @return {string} Returns the character at specified position.\n * @example\n * v.charAt('helicopter', 0);\n * // => 'h'\n *\n * v.charAt('helicopter', 1);\n * // => 'e'\n */\nexport default function charAt(subject, position) {\n  const subjectString = coerceToString(subject);\n  return subjectString.charAt(position);\n}","const HIGH_SURROGATE_START = 0xD800;\nconst HIGH_SURROGATE_END = 0xDBFF;\nconst LOW_SURROGATE_START = 0xDC00;\nconst LOW_SURROGATE_END = 0xDFFF;\n\n/**\n * Checks if `codePoint` is a high-surrogate number from range 0xD800 to 0xDBFF.\n *\n * @ignore\n * @param {number} codePoint The code point number to be verified\n * @return {boolean} Returns a boolean whether `codePoint` is a high-surrogate number.\n */\nexport function isHighSurrogate(codePoint) {\n  return codePoint >= HIGH_SURROGATE_START && codePoint <= HIGH_SURROGATE_END;\n}\n\n/**\n * Checks if `codePoint` is a low-surrogate number from range 0xDC00 to 0xDFFF.\n *\n * @ignore\n * @param {number} codePoint The code point number to be verified\n * @return {boolean} Returns a boolean whether `codePoint` is a low-surrogate number.\n */\nexport function isLowSurrogate(codePoint) {\n  return codePoint >= LOW_SURROGATE_START && codePoint <= LOW_SURROGATE_END;\n}\n\n/**\n * Get the astral code point number based on surrogate pair numbers.\n *\n * @ignore\n * @param {number} highSurrogate The high-surrogate code point number.\n * @param {number} lowSurrogate The low-surrogate code point number.\n * @return {number} Returns the astral symbol number.\n */\nexport function getAstralNumberFromSurrogatePair(highSurrogate, lowSurrogate) {\n  return (highSurrogate - HIGH_SURROGATE_START) * 0x400 + lowSurrogate - LOW_SURROGATE_START + 0x10000;\n}","import isNil from 'helper/object/is_nil';\n\n/**\n * Get the number representation of the `value`.\n * Converts the `value` to number.\n * If `value` is `null` or `undefined`, return `defaultValue`.\n *\n * @ignore\n * @function toString\n * @param {*} value             The value to convert.\n * @param {*} [defaultValue=''] The default value to return.\n * @return {number|null}        Returns the number representation of `value`. Returns `defaultValue` if `value` is\n *                              `null` or `undefined`.\n */\nexport default function coerceToNumber(value, defaultValue = 0) {\n  if (isNil(value)) {\n    return defaultValue;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return Number(value);\n}","/**\n * If `value` is `NaN`, return `defaultValue`. In other case returns `value`.\n *\n * @ignore\n * @function nanDefault\n * @param {*} value The value to verify.\n * @param {*} defaultValue The default value.\n * @return {*} Returns `defaultValue` if `value` is `NaN`, otherwise `defaultValue`.\n */\nexport default function nanDefault(value, defaultValue) {\n  return value !== value ? defaultValue : value;\n}","import { getAstralNumberFromSurrogatePair, isHighSurrogate, isLowSurrogate } from 'helper/string/surrogate_pair';\nimport coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport nanDefault from 'helper/number/nan_default';\n\n/**\n * Get the Unicode code point value of the character at `position`. <br/>\n * If a valid UTF-16 <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">\n * surrogate pair</a> starts at `position`, the\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#astralplanes\">astral code point</a>\n * value at `position` is returned.\n *\n * @function codePointAt\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {number} position The position to get the code point number.\n * @return {number} Returns a non-negative number less than or equal to `0x10FFFF`.\n * @example\n * v.codePointAt('rain', 1);\n * // => 97, or 0x0061\n *\n * v.codePointAt('\\uD83D\\uDE00 is smile', 0); // or '游 is smile'\n * // => 128512, or 0x1F600\n */\nexport default function codePointAt(subject, position) {\n  const subjectString = coerceToString(subject);\n  const subjectStringLength = subjectString.length;\n  let positionNumber = coerceToNumber(position);\n  positionNumber = nanDefault(positionNumber, 0);\n  if (positionNumber < 0 || positionNumber >= subjectStringLength) {\n    return undefined;\n  }\n  const firstCodePoint = subjectString.charCodeAt(positionNumber);\n  let secondCodePoint;\n  if (isHighSurrogate(firstCodePoint) && subjectStringLength > positionNumber + 1) {\n    secondCodePoint = subjectString.charCodeAt(positionNumber + 1);\n    if (isLowSurrogate(secondCodePoint)) {\n      return getAstralNumberFromSurrogatePair(firstCodePoint, secondCodePoint);\n    }\n  }\n  return firstCodePoint;\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Extracts the first `length` characters from `subject`.\n *\n * @function first\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {int}    [length=1]   The number of characters to extract.\n * @return {string}              Returns the first characters string.\n * @example\n * v.first('helicopter');\n * // => 'h'\n *\n * v.first('vehicle', 2);\n * // => 've'\n *\n * v.first('car', 5);\n * // => 'car'\n */\nexport default function first(subject, length) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  if (subjectString.length <= lengthInt) {\n    return subjectString;\n  }\n  return subjectString.substr(0, lengthInt);\n}","import coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport nanDefault from 'helper/number/nan_default';\nimport { REGEXP_UNICODE_CHARACTER } from 'helper/reg_exp/const';\n\n/**\n * Get a grapheme from `subject` at specified `position` taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function graphemeAt\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {number} position The position to get the grapheme.\n * @return {string} Returns the grapheme at specified position.\n * @example\n * v.graphemeAt('\\uD835\\uDC00\\uD835\\uDC01', 0); // or '洧洧내'\n * // => 'A'\n *\n * v.graphemeAt('cafe\\u0301', 3); // or 'cafe패'\n * // => 'e패'\n */\nexport default function graphemeAt(subject, position) {\n  const subjectString = coerceToString(subject);\n  let positionNumber = coerceToNumber(position);\n  let  graphemeMatch;\n  let graphemeMatchIndex = 0;\n  positionNumber = nanDefault(positionNumber, 0);\n  while ((graphemeMatch = REGEXP_UNICODE_CHARACTER.exec(subjectString)) !== null) {\n    if (graphemeMatchIndex === positionNumber) {\n      REGEXP_UNICODE_CHARACTER.lastIndex = 0;\n      return graphemeMatch[0];\n    }\n    graphemeMatchIndex++;\n  }\n  return '';\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Extracts the last `length` characters from `subject`.\n *\n * @function last\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {int}    [length=1]   The number of characters to extract.\n * @return {string}              Returns the last characters string.\n * @example\n * v.last('helicopter');\n * // => 'r'\n *\n * v.last('vehicle', 2);\n * // => 'le'\n *\n * v.last('car', 5);\n * // => 'car'\n */\nexport default function last(subject, length) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  if (subjectString.length <= lengthInt) {\n    return subjectString;\n  }\n  return subjectString.substr(subjectString.length - lengthInt, lengthInt);\n}","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Truncates `subject` to a new `length` and does not break the words. Guarantees that the truncated string is no longer\n * than `length`.\n *\n * @static\n * @function prune\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to prune.\n * @param  {int}    length       The length to prune the string.\n * @param  {string} [end='...']  The string to be added at the end.\n * @return {string}              Returns the pruned string.\n * @example\n * v.prune('Once upon a time', 7);\n * // => 'Once...'\n *\n * v.prune('Good day, Little Red Riding Hood', 16, ' (more)');\n * // => 'Good day (more)'\n *\n * v.prune('Once upon', 10);\n * // => 'Once upon'\n */\nexport default function prune(subject, length, end) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const endString = coerceToString(end, '...');\n  if (lengthInt >= subjectString.length) {\n    return subjectString;\n  }\n  const pattern = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\n  let truncatedLength = 0;\n  subjectString.replace(pattern, function(word, offset) {\n    const wordInsertLength = offset + word.length;\n    if (wordInsertLength <= lengthInt - endString.length) {\n      truncatedLength = wordInsertLength;\n    }\n  });\n  return subjectString.substr(0, truncatedLength) + endString;\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Extracts from `subject` a string from `start` position up to `end` position. The character at `end` position is not\n * included.\n *\n * @function slice\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject='']         The string to extract from.\n * @param  {number} start                The position to start extraction. If negative use `subject.length + start`.\n * @param  {number} [end=subject.length] The position to end extraction. If negative use `subject.length + end`.\n * @return {string}                      Returns the extracted string.\n * @note Uses native `String.prototype.slice()`\n * @example\n * v.slice('miami', 1);\n * // => 'iami'\n *\n * v.slice('florida', -4);\n * // => 'rida'\n *\n * v.slice('florida', 1, 4);\n * // => \"lor\"\n */\nexport default function slice(subject, start, end) {\n  return coerceToString(subject).slice(start, end);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Extracts from `subject` a string from `start` position a number of `length` characters.\n *\n * @function substr\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject='']                 The string to extract from.\n * @param  {number} start                        The position to start extraction.\n * @param  {number} [length=subject.endOfString] The number of characters to extract. If omitted, extract to the end of `subject`.\n * @return {string}                              Returns the extracted string.\n * @note Uses native `String.prototype.substr()`\n * @example\n * v.substr('infinite loop', 9);\n * // => 'loop'\n *\n * v.substr('dreams', 2, 2);\n * // => 'ea'\n */\nexport default function substr(subject, start, length) {\n  return coerceToString(subject).substr(start, length);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Extracts from `subject` a string from `start` position up to `end` position. The character at `end` position is not\n * included.\n *\n * @function substring\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject='']         The string to extract from.\n * @param  {number} start                The position to start extraction.\n * @param  {number} [end=subject.length] The position to end extraction.\n * @return {string}                      Returns the extracted string.\n * @note Uses native `String.prototype.substring()`\n * @example\n * v.substring('beach', 1);\n * // => 'each'\n *\n * v.substring('ocean', 1, 3);\n * // => 'ea'\n */\nexport default function substring(subject, start, end) {\n  return coerceToString(subject).substring(start, end);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Counts the characters in `subject`.<br/>\n *\n * @function count\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string} [subject=''] The string to count characters.\n * @return {number}              Returns the number of characters in `subject`.\n * @example\n * v.count('rain');\n * // => 4\n */\nexport default function count(subject) {\n  return coerceToString(subject).length;\n}","import { REGEXP_COMBINING_MARKS, REGEXP_SURROGATE_PAIRS } from 'helper/reg_exp/const';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Counts the graphemes in `subject` taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function  countGraphemes\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string} [subject=''] The string to count graphemes.\n * @return {number}              Returns the number of graphemes in `subject`.\n * @example\n * v.countGraphemes('cafe\\u0301'); // or 'cafe패'\n * // => 4\n *\n * v.countGraphemes('\\uD835\\uDC00\\uD835\\uDC01'); // or '洧洧내'\n * // => 2\n *\n * v.countGraphemes('rain');\n * // => 4\n */\nexport default function countGrapheme(subject) {\n  return coerceToString(subject)\n    .replace(REGEXP_COMBINING_MARKS, '*')\n    .replace(REGEXP_SURROGATE_PAIRS, '*')\n    .length;\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Counts the number of `substring` appearances in `subject`.\n *\n * @function countSubstrings\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string} [subject=''] The string where to count.\n * @param  {string} substring    The substring to be counted.\n * @return {number}              Returns the number of `substring` appearances.\n * @example\n * v.countSubstrings('bad boys, bad boys whatcha gonna do?', 'boys');\n * // => 2\n *\n * v.countSubstrings('every dog has its day', 'cat');\n * // => 0\n */\nexport default function countSubstrings(subject, substring) {\n  const subjectString = coerceToString(subject);\n  const substringString = coerceToString(substring);\n  const substringLength = substringString.length;\n  let count = 0;\n  let matchIndex = 0;\n  if (subjectString === '' || substringString === '') {\n    return count;\n  }\n  do {\n    matchIndex = subjectString.indexOf(substringString, matchIndex);\n    if (matchIndex !== -1) {\n      count++;\n      matchIndex += substringLength;\n    }\n  } while (matchIndex !== -1);\n  return count;\n}","import coerceToString from 'helper/string/coerce_to_string';\n\nconst reduce = Array.prototype.reduce;\n\n/**\n * Counts the characters in `subject` for which `predicate` returns truthy.\n *\n * @function  countWhere\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string}   [subject=''] The string to count characters.\n * @param  {Function} predicate    The predicate function invoked on each character with parameters `(character, index, string)`.\n * @param  {Object}   [context]    The context to invoke the `predicate`.\n * @return {number}                Returns the number of characters for which `predicate` returns truthy.\n * @example\n * v.countWhere('hola!', v.isAlpha);\n * // => 4\n *\n * v.countWhere('2022', function(character, index, str) {\n *   return character === '2';\n * });\n * // => 3\n */\nexport default function countWhere(subject, predicate, context) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '' || typeof predicate !== 'function') {\n    return 0;\n  }\n  const predicateWithContext = predicate.bind(context);\n  return reduce.call(subjectString, function(countTruthy, character, index) {\n    return predicateWithContext(character, index, subjectString) ? countTruthy + 1 : countTruthy;\n  }, 0);\n}","import words from 'split/words';\n\n/**\n * Counts the number of words in `subject`.\n *\n * @function countWords\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param {string} [subject=''] The string to split into words.\n * @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\n * @return {number} Returns the number of words.\n * @example\n * v.countWords('gravity can cross dimensions');\n * // => 4\n *\n * v.countWords('GravityCanCrossDimensions');\n * // => 4\n *\n * v.countWords('Gravity - can cross dimensions!');\n * // => 4\n *\n * v.words('Earth gravity', /[^\\s]+/g);\n * // => 2\n */\nexport default function countWords(subject, pattern, flags) {\n  return words(subject, pattern, flags).length;\n}","import isNil from 'helper/object/is_nil';\n\n/**\n * The current index.\n *\n * @ignore\n * @name ReplacementIndex#index\n * @type {number}\n * @return {ReplacementIndex} ReplacementIndex instance.\n */\nfunction ReplacementIndex() {\n  this.index = 0;\n}\n\n/**\n * Increment the current index.\n *\n * @ignore\n * @return {undefined}\n */\nReplacementIndex.prototype.increment = function() {\n  this.index++;\n};\n\n/**\n * Increment the current index by position.\n *\n * @ignore\n * @param {number} [position] The replacement position.\n * @return {undefined}\n */\nReplacementIndex.prototype.incrementOnEmptyPosition = function(position) {\n  if (isNil(position)) {\n    this.increment();\n  }\n};\n\n/**\n * Get the replacement index by position.\n *\n * @ignore\n * @param {number} [position] The replacement position.\n * @return {number} The replacement index.\n */\nReplacementIndex.prototype.getIndexByPosition = function(position) {\n  return isNil(position) ? this.index : position - 1;\n};\n\nexport default ReplacementIndex;","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Repeats the `subject` number of `times`.\n *\n * @function repeat\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to repeat.\n * @param {number} [times=1] The number of times to repeat.\n * @return {string} Returns the repeated string.\n * @example\n * v.repeat('w', 3);\n * // => 'www'\n *\n * v.repeat('world', 0);\n * // => ''\n */\nexport default function repeat(subject, times) {\n  let subjectString = coerceToString(subject);\n  let timesInt = isNil(times) ? 1 : clipNumber(toInteger(times), 0, MAX_SAFE_INTEGER);\n  let repeatString = '';\n  while (timesInt) {\n    if (timesInt & 1) {\n      repeatString += subjectString;\n    }\n    if (timesInt > 1) {\n      subjectString += subjectString;\n    }\n    timesInt >>= 1;\n  }\n  return repeatString;\n}","import repeat from 'manipulate/repeat';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Creates the padding string.\n *\n * @ignore\n * @param {string} padCharacters The characters to create padding string.\n * @param {number} length The padding string length.\n * @return {string} The padding string.\n */\nexport default function buildPadding(padCharacters, length) {\n  const padStringRepeat = toInteger(length / padCharacters.length);\n  const padStringRest = length % padCharacters.length;\n  return repeat(padCharacters, padStringRepeat + padStringRest).substr(0, length);\n}","import buildPadding from 'helper/string/build_padding';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Pads `subject` from left to a new `length`.\n *\n * @function padLeft\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to pad.\n * @param {int} [length=0] The length to left pad the string. No changes are made if `length` is less than `subject.length`.\n * @param {string} [pad=' '] The string to be used for padding.\n * @return {string} Returns the left padded string.\n * @example\n * v.padLeft('dog', 5);\n * // => '  dog'\n *\n * v.padLeft('bird', 6, '-');\n * // => '--bird'\n *\n * v.padLeft('cat', 6, '-=');\n * // => '-=-cat'\n */\nexport default function padLeft(subject, length, pad) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const padString = coerceToString(pad, ' ');\n  if (lengthInt <= subjectString.length) {\n    return subjectString;\n  }\n  return buildPadding(padString, lengthInt - subjectString.length) + subjectString;\n}","import buildPadding from 'helper/string/build_padding';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Pads `subject` from right to a new `length`.\n *\n * @function padRight\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to pad.\n * @param {int} [length=0] The length to right pad the string. No changes are made if `length` is less than `subject.length`.\n * @param {string} [pad=' '] The string to be used for padding.\n * @return {string} Returns the right padded string.\n * @example\n * v.padRight('dog', 5);\n * // => 'dog  '\n *\n * v.padRight('bird', 6, '-');\n * // => 'bird--'\n *\n * v.padRight('cat', 6, '-=');\n * // => 'cat-=-'\n */\nexport default function padRight(subject, length, pad) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const padString = coerceToString(pad, ' ');\n  if (lengthInt <= subjectString.length) {\n    return subjectString;\n  }\n  return subjectString + buildPadding(padString, lengthInt - subjectString.length);\n}","import isNil from 'helper/object/is_nil';\nimport { LITERAL_MINUS } from 'helper/format/const';\nimport padLeft from 'manipulate/pad_left';\nimport padRight from 'manipulate/pad_right';\n\n/**\n * Aligns and pads `subject` string.\n *\n * @ignore\n * @param {string} subject The subject string.\n * @param {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the aligned and padded string.\n */\nexport default function alignAndPad(subject, conversion) {\n  const width = conversion.width;\n  if (isNil(width) || subject.length >= width) {\n    return subject;\n  }\n  const padType = conversion.alignmentSpecifier === LITERAL_MINUS ? padRight : padLeft;\n  return padType(subject, width, conversion.getPaddingCharacter());\n}","import { LITERAL_PLUS } from 'helper/format/const';\n\n/**\n * Add sign to the formatted number.\n *\n * @ignore\n * @name addSignToFormattedNumber\n * @param  {number} replacementNumber The number to be replaced.\n * @param  {string} formattedReplacement The formatted version of number.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted number string with a sign.\n */\nexport default function addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion) {\n  if (conversion.signSpecifier === LITERAL_PLUS && replacementNumber >= 0) {\n    formattedReplacement = LITERAL_PLUS + formattedReplacement;\n  }\n  return formattedReplacement;\n}","import {\n  TYPE_FLOAT,\n  TYPE_FLOAT_SCIENTIFIC,\n  TYPE_FLOAT_SCIENTIFIC_UPPERCASE,\n  TYPE_FLOAT_SHORT,\n  TYPE_FLOAT_SHORT_UPPERCASE\n} from 'helper/format/const';\nimport addSignToFormattedNumber from 'helper/format/type_format/add_sign_to_formatted_number';\nimport coerceToNumber from 'helper/number/coerce_to_number';\nimport { REGEXP_TRAILING_ZEROS } from 'helper/reg_exp/const';\nimport toString from 'helper/string/coerce_to_string';\n\n/**\n * Formats a float type according to specifiers.\n *\n * @ignore\n * @param  {string} replacement The string to be formatted.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\n\nexport default function float(replacement, conversion) {\n  let replacementNumber = parseFloat(replacement);\n  let formattedReplacement;\n  if (isNaN(replacementNumber)) {\n    replacementNumber = 0;\n  }\n  const precision = coerceToNumber(conversion.precision, 6);\n  switch (conversion.typeSpecifier) {\n    case TYPE_FLOAT:\n      formattedReplacement = replacementNumber.toFixed(precision);\n      break;\n    case TYPE_FLOAT_SCIENTIFIC:\n      formattedReplacement = replacementNumber.toExponential(precision);\n      break;\n    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:\n      formattedReplacement = replacementNumber.toExponential(precision).toUpperCase();\n      break;\n    case TYPE_FLOAT_SHORT:\n    case TYPE_FLOAT_SHORT_UPPERCASE:\n      formattedReplacement = formatFloatAsShort(replacementNumber, precision, conversion);\n      break;\n  }\n  formattedReplacement = addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion);\n  return toString(formattedReplacement);\n}\n\n/**\n * Formats the short float.\n *\n * @ignore\n * @param  {number} replacementNumber The number to format.\n * @param  {number} precision The precision to format the float.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string}  Returns the formatted short float.\n */\nfunction formatFloatAsShort(replacementNumber, precision, conversion) {\n  if (replacementNumber === 0) {\n    return '0';\n  }\n  const nonZeroPrecision = precision === 0 ? 1 : precision;\n  let formattedReplacement = replacementNumber\n    .toPrecision(nonZeroPrecision)\n    .replace(REGEXP_TRAILING_ZEROS, '');\n  if (conversion.typeSpecifier === TYPE_FLOAT_SHORT_UPPERCASE) {\n    formattedReplacement = formattedReplacement.toUpperCase();\n  }\n  return formattedReplacement;\n}","import {\n  RADIX_BINARY,\n  RADIX_HEXADECIMAL,\n  RADIX_OCTAL,\n  TYPE_INTEGER_ASCII_CHARACTER,\n  TYPE_INTEGER_BINARY,\n  TYPE_INTEGER_HEXADECIMAL,\n  TYPE_INTEGER_HEXADECIMAL_UPPERCASE,\n  TYPE_INTEGER_OCTAL\n} from 'helper/format/const';\nimport toString from 'helper/string/coerce_to_string';\n\n/**\n * Formats an integer type according to specifiers.\n *\n * @ignore\n * @param  {string} replacement The string to be formatted.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\n\nexport default function integerBase(replacement, conversion) {\n  let integer = parseInt(replacement);\n  if (isNaN(integer)) {\n    integer = 0;\n  }\n  integer = integer >>> 0;\n  switch (conversion.typeSpecifier) {\n    case TYPE_INTEGER_ASCII_CHARACTER:\n      integer = String.fromCharCode(integer);\n      break;\n    case TYPE_INTEGER_BINARY:\n      integer = integer.toString(RADIX_BINARY);\n      break;\n    case TYPE_INTEGER_OCTAL:\n      integer = integer.toString(RADIX_OCTAL);\n      break;\n    case TYPE_INTEGER_HEXADECIMAL:\n      integer = integer.toString(RADIX_HEXADECIMAL);\n      break;\n    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:\n      integer = integer.toString(RADIX_HEXADECIMAL).toUpperCase();\n      break;\n  }\n  return toString(integer);\n}","import addSignToFormattedNumber from 'helper/format/type_format/add_sign_to_formatted_number';\nimport toString from 'helper/string/to_string';\n\n/**\n * Formats a decimal integer type according to specifiers.\n *\n * @ignore\n * @param  {string} replacement The string to be formatted.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\n\nexport default function integerDecimal(replacement, conversion) {\n  let integer = parseInt(replacement);\n  if (isNaN(integer)) {\n    integer = 0;\n  }\n  return addSignToFormattedNumber(integer, toString(integer), conversion);\n}","import isNil from 'helper/object/is_nil';\nimport truncate from 'chop/truncate';\n\n/**\n * Formats a string type according to specifiers.\n *\n * @ignore\n * @param {string} replacement The string to be formatted.\n * @param {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\nexport default function stringFormat(replacement, conversion) {\n  let formattedReplacement = replacement;\n  const precision = conversion.precision;\n  if (!isNil(precision) && formattedReplacement.length > precision) {\n    formattedReplacement = truncate(formattedReplacement, precision, '');\n  }\n  return formattedReplacement;\n}","import {\n  TYPE_FLOAT,\n  TYPE_FLOAT_SCIENTIFIC,\n  TYPE_FLOAT_SCIENTIFIC_UPPERCASE,\n  TYPE_FLOAT_SHORT,\n  TYPE_FLOAT_SHORT_UPPERCASE,\n  TYPE_INTEGER,\n  TYPE_INTEGER_ASCII_CHARACTER,\n  TYPE_INTEGER_BINARY,\n  TYPE_INTEGER_DECIMAL,\n  TYPE_INTEGER_HEXADECIMAL,\n  TYPE_INTEGER_HEXADECIMAL_UPPERCASE,\n  TYPE_INTEGER_OCTAL,\n  TYPE_INTEGER_UNSIGNED_DECIMAL,\n  TYPE_STRING\n} from 'helper/format/const';\nimport alignAndPad from 'helper/format/align_and_pad';\nimport formatFloat from 'helper/format/type_format/float';\nimport formatIntegerBase from 'helper/format/type_format/integer_base';\nimport formatIntegerDecimal from 'helper/format/type_format/integer_decimal';\nimport formatString from 'helper/format/type_format/string';\n\n/**\n * Returns the computed string based on format specifiers.\n *\n * @ignore\n * @name computeReplacement\n * @param {string} replacement The replacement value.\n * @param {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the computed string.\n */\nexport default function compute(replacement, conversion) {\n  let formatFunction;\n  switch (conversion.typeSpecifier) {\n    case TYPE_STRING:\n      formatFunction = formatString;\n      break;\n    case TYPE_INTEGER_DECIMAL:\n    case TYPE_INTEGER:\n      formatFunction = formatIntegerDecimal;\n      break;\n    case TYPE_INTEGER_ASCII_CHARACTER:\n    case TYPE_INTEGER_BINARY:\n    case TYPE_INTEGER_OCTAL:\n    case TYPE_INTEGER_HEXADECIMAL:\n    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:\n    case TYPE_INTEGER_UNSIGNED_DECIMAL:\n      formatFunction = formatIntegerBase;\n      break;\n    case TYPE_FLOAT:\n    case TYPE_FLOAT_SCIENTIFIC:\n    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:\n    case TYPE_FLOAT_SHORT:\n    case TYPE_FLOAT_SHORT_UPPERCASE:\n      formatFunction = formatFloat;\n      break;\n  }\n  const formattedString = formatFunction(replacement, conversion);\n  return alignAndPad(formattedString, conversion);\n}","import { LITERAL_PERCENT_SPECIFIER, LITERAL_SINGLE_QUOTE } from 'helper/format/const';\nimport nilDefault from 'helper/undefined/nil_default';\n\n/**\n * Construct the new conversion specification object.\n *\n * @ignore\n * @param {Object} properties An object with properties to initialize.\n * @return {ConversionSpecification} ConversionSpecification instance.\n */\nfunction ConversionSpecification(properties) {\n\n  /**\n   * The percent characters from conversion specification.\n   *\n   * @ignore\n   * @name ConversionSpecification#percent\n   * @type {string}\n   */\n  this.percent = properties.percent;\n\n  /**\n   *  The sign specifier to force a sign to be used on a number.\n   *\n   * @ignore\n   * @name ConversionSpecification#signSpecifier\n   * @type {string}\n   */\n  this.signSpecifier = properties.signSpecifier;\n\n  /**\n   * The padding specifier that says what padding character will be used.\n   *\n   * @ignore\n   * @name ConversionSpecification#paddingSpecifier\n   * @type {string}\n   */\n  this.paddingSpecifier = properties.paddingSpecifier;\n\n  /**\n   * The alignment specifier that says if the result should be left-justified or right-justified.\n   *\n   * @ignore\n   * @name ConversionSpecification#alignmentSpecifier\n   * @type {string}\n   */\n  this.alignmentSpecifier = properties.alignmentSpecifier;\n\n  /**\n   * The width specifier how many characters this conversion should result in.\n   *\n   * @ignore\n   * @name ConversionSpecification#width\n   * @type {number}\n   */\n  this.width = properties.width;\n\n  /**\n   * The precision specifier says how many decimal digits should be displayed for floating-point numbers.\n   *\n   * @ignore\n   * @name ConversionSpecification#precision\n   * @type {number}\n   */\n  this.precision = properties.precision;\n\n  /**\n   * The type specifier says what type the argument data should be treated as.\n   *\n   * @ignore\n   * @name ConversionSpecification#typeSpecifier\n   * @type {string}\n   */\n  this.typeSpecifier = properties.typeSpecifier;\n}\n\n\n/**\n * Check if the conversion specification is a percent literal \"%%\".\n *\n * @ignore\n * @return {boolean} Returns true if the conversion is a percent literal, false otherwise.\n */\nConversionSpecification.prototype.isPercentLiteral = function() {\n  return LITERAL_PERCENT_SPECIFIER === this.percent;\n};\n\n/**\n * Get the padding character from padding specifier.\n *\n * @ignore\n * @returns {string} Returns the padding character.\n */\nConversionSpecification.prototype.getPaddingCharacter = function() {\n  let paddingCharacter = nilDefault(this.paddingSpecifier, ' ');\n  if (paddingCharacter.length === 2 && paddingCharacter[0] === LITERAL_SINGLE_QUOTE) {\n    paddingCharacter = paddingCharacter[1];\n  }\n  return paddingCharacter;\n};\n\nexport default ConversionSpecification;","import isNil from 'helper/object/is_nil';\n\n/**\n * Validates the specifier type and replacement position.\n *\n * @ignore\n * @throws {Error} Throws an exception on insufficient arguments or unknown specifier.\n * @param  {number} index The index of the matched specifier.\n * @param  {number} replacementsLength The number of replacements.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {undefined}\n */\nexport default function validate(index, replacementsLength, conversion) {\n  if (isNil(conversion.typeSpecifier)) {\n    throw new Error('sprintf(): Unknown type specifier');\n  }\n  if (index > replacementsLength - 1) {\n    throw new Error('sprintf(): Too few arguments');\n  }\n  if (index < 0) {\n    throw new Error('sprintf(): Argument number must be greater than zero');\n  }\n}","import coerceToNumber from 'helper/number/coerce_to_number';\nimport computeReplacement from 'helper/format/replacement/compute';\nimport ConversionSpecification from 'helper/format/conversion_specification';\nimport validateReplacement from 'helper/format/replacement/validate';\n\n/**\n * Return the replacement for regular expression match of the conversion specification.\n *\n * @ignore\n * @name matchReplacement\n * @param {ReplacementIndex} replacementIndex The replacement index object.\n * @param {string[]} replacements The array of replacements.\n * @param {string} conversionSpecification The conversion specification.\n * @param {string} percent The percent characters from conversion specification.\n * @param {string} position The position to insert the replacement.\n * @param {string} signSpecifier The sign specifier to force a sign to be used on a number.\n * @param {string} paddingSpecifier The padding specifier that says what padding character will be used.\n * @param {string} alignmentSpecifier The alignment specifier that says if the result should be left-justified or right-justified.\n * @param {string} widthSpecifier The width specifier how many characters this conversion should result in.\n * @param {string} precisionSpecifier The precision specifier says how many decimal digits should be displayed for floating-point numbers.\n * @param {string} typeSpecifier The type specifier says what type the argument data should be treated as.\n * @return {string} Returns the computed replacement.\n */\nexport default function match(replacementIndex, replacements, conversionSpecification, percent, position, signSpecifier,\n  paddingSpecifier, alignmentSpecifier, widthSpecifier, precisionSpecifier, typeSpecifier) {\n  const conversion = new ConversionSpecification({\n    percent,\n    signSpecifier,\n    paddingSpecifier,\n    alignmentSpecifier,\n    width: coerceToNumber(widthSpecifier, null),\n    precision: coerceToNumber(precisionSpecifier, null),\n    typeSpecifier\n  });\n  if (conversion.isPercentLiteral()) {\n    return conversionSpecification.slice(1);\n  }\n  const actualReplacementIndex = replacementIndex.getIndexByPosition(position);\n  replacementIndex.incrementOnEmptyPosition(position);\n  validateReplacement(actualReplacementIndex, replacements.length, conversion);\n  return computeReplacement(replacements[actualReplacementIndex], conversion);\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_CONVERSION_SPECIFICATION } from 'helper/reg_exp/const';\nimport ReplacementIndex from 'helper/format/replacement/index.js';\nimport replacementMatch from 'helper/format/replacement/match';\n\n/**\n * Produces a string according to `format`.\n *\n * <div id=\"sprintf-format\" class=\"smaller\">\n * `format` string is composed of zero or more directives: ordinary characters (not <code>%</code>), which are  copied  unchanged\n * to  the  output string and <i>conversion specifications</i>, each of which results in fetching zero or more subsequent\n * arguments. <br/> <br/>\n *\n * Each <b>conversion specification</b> is introduced by the character <code>%</code>, and ends with a <b>conversion\n * specifier</b>. In between there may be (in this order) zero or more <b>flags</b>, an optional <b>minimum field width</b>\n * and an optional <b>precision</b>.<br/>\n * The syntax is: <b>ConversionSpecification</b> = <b>\"%\"</b> { <b>Flags</b> }\n * [ <b>MinimumFieldWidth</b> ] [ <b>Precision</b> ] <b>ConversionSpecifier</b>, where curly braces { } denote repetition\n * and square brackets [ ] optionality. <br/><br/>\n *\n * By default, the arguments are used in the given order.<br/>\n * For argument numbering and swapping, `%m$` (where `m` is a number indicating the argument order)\n * is used instead of `%` to specify explicitly which argument is taken. For instance `%1$s` fetches the 1st argument,\n * `%2$s` the 2nd and so on, no matter what position  the conversion specification has in `format`.\n * <br/><br/>\n *\n * <b>The flags</b><br/>\n * The character <code>%</code> is followed by zero or more of the following flags:<br/>\n * <table class=\"light-params\">\n *   <tr>\n *     <td><code>+</code></td>\n *     <td>\n *       A  sign (<code>+</code> or <code>-</code>) should always be placed before a number produced by a\n *       signed conversion. By default a sign is used only for negative numbers.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td><code>0</code></td>\n *     <td>The value should be zero padded.</td>\n *   </tr>\n *   <tr>\n *     <td><code>&blank;</code></td>\n *     <td>(a space) The value should be space padded.</td>\n *   </tr>\n *   <tr>\n *    <td><code>'</code></td>\n *    <td>Indicates alternate padding character, specified by prefixing it with a single quote <code>'</code>.</td>\n *   </tr>\n *   <tr>\n *     <td><code>-</code></td>\n *     <td>The converted value is to be left adjusted on the field boundary (the default is right justification).</td>\n *   </tr>\n * </table>\n *\n * <b>The minimum field width</b><br/>\n * An  optional decimal digit string (with nonzero first digit) specifying a minimum field width.  If the converted\n * value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the\n * left-adjustment flag has been given).<br/><br/>\n *\n * <b>The precision</b><br/>\n * An optional precision, in the form of a period `.` followed by an optional decimal digit string.<br/>\n * This gives the number of digits to appear after the radix character for `e`, `E`, `f` and `F` conversions, the\n * maximum number of significant digits for `g` and `G` conversions or the maximum number of characters to be printed\n * from a string for `s` conversion.<br/><br/>\n *\n * <b>The conversion specifier</b><br/>\n * A specifier that mentions what type the argument should be treated as:\n *\n * <table class=\"light-params\">\n *   <tr>\n *     <td>`s`</td>\n *     <td>The string argument is treated as and presented as a string.</td>\n *   </tr>\n *   <tr>\n *     <td>`d` `i`</td>\n *     <td>The integer argument is converted to signed decimal notation.</td>\n *   </tr>\n *   <tr>\n *     <td>`b`</td>\n *     <td>The unsigned integer argument is converted to unsigned binary.</td>\n *   </tr>\n *   <tr>\n *     <td>`c`</td>\n *     <td>The unsigned integer argument is converted to an ASCII character with that number.</td>\n *   </tr>\n *   <tr>\n *     <td>`o`</td>\n *     <td>The unsigned integer argument is converted to unsigned octal.</td>\n *   </tr>\n *   <tr>\n *     <td>`u`</td>\n *     <td>The unsigned integer argument is converted to unsigned decimal.</td>\n *   </tr>\n *   <tr>\n *     <td>`x` `X`</td>\n *     <td>The unsigned integer argument is converted to unsigned hexadecimal. The letters `abcdef` are used for `x`\n *     conversions; the letters `ABCDEF` are used for `X` conversions.</td>\n *   </tr>\n *   <tr>\n *     <td>`f`</td>\n *     <td>\n *      The float argument is rounded and converted to decimal notation in the style `[-]ddd.ddd`, where the number of\n *      digits after the decimal-point character is equal to the precision specification. If the precision is missing,\n *      it is taken as 6; if the precision is explicitly zero, no decimal-point character appears.\n *      If a decimal point appears, at least one digit appears before it.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td>`e` `E`</td>\n *     <td>\n *       The float argument is rounded and converted in the style `[-]d.ddde췀dd`, where there is one digit\n *       before the decimal-point character and the number of digits after it is equal to the precision. If\n *       the precision is missing, it is taken as `6`; if the precision is zero, no decimal-point character\n *       appears. An `E` conversion uses the letter `E` (rather than `e`) to introduce the exponent.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td>`g` `G`</td>\n *     <td>\n *       The float argument is converted in style `f` or `e` (or `F` or `E` for `G` conversions). The precision specifies\n *       the number of significant digits. If the precision is missing, `6` digits are given; if the\n *       precision is zero, it is treated as `1`. Style `e` is used if the exponent from its conversion is less\n *       than `-6` or greater than or equal to the precision. Trailing zeros are removed from the fractional\n *       part of the result; a decimal point appears only if it is followed by at least one digit.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td>`%`</td>\n *     <td>A literal `%` is written. No argument is converted. The complete conversion specification is `%%`.</td>\n *   </tr>\n *\n * </table>\n * </div>\n *\n * @function sprintf\n * @static\n * @since 1.0.0\n * @memberOf Format\n * @param  {string} [format=''] The format string.\n * @param  {...*}               replacements The replacements to produce the string.\n * @return {string}             Returns the produced string.\n * @example\n * v.sprintf('%s, %s!', 'Hello', 'World');\n * // => 'Hello World!'\n *\n * v.sprintf('%s costs $%d', 'coffee', 2);\n * // => 'coffee costs $2'\n *\n * v.sprintf('%1$s %2$s %1$s %2$s, watcha gonna %3$s', 'bad', 'boys', 'do')\n * // => 'bad boys bad boys, watcha gonna do'\n *\n * v.sprintf('% 6s', 'bird');\n * // => '  bird'\n *\n * v.sprintf('% -6s', 'crab');\n * // => 'crab  '\n *\n * v.sprintf(\"%'*5s\", 'cat');\n * // => '**cat'\n *\n * v.sprintf(\"%'*-6s\", 'duck');\n * // => 'duck**'\n *\n * v.sprintf('%d %i %+d', 15, -2, 25);\n * // => '15 -2 +25'\n *\n * v.sprintf(\"%06d\", 15);\n * // => '000015'\n *\n * v.sprintf('0b%b 0o%o 0x%X', 12, 9, 155);\n * // => '0b1100 0o11 0x9B'\n *\n * v.sprintf('%.2f', 10.469);\n * // => '10.47'\n *\n * v.sprintf('%.2e %g', 100.5, 0.455);\n * // => '1.01e+2 0.455'\n * \n */\nexport default function sprintf(format, ...replacements) {\n  const formatString = coerceToString(format);\n  if (formatString === '') {\n    return formatString;\n  }\n  const boundReplacementMatch = replacementMatch.bind(undefined, new ReplacementIndex(), replacements);\n  return formatString.replace(REGEXP_CONVERSION_SPECIFICATION, boundReplacementMatch);\n}","import nilDefault from 'helper/undefined/nil_default';\nimport sprintf from 'format/sprintf';\n\n/**\n * Produces a string according to `format`. Works exactly like <a href=\"#sprintf\"><code>sprintf()</code></a>,\n * with the only difference that accepts the formatting arguments in an array `values`.<br/>\n * See <a href=\"#sprintf-format\">here</a> `format` string specifications.\n *\n * @function vprintf\n * @static\n * @since 1.0.0\n * @memberOf Format\n * @param  {string} format='']  The format string.\n * @param  {Array} replacements The array of replacements to produce the string.\n * @return {string}             Returns the produced string.\n * @example\n * v.vprintf('%s', ['Welcome'])\n * // => 'Welcome'\n *\n * v.vprintf('%s has %d apples', ['Alexandra', 3]);\n * // => 'Alexandra has 3 apples'\n */\nexport default function vprintf(format, replacements) {\n  return sprintf(format, ...nilDefault(replacements, []));\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_HTML_SPECIAL_CHARACTERS } from 'helper/reg_exp/const';\n\nconst escapeCharactersMap = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;'\n};\n\n/**\n * Return the escaped version of `character`.\n *\n * @ignore\n * @param  {string} character The character to be escape.\n * @return {string}           The escaped version of character.\n */\nfunction replaceSpecialCharacter(character) {\n  return escapeCharactersMap[character];\n}\n\n/**\n * Escapes HTML special characters  <code>< > & ' \" `</code> in <code>subject</code>.\n *\n * @function escapeHtml\n * @static\n * @since 1.0.0         \n * @memberOf Escape\n * @param {string} [subject=''] The string to escape.\n * @return {string} Returns the escaped string.\n * @example\n * v.escapeHtml('<p>wonderful world</p>');\n * // => '&lt;p&gt;wonderful world&lt;/p&gt;'\n */\nexport default function escapeHtml(subject) {\n  return coerceToString(subject).replace(REGEXP_HTML_SPECIAL_CHARACTERS, replaceSpecialCharacter);\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_SPECIAL_CHARACTERS } from 'helper/reg_exp/const';\n\n/**\n * Escapes the regular expression special characters `- [ ] / { } ( ) * + ? . \\ ^ $ |` in `subject`.\n *\n * @function escapeRegExp\n * @static\n * @since 1.0.0\n * @memberOf Escape\n * @param {string} [subject=''] The string to escape.\n * @return {string} Returns the escaped string.\n * @example\n * v.escapeRegExp('(hours)[minutes]{seconds}');\n * // => '\\(hours\\)\\[minutes\\]\\{seconds\\}'\n */\nexport default function escapeRegExp(subject) {\n  return coerceToString(subject).replace(REGEXP_SPECIAL_CHARACTERS, '\\\\$&');\n}","import coerceToString from 'helper/string/coerce_to_string';\n\nconst unescapeCharactersMap = {\n  '<': /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi,\n  '>': /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi,\n  '&': /(&amp;)|(&#x0*26;)|(&#0*38;)/gi,\n  '\"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi,\n  \"'\": /(&#x0*27;)|(&#0*39;)/gi,\n  '`': /(&#x0*60;)|(&#0*96;)/gi\n};\nconst characters = Object.keys(unescapeCharactersMap);\n\n/**\n * Replaces the HTML entities with corresponding characters.\n *\n * @ignore\n * @param  {string} string The accumulator string.\n * @param  {string} key    The character.\n * @return {string}        The string with replaced HTML entity\n */\nfunction reduceUnescapedString(string, key) {\n  return string.replace(unescapeCharactersMap[key], key);\n}\n\n/**\n * Unescapes HTML special characters from <code>&amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;#x27; &amp;#x60;</code>\n * to corresponding <code>< > & ' \" `</code> in <code>subject</code>.\n *\n * @function unescapeHtml\n * @static\n * @since 1.0.0\n * @memberOf Escape\n * @param  {string} [subject=''] The string to unescape.\n * @return {string}              Returns the unescaped string.\n * @example\n * v.unescapeHtml('&lt;p&gt;wonderful world&lt;/p&gt;');\n * // => '<p>wonderful world</p>'\n */\nexport default function unescapeHtml(subject) {\n  const subjectString = coerceToString(subject);\n  return characters.reduce(reduceUnescapedString, subjectString);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Returns the first occurrence index of `search` in `subject`.\n *\n * @function indexOf\n * @static\n * @since 1.0.0\n * @memberOf Index\n * @param {string} [subject=''] The string where to search.\n * @param {string} search The string to search.\n * @param {number} [fromIndex=0] The index to start searching.\n * @return {number} Returns the first occurrence index or `-1` if not found.\n * @example\n * v.indexOf('morning', 'n');\n * // => 3\n *\n * v.indexOf('evening', 'o');\n * // => -1\n */\nexport default function indexOf(subject, search, fromIndex) {\n  const subjectString = coerceToString(subject);\n  return subjectString.indexOf(search, fromIndex);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Returns the last occurrence index of `search` in `subject`.\n *\n * @function lastIndexOf\n * @static\n * @since 1.0.0\n * @memberOf Index\n * @param {string} [subject=''] The string where to search.\n * @param {string} search The string to search.\n * @param {number} [fromIndex=subject.length - 1] The index to start searching backward in the string.\n * @return {number} Returns the last occurrence index or `-1` if not found.\n * @example\n * v.lastIndexOf('morning', 'n');\n * // => 5\n *\n * v.lastIndexOf('evening', 'o');\n * // => -1\n */\nexport default function lastIndexOf(subject, search, fromIndex) {\n  const subjectString = coerceToString(subject);\n  return subjectString.lastIndexOf(search, fromIndex);\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Returns the first index of a `pattern` match in `subject`.\n *\n * @function search\n * @static\n * @since 1.0.0\n * @memberOf Index\n * @param {string} [subject=''] The string where to search.\n * @param {string|RegExp} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern)`.\n * @param {number} [fromIndex=0] The index to start searching.\n * @return {number} Returns the first match index or `-1` if not found.\n * @example\n * v.search('morning', /rn/);\n * // => 2\n *\n * v.search('evening', '/\\d/');\n * // => -1\n */\nexport default function search(subject, pattern, fromIndex) {\n  const subjectString = coerceToString(subject);\n  const fromIndexNumber = isNil(fromIndex) ? 0 : clipNumber(toInteger(fromIndex), 0, subjectString.length);\n  let matchIndex  = subjectString.substr(fromIndexNumber).search(pattern);\n  if (matchIndex !== -1 && !isNaN(fromIndexNumber)) {\n    matchIndex += fromIndexNumber;\n  }\n  return matchIndex;\n}","import coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Inserts into `subject` a string `toInsert` at specified `position`.\n *\n * @function insert\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string where to insert.\n * @param {string} [toInsert=''] The string to be inserted.\n * @param {number} [position=0] The position to insert.\n * @return {string} Returns the string after insertion.\n * @example\n * v.insert('ct', 'a', 1);\n * // => 'cat'\n *\n * v.insert('sunny', ' day', 5);\n * // => 'sunny day'\n */\nexport default function insert(subject, toInsert, position) {\n  const subjectString = coerceToString(subject);\n  const toInsertString = coerceToString(toInsert);\n  const positionNumber = coerceToNumber(position);\n  if (positionNumber < 0 || positionNumber > subjectString.length || toInsertString === '') {\n    return subjectString;\n  }\n  return subjectString.slice(0, positionNumber) + toInsertString + subjectString.slice(positionNumber);\n}","/**\n * Generated diacritics map. See bellow the base code.\n * @ignore\n * @see http://stackoverflow.com/a/18391901/1894471\n * @type Object\n */\n\nconst diacritics = {\n  \"3\": \"\\u039e\\u03be\",\n  \"8\": \"\\u0398\\u03b8\",\n  \"A\": \"\\x41\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226\\u023a\\u1e00\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u24b6\\u2c6f\\uff21\\u0386\\u0391\\u0410\",\n  \"B\": \"\\x42\\u0181\\u0182\\u0243\\u1e02\\u1e04\\u1e06\\u24b7\\uff22\\u0392\\u0411\",\n  \"C\": \"\\x43\\xc7\\u0106\\u0108\\u010a\\u010c\\u0187\\u023b\\u1e08\\u24b8\\ua73e\\uff23\\u0426\",\n  \"D\": \"\\x44\\u010e\\u0110\\u0189\\u018a\\u018b\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u24b9\\ua779\\uff24\\xd0\\u0394\\u0414\",\n  \"E\": \"\\x45\\xc8\\xc9\\xca\\xcb\\u0112\\u0114\\u0116\\u0118\\u011a\\u018e\\u0190\\u0204\\u0206\\u0228\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1eb8\\u1eba\\u1ebc\\u1ebe\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u24ba\\uff25\\u0388\\u0395\\u0415\\u042d\",\n  \"F\": \"\\x46\\u0191\\u1e1e\\u24bb\\ua77b\\uff26\\u03a6\\u0424\",\n  \"G\": \"\\x47\\u011c\\u011e\\u0120\\u0122\\u0193\\u01e4\\u01e6\\u01f4\\u1e20\\u24bc\\ua77d\\ua77e\\ua7a0\\uff27\\u0393\\u0413\\u0490\",\n  \"H\": \"\\x48\\u0124\\u0126\\u021e\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u24bd\\u2c67\\u2c75\\ua78d\\uff28\\u0389\\u0397\\u0425\",\n  \"I\": \"\\x49\\xcc\\xcd\\xce\\xcf\\u0128\\u012a\\u012c\\u012e\\u0130\\u0197\\u01cf\\u0208\\u020a\\u1e2c\\u1e2e\\u1ec8\\u1eca\\u24be\\uff29\\u038a\\u0399\\u03aa\\u0406\\u0418\",\n  \"J\": \"\\x4a\\u0134\\u0248\\u24bf\\uff2a\\u0419\",\n  \"K\": \"\\x4b\\u0136\\u0198\\u01e8\\u1e30\\u1e32\\u1e34\\u24c0\\u2c69\\ua740\\ua742\\ua744\\ua7a2\\uff2b\\u039a\\u041a\",\n  \"L\": \"\\x4c\\u0139\\u013b\\u013d\\u013f\\u0141\\u023d\\u1e36\\u1e38\\u1e3a\\u1e3c\\u24c1\\u2c60\\u2c62\\ua746\\ua748\\ua780\\uff2c\\u039b\\u041b\",\n  \"M\": \"\\x4d\\u019c\\u1e3e\\u1e40\\u1e42\\u24c2\\u2c6e\\uff2d\\u039c\\u041c\",\n  \"N\": \"\\x4e\\xd1\\u0143\\u0145\\u0147\\u019d\\u01f8\\u0220\\u1e44\\u1e46\\u1e48\\u1e4a\\u24c3\\ua790\\ua7a4\\uff2e\\u039d\\u041d\",\n  \"O\": \"\\x4f\\xd2\\xd3\\xd4\\xd5\\xd6\\xd8\\u014c\\u014e\\u0150\\u0186\\u019f\\u01a0\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\\u022e\\u0230\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u24c4\\ua74a\\ua74c\\uff2f\\u038c\\u039f\\u041e\",\n  \"P\": \"\\x50\\u01a4\\u1e54\\u1e56\\u24c5\\u2c63\\ua750\\ua752\\ua754\\uff30\\u03a0\\u041f\",\n  \"Q\": \"\\x51\\u024a\\u24c6\\ua756\\ua758\\uff31\",\n  \"R\": \"\\x52\\u0154\\u0156\\u0158\\u0210\\u0212\\u024c\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u24c7\\u2c64\\ua75a\\ua782\\ua7a6\\uff32\\u03a1\\u0420\",\n  \"S\": \"\\x53\\u015a\\u015c\\u015e\\u0160\\u0218\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e9e\\u24c8\\u2c7e\\ua784\\ua7a8\\uff33\\u03a3\\u0421\",\n  \"T\": \"\\x54\\u0162\\u0164\\u0166\\u01ac\\u01ae\\u021a\\u023e\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u24c9\\ua786\\uff34\\u03a4\\u0422\",\n  \"U\": \"\\x55\\xd9\\xda\\xdb\\xdc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01af\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216\\u0244\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u24ca\\uff35\\u0423\\u042a\",\n  \"V\": \"\\x56\\u01b2\\u0245\\u1e7c\\u1e7e\\u24cb\\ua75e\\uff36\\u0412\",\n  \"W\": \"\\x57\\u0174\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u24cc\\u2c72\\uff37\\u038f\\u03a9\",\n  \"X\": \"\\x58\\u1e8a\\u1e8c\\u24cd\\uff38\\u03a7\",\n  \"Y\": \"\\x59\\xdd\\u0176\\u0178\\u01b3\\u0232\\u024e\\u1e8e\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1efe\\u24ce\\uff39\\u038e\\u03a5\\u03ab\\u042b\",\n  \"Z\": \"\\x5a\\u0179\\u017b\\u017d\\u01b5\\u0224\\u1e90\\u1e92\\u1e94\\u24cf\\u2c6b\\u2c7f\\ua762\\uff3a\\u0396\\u0417\",\n  \"a\": \"\\x61\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227\\u0250\\u1e01\\u1e9a\\u1ea1\\u1ea3\\u1ea5\\u1ea7\\u1ea9\\u1eab\\u1ead\\u1eaf\\u1eb1\\u1eb3\\u1eb5\\u1eb7\\u24d0\\u2c65\\uff41\\u03ac\\u03b1\\u0430\",\n  \"b\": \"\\x62\\u0180\\u0183\\u0253\\u1e03\\u1e05\\u1e07\\u24d1\\uff42\\u03b2\\u0431\",\n  \"c\": \"\\x63\\xe7\\u0107\\u0109\\u010b\\u010d\\u0188\\u023c\\u1e09\\u2184\\u24d2\\ua73f\\uff43\\u0446\",\n  \"d\": \"\\x64\\u010f\\u0111\\u018c\\u0256\\u0257\\u1e0b\\u1e0d\\u1e0f\\u1e11\\u1e13\\u24d3\\ua77a\\uff44\\xf0\\u03b4\\u0434\",\n  \"e\": \"\\x65\\xe8\\xe9\\xea\\xeb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229\\u0247\\u025b\\u1e15\\u1e17\\u1e19\\u1e1b\\u1e1d\\u1eb9\\u1ebb\\u1ebd\\u1ebf\\u1ec1\\u1ec3\\u1ec5\\u1ec7\\u24d4\\uff45\\u03ad\\u03b5\\u0435\\u044d\",\n  \"f\": \"\\x66\\u0192\\u1e1f\\u24d5\\ua77c\\uff46\\u03c6\\u0444\",\n  \"g\": \"\\x67\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5\\u0260\\u1d79\\u1e21\\u24d6\\ua77f\\ua7a1\\uff47\\u03b3\\u0433\\u0491\",\n  \"h\": \"\\x68\\u0125\\u0127\\u021f\\u0265\\u1e23\\u1e25\\u1e27\\u1e29\\u1e2b\\u1e96\\u24d7\\u2c68\\u2c76\\uff48\\u03ae\\u03b7\\u0445\",\n  \"i\": \"\\x69\\xec\\xed\\xee\\xef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b\\u0268\\u1e2d\\u1e2f\\u1ec9\\u1ecb\\u24d8\\uff49\\u0390\\u03af\\u03b9\\u03ca\\u0438\\u0456\",\n  \"j\": \"\\x6a\\u0135\\u01f0\\u0249\\u24d9\\uff4a\\u0439\",\n  \"k\": \"\\x6b\\u0137\\u0199\\u01e9\\u1e31\\u1e33\\u1e35\\u24da\\u2c6a\\ua741\\ua743\\ua745\\ua7a3\\uff4b\\u03ba\\u043a\",\n  \"l\": \"\\x6c\\u013a\\u013c\\u013e\\u0140\\u0142\\u017f\\u019a\\u026b\\u1e37\\u1e39\\u1e3b\\u1e3d\\u24db\\u2c61\\ua747\\ua749\\ua781\\uff4c\\u03bb\\u043b\",\n  \"m\": \"\\x6d\\u026f\\u0271\\u1e3f\\u1e41\\u1e43\\u24dc\\uff4d\\u03bc\\u043c\",\n  \"n\": \"\\x6e\\xf1\\u0144\\u0146\\u0148\\u0149\\u019e\\u01f9\\u0272\\u1e45\\u1e47\\u1e49\\u1e4b\\u24dd\\ua791\\ua7a5\\uff4e\\u03bd\\u043d\",\n  \"o\": \"\\x6f\\xf2\\xf3\\xf4\\xf5\\xf6\\xf8\\u014d\\u014f\\u0151\\u01a1\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\\u022f\\u0231\\u0254\\u0275\\u1e4d\\u1e4f\\u1e51\\u1e53\\u1ecd\\u1ecf\\u1ed1\\u1ed3\\u1ed5\\u1ed7\\u1ed9\\u1edb\\u1edd\\u1edf\\u1ee1\\u1ee3\\u24de\\ua74b\\ua74d\\uff4f\\u03bf\\u03cc\\u043e\",\n  \"p\": \"\\x70\\u01a5\\u1d7d\\u1e55\\u1e57\\u24df\\ua751\\ua753\\ua755\\uff50\\u03c0\\u043f\",\n  \"q\": \"\\x71\\u024b\\u24e0\\ua757\\ua759\\uff51\",\n  \"r\": \"\\x72\\u0155\\u0157\\u0159\\u0211\\u0213\\u024d\\u027d\\u1e59\\u1e5b\\u1e5d\\u1e5f\\u24e1\\ua75b\\ua783\\ua7a7\\uff52\\u03c1\\u0440\",\n  \"s\": \"\\x73\\xdf\\u015b\\u015d\\u015f\\u0161\\u0219\\u023f\\u1e61\\u1e63\\u1e65\\u1e67\\u1e69\\u1e9b\\u24e2\\ua785\\ua7a9\\uff53\\u03c2\\u03c3\\u0441\",\n  \"t\": \"\\x74\\u0163\\u0165\\u0167\\u01ad\\u021b\\u0288\\u1e6b\\u1e6d\\u1e6f\\u1e71\\u1e97\\u24e3\\u2c66\\ua787\\uff54\\u03c4\\u0442\",\n  \"u\": \"\\x75\\xf9\\xfa\\xfb\\xfc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01b0\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217\\u0289\\u1e73\\u1e75\\u1e77\\u1e79\\u1e7b\\u1ee5\\u1ee7\\u1ee9\\u1eeb\\u1eed\\u1eef\\u1ef1\\u24e4\\uff55\\u0443\\u044a\",\n  \"v\": \"\\x76\\u028b\\u028c\\u1e7d\\u1e7f\\u24e5\\ua75f\\uff56\\u0432\",\n  \"w\": \"\\x77\\u0175\\u1e81\\u1e83\\u1e85\\u1e87\\u1e89\\u1e98\\u24e6\\u2c73\\uff57\\u03c9\\u03ce\",\n  \"x\": \"\\x78\\u1e8b\\u1e8d\\u24e7\\uff58\\u03c7\",\n  \"y\": \"\\x79\\xfd\\xff\\u0177\\u01b4\\u0233\\u024f\\u1e8f\\u1e99\\u1ef3\\u1ef5\\u1ef7\\u1ef9\\u1eff\\u24e8\\uff59\\u03b0\\u03c5\\u03cb\\u03cd\\u044b\",\n  \"z\": \"\\x7a\\u017a\\u017c\\u017e\\u01b6\\u0225\\u0240\\u1e91\\u1e93\\u1e95\\u24e9\\u2c6c\\ua763\\uff5a\\u03b6\\u0437\",\n  \"OE\": \"\\x8c\\u0152\",\n  \"oe\": \"\\x9c\\u0153\",\n  \"AE\": \"\\xc6\\u01e2\\u01fc\",\n  \"ae\": \"\\xe6\\u01e3\\u01fd\",\n  \"hv\": \"\\u0195\",\n  \"OI\": \"\\u01a2\",\n  \"oi\": \"\\u01a3\",\n  \"DZ\": \"\\u01c4\\u01f1\",\n  \"Dz\": \"\\u01c5\\u01f2\",\n  \"dz\": \"\\u01c6\\u01f3\",\n  \"LJ\": \"\\u01c7\",\n  \"Lj\": \"\\u01c8\",\n  \"lj\": \"\\u01c9\",\n  \"NJ\": \"\\u01ca\",\n  \"Nj\": \"\\u01cb\",\n  \"nj\": \"\\u01cc\",\n  \"OU\": \"\\u0222\",\n  \"ou\": \"\\u0223\",\n  \"TZ\": \"\\ua728\",\n  \"tz\": \"\\ua729\",\n  \"AA\": \"\\ua732\",\n  \"aa\": \"\\ua733\",\n  \"AO\": \"\\ua734\",\n  \"ao\": \"\\ua735\",\n  \"AU\": \"\\ua736\",\n  \"au\": \"\\ua737\",\n  \"AV\": \"\\ua738\\ua73a\",\n  \"av\": \"\\ua739\\ua73b\",\n  \"AY\": \"\\ua73c\",\n  \"ay\": \"\\ua73d\",\n  \"OO\": \"\\ua74e\",\n  \"oo\": \"\\ua74f\",\n  \"VY\": \"\\ua760\",\n  \"vy\": \"\\ua761\",\n  \"TH\": \"\\xde\",\n  \"th\": \"\\xfe\",\n  \"PS\": \"\\u03a8\",\n  \"ps\": \"\\u03c8\",\n  \"Yo\": \"\\u0401\",\n  \"Ye\": \"\\u0404\",\n  \"Yi\": \"\\u0407\",\n  \"Zh\": \"\\u0416\",\n  \"Ch\": \"\\u0427\",\n  \"Sh\": \"\\u0428\\u0429\",\n  \"\": \"\\u042c\\u044c\",\n  \"Yu\": \"\\u042e\",\n  \"Ya\": \"\\u042f\",\n  \"zh\": \"\\u0436\",\n  \"ch\": \"\\u0447\",\n  \"sh\": \"\\u0448\\u0449\",\n  \"yu\": \"\\u044e\",\n  \"ya\": \"\\u044f\",\n  \"yo\": \"\\u0451\",\n  \"ye\": \"\\u0454\",\n  \"yi\": \"\\u0457\"\n};\n\nlet diacriticsMap = null;\n\n/**\n * Creates a map of the diacritics.\n *\n * @ignore\n * @returns {Object} Returns the diacritics map.\n */\nfunction getDiacriticsMap() {\n  if (diacriticsMap !== null) {\n    return diacriticsMap;\n  }\n  diacriticsMap = {};\n  Object.keys(diacritics).forEach(function(key) {\n    const characters = diacritics[key];\n    for (let index = 0; index < characters.length; index++) {\n      const character = characters[index];\n      diacriticsMap[character] = key;\n    }\n  });\n  return diacriticsMap;\n}\n\n/**\n * Get the latin character from character with diacritics.\n *\n * @ignore\n * @param   {string} character The character with diacritics.\n * @returns {string}           Returns the character without diacritics.\n */\nexport function getLatinCharacter(character) {\n  const characterWithoutDiacritic = getDiacriticsMap()[character];\n  return characterWithoutDiacritic ? characterWithoutDiacritic : character;\n}","import { REGEXP_COMBINING_MARKS, REGEXP_NON_LATIN } from 'helper/reg_exp/const';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport { getLatinCharacter } from 'helper/string/diacritics_map';\n\n/**\n * Returns the `cleanCharacter` from combining marks regular expression match.\n *\n * @ignore\n * @param {string} character The character with combining marks\n * @param {string} cleanCharacter The character without combining marks.\n * @return {string} The character without combining marks.\n */\nfunction removeCombiningMarks(character, cleanCharacter) {\n  return cleanCharacter;\n}\n\n/**\n * Latinises the `subject` by removing diacritic characters.\n *\n * @function latinise\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to latinise.\n * @return {string} Returns the latinised string.\n * @example\n * v.latinise('cafe\\u0301'); // or 'cafe패'\n * // => 'cafe'\n *\n * v.latinise('ao칱t d칠cembre');\n * // => 'aout decembre'\n *\n * v.latinise('햨햟햨 햣햨햟혜햣햫 혨혝쮐 햪햦');\n * // => 'kak prekrasen etot mir'\n */\nexport default function latinise(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return subjectString\n    .replace(REGEXP_NON_LATIN, getLatinCharacter)\n    .replace(REGEXP_COMBINING_MARKS, removeCombiningMarks);\n}","import buildPadding from 'helper/string/build_padding';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Pads `subject` to a new `length`.\n *\n * @function pad\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to pad.\n * @param {int} [length=0] The length to pad the string. No changes are made if `length` is less than `subject.length`.\n * @param {string} [pad=' '] The string to be used for padding.\n * @return {string} Returns the padded string.\n * @example\n * v.pad('dog', 5);\n * // => ' dog '\n *\n * v.pad('bird', 6, '-');\n * // => '-bird-'\n *\n * v.pad('cat', 6, '-=');\n * // => '-cat-='\n */\nexport default function pad(subject, length, pad) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const padString = coerceToString(pad, ' ');\n  if (lengthInt <= subjectString.length) {\n    return subjectString;\n  }\n  const paddingLength = lengthInt - subjectString.length;\n  const paddingSideLength = toInteger(paddingLength / 2);\n  const paddingSideRemainingLength = paddingLength % 2;\n  return buildPadding(padString, paddingSideLength) + subjectString +\n      buildPadding(padString, paddingSideLength + paddingSideRemainingLength);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Replaces the matches of `pattern` with `replacement`. <br/>\n *\n * @function replace\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to verify.\n * @param {string|RegExp} pattern The pattern which match is replaced. If `pattern` is a string,\n * a simple string match is evaluated and only the first occurrence replaced.\n * @param {string|Function} replacement The string or function which invocation result replaces `pattern` match.\n * @return {string} Returns the replacement result.\n * @example\n * v.replace('swan', 'wa', 'u');\n * // => 'sun'\n *\n * v.replace('domestic duck', /domestic\\s/, '');\n * // => 'duck'\n *\n * v.replace('nice duck', /(nice)(duck)/, function(match, nice, duck) {\n *   return 'the ' + duck + ' is ' + nice;\n * });\n * // => 'the duck is nice'\n */\nexport default function replace(subject, pattern, replacement) {\n  const subjectString = coerceToString(subject);\n  return subjectString.replace(pattern, replacement);\n}","import { REGEXP_FLAGS } from 'helper/reg_exp/const';\n\n/**\n * Get the flags string from a regular expression object.\n *\n * @ignore\n * @param {RegExp} regExp The regular expression object.\n * @return {string} Returns the string with flags chars.\n */\nexport default function getRegExpFlags(regExp) {\n  return regExp.toString().match(REGEXP_FLAGS)[0];\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\nimport toString from 'helper/string/to_string';\n\n/**\n * Checks whether `subject` includes `search` starting from `position`.\n *\n * @function includes\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string where to search.\n * @param {string} search The string to search.\n * @param {number} [position=0] The position to start searching.\n * @return {boolean} Returns `true` if `subject` includes `search` or `false` otherwise.\n * @example\n * v.includes('starship', 'star');\n * // => true\n *\n * v.includes('galaxy', 'g', 1);\n * // => false\n */\nexport default function includes(subject, search, position) {\n  const subjectString = coerceToString(subject);\n  const searchString = toString(search);\n  if (searchString === null) {\n    return false;\n  }\n  if (searchString === '') {\n    return true;\n  }\n  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);\n  return subjectString.indexOf(searchString, position) !== -1;\n}","import getRegExpFlags from 'helper/reg_exp/get_reg_exp_flags';\nimport includes from 'query/includes';\n\n/**\n * Append flag to a regular expression.\n *\n * @ignore\n * @param {RegExp} pattern The pattern to coerce.\n * @param {string} appendFlag The flag to append to regular expression.\n * @return {RegExp} The regular expression with added flag.\n */\nexport default function appendFlagToRegExp(pattern, appendFlag) {\n  const regularExpressionFlags = getRegExpFlags(pattern);\n  if (!includes(regularExpressionFlags, appendFlag)) {\n    return new RegExp(pattern.source, regularExpressionFlags + appendFlag);\n  }\n  return pattern;\n}","import appendFlagToRegularExpression from 'helper/reg_exp/append_flag_to_reg_exp';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport escapeRegExp from 'escape/escape_reg_exp';\n\n/**\n * Replaces all matches of `pattern` with `replacement`. <br/>\n *\n * @function replaceAll\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to verify.\n * @param {string|RegExp} pattern The pattern which match is replaced. If `pattern` is a string, a simple string match is evaluated.\n * All matches are replaced.\n * @param {string|Function} replacement The string or function which invocation result replaces `pattern` match.\n * @return {string} Returns the replacement result.\n * @example\n * v.replaceAll('good morning', 'o', '*');\n * // => 'g**d m*rning'\n * v.replaceAll('evening', /n/, 's');\n * // => 'evesisg'\n *\n */\nexport default function replaceAll(subject, pattern, replacement) {\n  const subjectString = coerceToString(subject);\n  let regExp = pattern;\n  if (!(pattern instanceof RegExp)) {\n    regExp = new RegExp(escapeRegExp(pattern), 'g');\n  } else if (!pattern.global) {\n    regExp = appendFlagToRegularExpression(pattern, 'g');\n  }\n  return subjectString.replace(regExp, replacement);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Reverses the `subject`.\n *\n * @function reverse\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to reverse.\n * @return {string} Returns the reversed string.\n * @example\n * v.reverse('winter');\n * // => 'retniw'\n */\nexport default function reverse(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split('').reverse().join('');\n}","import { REGEXP_COMBINING_MARKS, REGEXP_SURROGATE_PAIRS } from 'helper/reg_exp/const';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Reverses the `subject` taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function reverseGrapheme\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to reverse.\n * @return {string} Returns the reversed string.\n * @example\n * v.reverseGrapheme('summer');\n * // => 'remmus'\n *\n * v.reverseGrapheme('洧깭 bar ma침ana man팪ana');\n * // => 'anan팪am ana침am rab 洧깭'\n */\nexport default function reverseGrapheme(subject) {\n  let subjectString = coerceToString(subject);\n  /**\n   * @see https://github.com/mathiasbynens/esrever\n   */\n  subjectString = subjectString\n    .replace(REGEXP_COMBINING_MARKS, function($0, $1, $2) {\n      return reverseGrapheme($2) + $1;\n    })\n    .replace(REGEXP_SURROGATE_PAIRS, '$2$1');\n  let reversedString = '';\n  let index = subjectString.length;\n  while (index--) {\n    reversedString += subjectString.charAt(index);\n  }\n  return reversedString;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport kebabCase from 'case/kebab_case';\nimport latinise from 'manipulate/latinise';\nimport { REGEXP_NON_LATIN } from 'helper/reg_exp/const';\n\n/**\n * Slugifies the `subject`. Cleans the `subject` by replacing diacritics with corresponding latin characters.\n *\n * @function slugify\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to slugify.\n * @return {string} Returns the slugified string.\n * @example\n * v.slugify('Italian cappuccino drink');\n * // => 'italian-cappuccino-drink'\n *\n * v.slugify('caff칠 latt칠');\n * // => 'caffe-latte'\n *\n * v.slugify('혠쮐쮐걣썜 쮏쮏얧');\n * // => 'horoshaya-pogoda'\n */\nexport default function slugify(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  const cleanSubjectString = latinise(subjectString).replace(REGEXP_NON_LATIN, '-');\n  return kebabCase(cleanSubjectString);\n}","import coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Changes `subject` by deleting `deleteCount` of characters starting at position `start`. Places a new string\n * `toAdd` instead of deleted characters.\n *\n * @function splice\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string where to insert.\n * @param {string} start The position to start changing the string. For a negative position will start from the end of\n * the string.\n * @param {number} [deleteCount=subject.length-start] The number of characters to delete from string.\n * @param {string} [toAdd=''] The string to be added instead of deleted characters.\n * @return {string} Returns the modified string.\n * @example\n * v.splice('new year', 0, 4);\n * // => 'year'\n *\n * v.splice('new year', 0, 3, 'happy');\n * // => 'happy year'\n *\n * v.splice('new year', -4, 4, 'day');\n * // => 'new day'\n */\nexport default function splice(subject, start, deleteCount, toAdd) {\n  const subjectString = coerceToString(subject);\n  const toAddString = coerceToString(toAdd);\n  let startPosition = coerceToNumber(start);\n  if (startPosition < 0) {\n    startPosition = subjectString.length + startPosition;\n    if (startPosition < 0) {\n      startPosition = 0;\n    }\n  } else if (startPosition > subjectString.length) {\n    startPosition = subjectString.length;\n  }\n  let deleteCountNumber = coerceToNumber(deleteCount, subjectString.length - startPosition);\n  if (deleteCountNumber < 0) {\n    deleteCountNumber = 0;\n  }\n  return subjectString.slice(0, startPosition) + toAddString + subjectString.slice(startPosition + deleteCountNumber);\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport isString from 'query/is_string';\nimport nilDefault from 'helper/undefined/nil_default';\n\n/**\n * Translates characters or replaces substrings in `subject`.\n *\n * @function tr\n * @static\n * @since 1.3.0\n * @memberOf Manipulate\n * @param  {string} [subject=''] The string to translate.\n * @param  {string|Object} from The string of characters to translate from. Or an object, then the object keys are replaced with corresponding values (longest keys are tried first).\n * @param  {string} to The string of characters to translate to. Ignored when `from` is an object.\n * @return {string} Returns the translated string.\n * @example\n * v.tr('hello', 'el', 'ip');\n * // => 'hippo'\n * \n * v.tr('l칠g칟ret칠', '칠칟', 'ee');\n * // => 'legerete'\n * \n * v.tr('Yes. The fire rises.', {\n *   'Yes': 'Awesome',\n *   'fire': 'flame'\n * })\n * // => 'Awesome. The flame rises.'\n * \n * v.tr(':where is the birthplace of :what', {\n *   ':where': 'Africa',\n *   ':what': 'Humanity'\n * });\n * // => 'Africa is the birthplace of Humanity'\n * \n */\nexport default function tr(subject, from, to) {\n  const subjectString = coerceToString(subject);\n  let keys;\n  let values;\n  if (isString(from) && isString(to)) {\n    keys = from.split('');\n    values = to.split('');\n  } else {\n    [keys, values] = extractKeysAndValues(nilDefault(from, {}));\n  }\n  const keysLength = keys.length;\n  if (keysLength === 0) {\n    return subjectString;\n  }\n  let result = '';\n  const valuesLength = values.length;\n  for (let index = 0; index < subjectString.length; index++) {\n    let isMatch = false;\n    let matchValue;\n    for (let keyIndex = 0; keyIndex < keysLength && keyIndex < valuesLength; keyIndex++) {\n      const key = keys[keyIndex];\n      if (subjectString.substr(index, key.length) === key) {\n        isMatch = true;\n        matchValue = values[keyIndex];\n        index = index + key.length - 1;\n        break;\n      }\n    }\n    result += isMatch ? matchValue : subjectString[index];\n  }\n  return result;\n}\n\nfunction extractKeysAndValues(object) {\n  const keys = Object.keys(object);\n  const values = keys.sort(sortStringByLength).map(function (key) {\n    return object[key];\n  });\n  return [keys, values];\n}\n\nfunction sortStringByLength(str1, str2) {\n  if (str1.length === str2.length) {\n    return 0;\n  }\n  return str1.length < str2.length ? 1 : -1;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport includes from 'query/includes';\nimport isNil from 'helper/object/is_nil';\nimport { REGEXP_TRIM_LEFT } from 'helper/reg_exp/const';\nimport toString from 'helper/string/to_string';\n\nconst reduce = Array.prototype.reduce;\n\n/**\n * Removes whitespaces from the left side of the `subject`.\n *\n * @function trimLeft\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to trim.\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\n * @return {string} Returns the trimmed string.\n * @example\n * v.trimLeft('  Starship Troopers');\n * // => 'Starship Troopers'\n *\n * v.trimLeft('***Mobile Infantry', '*');\n * // => 'Mobile Infantry'\n */\nexport default function trimLeft(subject, whitespace) {\n  const subjectString = coerceToString(subject);\n  if (whitespace === '' || subjectString === '') {\n    return subjectString;\n  }\n  const whitespaceString = toString(whitespace);\n  if (isNil(whitespaceString)) {\n    return subjectString.replace(REGEXP_TRIM_LEFT, '');\n  }\n  let matchWhitespace = true;\n  return reduce.call(subjectString, function(trimmed, character) {\n    if (matchWhitespace && includes(whitespaceString, character)) {\n      return trimmed;\n    }\n    matchWhitespace = false;\n    return trimmed + character;\n  }, '');\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport includes from 'query/includes';\nimport isNil from 'helper/object/is_nil';\nimport { REGEXP_TRIM_RIGHT } from 'helper/reg_exp/const';\nimport toString from 'helper/string/to_string';\n\nconst reduceRight = Array.prototype.reduceRight;\n\n/**\n * Removes whitespaces from the right side of the `subject`.\n *\n * @function trimRight\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to trim.\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\n * @return {string} Returns the trimmed string.\n * @example\n * v.trimRight('the fire rises   ');\n * // => 'the fire rises'\n *\n * v.trimRight('do you feel in charge?!!!', '!');\n * // => 'do you feel in charge?'\n */\nexport default function trimRight(subject, whitespace) {\n  const subjectString = coerceToString(subject);\n  if (whitespace === '' || subjectString === '') {\n    return subjectString;\n  }\n  const whitespaceString = toString(whitespace);\n  if (isNil(whitespaceString)) {\n    return subjectString.replace(REGEXP_TRIM_RIGHT, '');\n  }\n  let matchWhitespace = true;\n  return reduceRight.call(subjectString, function(trimmed, character) {\n    if (matchWhitespace && includes(whitespaceString, character)) {\n      return trimmed;\n    }\n    matchWhitespace = false;\n    return character + trimmed;\n  }, '');\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toString from 'helper/string/to_string';\nimport trimLeft from 'manipulate/trim_left';\nimport trimRight from 'manipulate/trim_right';\n\n/**\n * Removes whitespaces from left and right sides of the `subject`.\n *\n * @function trim\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to trim.\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\n * @return {string} Returns the trimmed string.\n * @example\n * v.trim(' Mother nature ');\n * // => 'Mother nature'\n *\n * v.trim('--Earth--', '-');\n * // => 'Earth'\n */\nexport default function trim(subject, whitespace) {\n  const subjectString = coerceToString(subject);\n  if (whitespace === '' || subjectString === '') {\n    return subjectString;\n  }\n  const whitespaceString = toString(whitespace);\n  if (isNil(whitespaceString)) {\n    return subjectString.trim();\n  }\n  return trimRight(trimLeft(subjectString, whitespaceString), whitespaceString);\n}","import coerceToBoolean from 'helper/boolean/coerce_to_boolean';\nimport coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\n\nconst OPTION_WIDTH = 'width';\nconst OPTION_NEW_LINE = 'newLine';\nconst OPTION_INDENT = 'indent';\nconst OPTION_CUT = 'cut';\n\n/**\n * Wraps `subject` to a given number of characters using a string break character.\n *\n * @function wordWrap\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param  {string} [subject=''] The string to wrap.\n * @param  {Object} [options={}] The wrap options.\n * @param  {number} [options.width=75] The number of characters at which to wrap.\n * @param  {string} [options.newLine='\\n'] The string to add at the end of line.\n * @param  {string} [options.indent='']  The string to intend the line.\n * @param  {boolean} [options.cut=false] When `false` (default) does not split the word even if word length is bigger than `width`. <br/>\n *                                       When `true` breaks the word that has length bigger than `width`.\n *\n * @return {string} Returns wrapped string.\n * @example\n * v.wordWrap('Hello world', {\n *   width: 5\n * });\n * // => 'Hello\\nworld'\n *\n * v.wordWrap('Hello world', {\n *   width: 5,\n *   newLine: '<br/>',\n *   indent: '__'\n * });\n * // => '__Hello<br/>__world'\n *\n * v.wordWrap('Wonderful world', {\n *   width: 5,\n *   cut: true\n * });\n * // => 'Wonde\\nrful\\nworld'\n *\n */\nexport default function wordWrap(subject, options = {}) {\n  const subjectString = coerceToString(subject);\n  const { width, newLine, indent, cut } = determineOptions(options);\n  if (subjectString === '' || width <= 0) {\n    return indent;\n  }\n  const subjectLength = subjectString.length;\n  const substring = subjectString.substring.bind(subjectString);\n  let offset = 0;\n  let wrappedLine = '';\n  while ((subjectLength - offset) > width) {\n    if (subjectString[offset] === ' ') {\n      offset++;\n      continue;\n    }\n    let spaceToWrapAt = subjectString.lastIndexOf(' ', width + offset);\n    if (spaceToWrapAt >= offset) {\n      wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;\n      offset = spaceToWrapAt + 1;\n    } else {\n      if (cut) {\n        wrappedLine += indent + substring(offset, width + offset) + newLine;\n        offset += width;\n      } else {\n        spaceToWrapAt = subjectString.indexOf(' ', width + offset);\n        if (spaceToWrapAt >= 0) {\n          wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;\n          offset = spaceToWrapAt + 1;\n        } else {\n          wrappedLine += indent + substring(offset);\n          offset = subjectLength;\n        }\n      }\n    }\n  }\n  if (offset < subjectLength) {\n    wrappedLine += indent + substring(offset);\n  }\n  return wrappedLine;\n}\n\n/**\n * Determine the word wrap options. The missing values are filled with defaults.\n *\n * @param  {Object} options  The options object.\n * @return {Object}          The word wrap options, with default settings if necessary.\n * @ignore\n */\nfunction determineOptions(options) {\n  return {\n    width: coerceToNumber(options[OPTION_WIDTH], 75),\n    newLine: coerceToString(options[OPTION_NEW_LINE], '\\n'),\n    indent: coerceToString(options[OPTION_INDENT], ''),\n    cut: coerceToBoolean(options[OPTION_CUT], false)\n  };\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Checks whether `subject` ends with `end`.\n *\n * @function endsWith\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @param {string} end The ending string.\n * @param {number} [position=subject.length] Search within `subject` as if the string were only `position` long.\n * @return {boolean} Returns `true` if `subject` ends with `end` or `false` otherwise.\n * @example\n * v.endsWith('red alert', 'alert');\n * // => true\n *\n * v.endsWith('metro south', 'metro');\n * // => false\n *\n * v.endsWith('Murphy', 'ph', 5);\n * // => true\n */\nexport default function endsWith(subject, end, position) {\n  if (isNil(end)) {\n    return false;\n  }\n  const subjectString = coerceToString(subject);\n  const endString = coerceToString(end);\n  if (endString === '') {\n    return true;\n  }\n  position = isNil(position) ? subjectString.length : clipNumber(toInteger(position), 0, subjectString.length);\n  position -= endString.length;\n  const lastIndex = subjectString.indexOf(endString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_ALPHA } from 'helper/reg_exp/const_extended';\n\n/**\n * Checks whether `subject` contains only alpha characters.\n *\n * @function isAlpha\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` contains only alpha characters or `false` otherwise.\n * @example\n * v.isAlpha('bart');\n * // => true\n *\n * v.isAlpha('lisa!');\n * // => false\n *\n * v.isAlpha('lisa and bart');\n * // => false\n */\nexport default function isAlpha(subject) {\n  const subjectString = coerceToString(subject);\n  return REGEXP_ALPHA.test(subjectString);\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_ALPHA_DIGIT } from 'helper/reg_exp/const_extended';\n\n/**\n * Checks whether `subject` contains only alpha and digit characters.\n *\n * @function isAlphaDigit\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` contains only alpha and digit characters or `false` otherwise.\n * @example\n * v.isAlphaDigit('year2020');\n * // => true\n *\n * v.isAlphaDigit('1448');\n * // => true\n *\n * v.isAlphaDigit('40-20');\n * // => false\n */\nexport default function isAlphaDigit(subject) {\n  const subjectString = coerceToString(subject);\n  return REGEXP_ALPHA_DIGIT.test(subjectString);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Checks whether `subject` is empty or contains only whitespaces.\n *\n * @function isBlank\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is empty or contains only whitespaces or `false` otherwise.\n * @example\n * v.isBlank('');\n * // => true\n *\n * v.isBlank('  ');\n * // => true\n *\n * v.isBlank('World');\n * // => false\n */\nexport default function isBlank(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.trim().length === 0;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_DIGIT } from 'helper/reg_exp/const';\n\n/**\n * Checks whether `subject` contains only digit characters.\n *\n * @function isDigit\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` contains only digit characters or `false` otherwise.\n * @example\n * v.isDigit('35');\n * // => true\n *\n * v.isDigit('1.5');\n * // => false\n *\n * v.isDigit('ten');\n * // => false\n */\nexport default function isDigit(subject) {\n  const subjectString = coerceToString(subject);\n  return REGEXP_DIGIT.test(subjectString);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Checks whether `subject` is empty.\n *\n * @function isEmpty\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is empty or `false` otherwise\n * @example\n * v.isEmpty('');\n * // => true\n *\n * v.isEmpty('  ');\n * // => false\n *\n * v.isEmpty('sun');\n * // => false\n */\nexport default function isEmpty(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.length === 0;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport isAlpha from 'query/is_alpha';\n\n/**\n * Checks whether `subject` has only lower case characters.\n *\n * @function isLowerCase\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is lower case or `false` otherwise.\n * @example\n * v.isLowerCase('motorcycle');\n * // => true\n *\n * v.isLowerCase('John');\n * // => false\n *\n * v.isLowerCase('T1000');\n * // => false\n */\nexport default function isLowerCase(subject) {\n  const valueString = coerceToString(subject);\n  return isAlpha(valueString) && valueString.toLowerCase() === valueString;\n}","import isNil from 'helper/object/is_nil';\n\n/**\n * Checks whether `subject` is numeric.\n *\n * @function isNumeric\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is numeric or `false` otherwise.\n * @example\n * v.isNumeric('350');\n * // => true\n *\n * v.isNumeric('-20.5');\n * // => true\n *\n * v.isNumeric('1.5E+2');\n * // => true\n *\n * v.isNumeric('five');\n * // => false\n */\nexport default function isNumeric(subject) {\n  const valueNumeric = typeof subject === 'object' && !isNil(subject) ? Number(subject) : subject;\n  return (typeof valueNumeric === 'number' || typeof valueNumeric === 'string')\n    && !isNaN(valueNumeric - parseFloat(valueNumeric));\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport isAlpha from 'query/is_alpha';\n\n/**\n * Checks whether `subject` contains only upper case characters.\n *\n * @function isUpperCase\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is upper case or `false` otherwise.\n * @example\n * v.isUpperCase('ACDC');\n * // => true\n *\n * v.isUpperCase('Morning');\n * // => false\n */\nexport default function isUpperCase(subject) {\n  const subjectString = coerceToString(subject);\n  return isAlpha(subjectString) && subjectString.toUpperCase() === subjectString;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport toString from 'helper/string/to_string';\n\n/**\n * Checks whether `subject` matches the regular expression `pattern`.\n *\n * @function matches\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @param {RegExp|string} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\n * @return {boolean} Returns `true` if `subject` matches `pattern` or `false` otherwise.\n * @example\n * v.matches('pluto', /plu.{2}/);\n * // => true\n *\n * v.matches('sun', 'S', 'i');\n * // => true\n *\n * v.matches('apollo 11', '\\\\d{3}');\n * // => false\n */\nexport default function matches(subject, pattern, flags) {\n  const subjectString = coerceToString(subject);\n  const flagsString = coerceToString(flags);\n  let patternString;\n  if (!(pattern instanceof RegExp)) {\n    patternString = toString(pattern);\n    if (patternString === null) {\n      return false;\n    }\n    pattern = new RegExp(patternString, flagsString);\n  }\n  return pattern.test(subjectString);\n}","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\nimport toString from 'helper/string/to_string';\n\n/**\n * Checks whether `subject` starts with `start`.\n *\n * @function startsWith\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @param {string} start The starting string.\n * @param {number} [position=0] The position to start searching.\n * @return {boolean} Returns `true` if `subject` starts with `start` or `false` otherwise.\n * @example\n * v.startsWith('say hello to my little friend', 'say hello');\n * // => true\n *\n * v.startsWith('tony', 'on', 1);\n * // => true\n *\n * v.startsWith('the world is yours', 'world');\n * // => false\n */\nexport default function startsWith(subject, start, position) {\n  const subjectString = coerceToString(subject);\n  const startString = toString(start);\n  if (startString === null) {\n    return false;\n  }\n  if (startString === '') {\n    return true;\n  }\n  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);\n  return subjectString.substr(position, startString.length) === startString;\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Splits `subject` into an array of characters.\n *\n * @function chars\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into characters.\n * @return {Array} Returns the array of characters.\n * @example\n * v.chars('cloud');\n * // => ['c', 'l', 'o', 'u', 'd']\n */\nexport default function chars(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split('');\n}","import codePointAt from 'chop/code_point_at';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Returns an array of Unicode code point values from characters of `subject`.\n *\n * @function codePoints\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param  {string} [subject=''] The string to extract from.\n * @return {Array} Returns an array of non-negative numbers less than or equal to `0x10FFFF`.\n * @example\n * v.codePoints('rain');\n * // => [114, 97, 105, 110], or\n * //    [0x72, 0x61, 0x69, 0x6E]\n *\n * v.codePoints('\\uD83D\\uDE00 smile'); // or '游 smile'\n * // => [128512, 32, 115, 109, 105, 108, 101], or\n * //    [0x1F600, 0x20, 0x73, 0x6D, 0x69, 0x6C, 0x65]\n */\nexport default function codePoints(subject) {\n  const subjectString = coerceToString(subject);\n  const subjectStringLength = subjectString.length;\n  const codePointArray = [];\n  let index = 0;\n  let codePointNumber;\n  while (index < subjectStringLength) {\n    codePointNumber = codePointAt(subjectString, index);\n    codePointArray.push(codePointNumber);\n    index += codePointNumber > 0xFFFF ? 2 : 1;\n  }\n  return codePointArray;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport nilDefault from 'helper/undefined/nil_default';\nimport { REGEXP_UNICODE_CHARACTER } from 'helper/reg_exp/const';\n\n/**\n * Splits `subject` into an array of graphemes taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function graphemes\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into characters.\n * @return {Array} Returns the array of graphemes.\n * @example\n * v.graphemes('\\uD835\\uDC00\\uD835\\uDC01'); // or '洧洧내'\n * // => ['\\uD835\\uDC00', '\\uD835\\uDC01'], or\n * //    ['洧', '洧내']\n *\n * v.graphemes('cafe\\u0301'); // or 'cafe패'\n * // => ['c', 'a', 'f', 'e\\u0301'], or\n * //    ['c', 'a', 'f', 'e패']\n */\nexport default function graphemes(subject) {\n  const subjectString = coerceToString(subject);\n  return nilDefault(subjectString.match(REGEXP_UNICODE_CHARACTER), []);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Splits `subject` into an array of chunks by `separator`.\n *\n * @function split\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into characters.\n * @param {string|RegExp} [separator] The pattern to match the separator.\n * @param {number} [limit] Limit the number of chunks to be found.\n * @return {Array} Returns the array of chunks.\n * @example\n * v.split('rage against the dying of the light', ' ');\n * // => ['rage', 'against', 'the', 'dying', 'of', 'the', 'light']\n *\n * v.split('the dying of the light', /\\s/, 3);\n * // => ['the', 'dying', 'of']\n */\nexport default function split(subject, separator, limit) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split(separator, limit);\n}","import coerceToString from 'helper/string/coerce_to_string';\n\nconst BYRE_ORDER_MARK = '\\uFEFF';\n\n/**\n * Strips the byte order mark (BOM) from the beginning of `subject`.\n *\n * @function stripBom\n * @static\n * @since 1.2.0\n * @memberOf Strip\n * @param {string} [subject=''] The string to strip from.\n * @return {string} Returns the stripped string.\n * @example\n *\n * v.stripBom('\\uFEFFsummertime sadness');\n * // => 'summertime sadness'\n *\n * v.stripBom('summertime happiness');\n * // => 'summertime happiness'\n *\n */\nexport default function trim(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  if (subjectString[0] === BYRE_ORDER_MARK) {\n    return subjectString.substring(1);\n  }\n  return subjectString;\n}","/**\n * Checks whether `subject` contains substring at specific `index`.\n *\n * @ignore\n * @param {string} subject The subject to search in.\n * @param {string} substring The substring to search/\n * @param {number} index The index to search substring.\n * @param {boolean} lookBehind Whether to look behind (true) or ahead (false).\n * @return {boolean} Returns a boolean whether the substring exists.\n */\nexport default function hasSubstringAtIndex(subject, substring, index, lookBehind = true) {\n  let indexOffset = 0;\n  if (lookBehind) {\n    indexOffset = - substring.length + 1;\n  }\n  const extractedSubstring = subject.substr(index + indexOffset, substring.length);\n  return extractedSubstring.toLowerCase() === substring;\n}","import { REGEXP_TAG_LIST } from 'helper/reg_exp/const';\n\n/**\n * Parses the tags from the string '<tag1><tag2>...<tagN>'.\n *\n * @ignore\n * @param {string} tags The string that contains the tags.\n * @return {string[]} Returns the array of tag names.\n */\nexport default function parseTagList(tags) {\n  const tagsList = [];\n  let match;\n  while ((match = REGEXP_TAG_LIST.exec(tags)) !== null) {\n    tagsList.push(match[1]);\n  }\n  return tagsList;\n}","import { REGEXP_WHITESPACE } from 'helper/reg_exp/const';\n\nconst STATE_START_TAG = 0;\nconst STATE_NON_WHITESPACE = 1;\nconst STATE_DONE = 2;\n\n/**\n * Parses the tag name from html content.\n *\n * @ignore\n * @param {string} tagContent The tag content.\n * @return {string} Returns the tag name.\n */\nexport default function parseTagName(tagContent) {\n  let state = STATE_START_TAG;\n  let tagName = '';\n  let index = 0;\n  while (state !== STATE_DONE) {\n    const char = tagContent[index++].toLowerCase();\n    switch (char) {\n      case '<':\n        break;\n      case '>':\n        state = STATE_DONE;\n        break;\n      default:\n        if (REGEXP_WHITESPACE.test(char)) {\n          if (state === STATE_NON_WHITESPACE) {\n            state = STATE_DONE;\n          }\n        } else {\n          if (state === STATE_START_TAG) {\n            state = STATE_NON_WHITESPACE;\n          }\n          if (char !== '/') {\n            tagName += char;\n          }\n        }\n        break;\n    }\n  }\n  return tagName;\n}","import coerceToString from 'helper/string/coerce_to_string';\nimport hasSubstringAtIndex from 'helper/string/has_substring_at_index';\nimport parseTagList from 'helper/strip/parse_tag_list';\nimport parseTagName from 'helper/strip/parse_tag_name';\n\nconst STATE_OUTPUT = 0;\nconst STATE_HTML = 1;\nconst STATE_EXCLAMATION = 2;\nconst STATE_COMMENT = 3;\n\n/**\n * Strips HTML tags from `subject`.\n *\n * @function stripTags\n * @static\n * @since 1.1.0\n * @memberOf Strip\n * @param {string} [subject=''] The string to strip from.\n * @param {string|Array} [allowableTags] The string `'<tag1><tag2>'` or array `['tag1', 'tag2']` of tags that should not be stripped.\n * @param {string} [replacement=''] The string to replace the stripped tag.\n * @return {string} Returns the stripped string.\n * @example\n *\n * v.stripTags('<span><a href=\"#\">Summer</a> is nice</span>');\n * // => 'Summer is nice'\n *\n * v.stripTags('<span><i>Winter</i> is <b>cold</b></span>', ['b', 'i']);\n * // => '<i>Winter</i> is <b>cold</b>'\n *\n * v.stripTags('Sun<br/>set', '', '-');\n * // => 'Sun-set'\n */\nexport default function trim(subject, allowableTags, replacement) {\n  subject = coerceToString(subject);\n  if (subject === '') {\n    return '';\n  }\n  if (!Array.isArray(allowableTags)) {\n    const allowableTagsString = coerceToString(allowableTags);\n    allowableTags = allowableTagsString === '' ? [] : parseTagList(allowableTagsString);\n  }\n  const replacementString = coerceToString(replacement);\n  const length = subject.length;\n  const hasAllowableTags = allowableTags.length > 0;\n  const hasSubstring = hasSubstringAtIndex.bind(null, subject);\n  let state = STATE_OUTPUT;\n  let depth = 0;\n  let output = '';\n  let tagContent = '';\n  let quote = null;\n  for (let index = 0; index < length; index++) {\n    const char = subject[index];\n    let advance = false;\n    switch (char) {\n      case '<':\n        if (quote) {\n          break;\n        }\n        if (hasSubstring('< ', index, false)) {\n          advance = true;\n          break;\n        }\n        if (state === STATE_OUTPUT) {\n          advance = true;\n          state = STATE_HTML;\n          break;\n        }\n        if (state === STATE_HTML) {\n          depth++;\n          break;\n        }\n        advance = true;\n        break;\n      case '!':\n        if (state === STATE_HTML && hasSubstring('<!', index)) {\n          state = STATE_EXCLAMATION;\n          break;\n        }\n        advance = true;\n        break;\n      case '-':\n        if (state === STATE_EXCLAMATION && hasSubstring('!--', index)) {\n          state = STATE_COMMENT;\n          break;\n        }\n        advance = true;\n        break;\n      case '\"':\n      case \"'\":\n        if (state === STATE_HTML) {\n          if (quote === char) {\n            quote = null;\n          } else if (!quote) {\n            quote = char;\n          }\n        }\n        advance = true;\n        break;\n      case 'E':\n      case 'e':\n        if (state === STATE_EXCLAMATION && hasSubstring('doctype', index)) {\n          state = STATE_HTML;\n          break;\n        }\n        advance = true;\n        break;\n      case '>':\n        if (depth > 0) {\n          depth--;\n          break;\n        }\n        if (quote) {\n          break;\n        }\n        if (state === STATE_HTML) {\n          quote = null;\n          state = STATE_OUTPUT;\n          if (hasAllowableTags) {\n            tagContent += '>';\n            const tagName = parseTagName(tagContent);\n            if (allowableTags.indexOf(tagName.toLowerCase()) !== -1) {\n              output += tagContent;\n            } else {\n              output += replacementString;\n            }\n            tagContent = '';\n          } else {\n            output += replacementString;\n          }\n          break;\n        }\n        if (state === STATE_EXCLAMATION || state === STATE_COMMENT && hasSubstring('-->', index)) {\n          quote = null;\n          state = STATE_OUTPUT;\n          tagContent = '';\n          break;\n        }\n        advance = true;\n        break;\n      default:\n        advance = true;\n    }\n    if (advance) {\n      switch (state) {\n        case STATE_OUTPUT:\n          output += char;\n          break;\n        case STATE_HTML:\n          if (hasAllowableTags) {\n            tagContent += char;\n          }\n          break;\n      }\n    }\n  }\n  return output;\n}","import getGlobalObject from 'helper/object/get_global';\n\nconst globalObject = getGlobalObject();\nconst previousV = globalObject.v;\n\n/**\n * Restores `v` variable to previous value and returns Voca library instance.\n *\n * @function noConflict\n * @static\n * @since 1.0.0\n * @memberOf Util\n * @return {Object} Returns Voca library instance.\n * @example\n * var voca = v.noConflict();\n * voca.isAlpha('Hello');\n * // => true\n */\nexport default function noConflict() {\n  if (this === globalObject.v) {\n    globalObject.v = previousV;\n  }\n  return this;\n}\n","import functions from 'functions';\n\n\n/**\n * The chain wrapper constructor.\n *\n * @ignore\n * @param  {string}       subject               The string to be wrapped.\n * @param  {boolean}      [explicitChain=false] A boolean that indicates if the chain sequence is explicit or implicit.\n * @return {ChainWrapper}                       Returns a new instance of `ChainWrapper`\n * @constructor\n */\nfunction ChainWrapper(subject, explicitChain) {\n  this._wrappedValue = subject;\n  this._explicitChain = explicitChain;\n}\n\n/**\n * Unwraps the chain sequence wrapped value.\n *\n * @memberof Chain\n * @since 1.0.0\n * @function __proto__value\n * @return {*} Returns the unwrapped value.\n * @example\n * v\n *  .chain('Hello world')\n *  .replace('Hello', 'Hi')\n *  .lowerCase()\n *  .slugify()\n *  .value()\n * // => 'hi-world'\n *\n * v(' Space travel ')\n *  .trim()\n *  .truncate(8)\n *  .value()\n * // => 'Space...'\n */\nChainWrapper.prototype.value = function() {\n  return this._wrappedValue;\n};\n\n/**\n * Override the default object valueOf().\n *\n * @ignore\n * @return {*} Returns the wrapped value.\n */\nChainWrapper.prototype.valueOf = function() {\n  return this.value();\n};\n\n/**\n * Returns the wrapped value to be used in JSON.stringify().\n *\n * @ignore\n * @return {*} Returns the wrapped value.\n */\nChainWrapper.prototype.toJSON = function() {\n  return this.value();\n};\n\n/**\n * Returns the string representation of the wrapped value.\n *\n * @ignore\n * @return {string} Returns the string representation.\n */\nChainWrapper.prototype.toString = function() {\n  return String(this.value());\n};\n\n/**\n * Creates a new chain object that enables <i>explicit</i> chain sequences.\n * Use `v.prototype.value()` to unwrap the result. <br/>\n * Does not modify the wrapped value.\n *\n * @memberof Chain\n * @since 1.0.0\n * @function __proto__chain\n * @return {Object} Returns the wrapper in <i>explicit</i> mode.\n * @example\n * v('Back to School')\n *  .chain()\n *  .lowerCase()\n *  .words()\n *  .value()\n * // => ['back', 'to', 'school']\n *\n * v(\" Back to School \")\n *  .chain()\n *  .trim()\n *  .truncate(7)\n *  .value()\n * // => 'Back...'\n */\nChainWrapper.prototype.chain = function() {\n  return new ChainWrapper(this._wrappedValue, true);\n};\n\n/**\n * Modifies the wrapped value with the invocation result of `changer` function. The current wrapped value is the\n * argument of `changer` invocation.\n *\n * @memberof Chain\n * @since 1.0.0\n * @function __proto__thru\n * @param  {Function} changer The function to invoke.\n * @return {Object}           Returns the new wrapper that wraps the invocation result of `changer`.\n * @example\n * v\n *  .chain('sun is shining')\n *  .words()\n *  .thru(function(words) {\n *    return words[0];\n *  })\n *  .value()\n * // => 'sun'\n *\n */\nChainWrapper.prototype.thru = function(changer) {\n  if (typeof changer === 'function') {\n    return new ChainWrapper(changer(this._wrappedValue), this._explicitChain);\n  }\n  return this;\n};\n\n/**\n * A boolean that indicates if the chain sequence is explicit or implicit.\n * @ignore\n * @type {boolean}\n * @private\n */\nChainWrapper.prototype._explicitChain = true;\n\n/**\n * Make a voca function chainable.\n *\n * @ignore\n * @param  {Function} functionInstance The function to make chainable\n * @return {Function}                  Returns the chainable function\n */\nfunction makeFunctionChainable(functionInstance) {\n  return function(...args) {\n    const result = functionInstance(this._wrappedValue, ...args);\n    if (this._explicitChain || typeof result === 'string') {\n      return new ChainWrapper(result, this._explicitChain);\n    } else {\n      return result;\n    }\n  };\n}\n\nObject.keys(functions).forEach(function(name) {\n  ChainWrapper.prototype[name] = makeFunctionChainable(functions[name]);\n});\n\n\nexport default ChainWrapper;","import ChainWrapper from 'chain/wrapper';\n\n/**\n * Creates a chain object that wraps `subject`, enabling <i>explicit</i> chain sequences. <br/>\n * Use `v.prototype.value()` to unwrap the result.\n *\n * @memberOf Chain\n * @since 1.0.0\n * @function chain\n * @param  {string} subject The string to wrap.\n * @return {Object}         Returns the new wrapper object.\n * @example\n * v\n *  .chain('Back to School')\n *  .lowerCase()\n *  .words()\n *  .value()\n * // => ['back', 'to', 'school']\n */\nexport default function chain(subject) {\n  return new ChainWrapper(subject, true);\n}","import chain from './chain/chain'; // include chain here to resolve af circular reference\nimport ChainWrapper from './chain/wrapper';\nimport functions from './functions';\n\n/**\n * Creates a chain object that wraps `subject`, enabling <i>implicit</i> chain sequences.<br/>\n * A function that returns `number`, `boolean` or `array` type <i>terminates</i> the chain sequence and returns the unwrapped value.\n * Otherwise use `v.prototype.value()` to unwrap the result.\n *\n * @memberOf Chain\n * @since 1.0.0\n * @function v\n * @param {string} subject The string to wrap.\n * @return {Object}  Returns the new wrapper object.\n * @example\n * v('Back to School')\n *  .lowerCase()\n *  .words()\n * // => ['back', 'to', 'school']\n *\n * v(\" Back to School \")\n *  .trim()\n *  .truncate(7)\n *  .value()\n * // => 'Back...'\n */\nfunction Voca(subject) {\n  return new ChainWrapper(subject, false);\n}\n\nObject.assign(Voca, functions, {\n  chain: chain\n});\n\nexport default Voca;","/**\n * A regular expression string matching digits\n *\n * @type {string}\n * @ignore\n */\nexport const digit = '\\\\d';\n\n/**\n * A regular expression string matching whitespace\n *\n * @type {string}\n * @ignore\n */\nexport const whitespace = '\\\\s\\\\uFEFF\\\\xA0';\n\n/**\n * A regular expression string matching high surrogate\n *\n * @type {string}\n * @ignore\n */\nexport const highSurrogate = '\\\\uD800-\\\\uDBFF';\n\n/**\n * A regular expression string matching low surrogate\n *\n * @type {string}\n * @ignore\n */\nexport const lowSurrogate = '\\\\uDC00-\\\\uDFFF';\n\n/**\n * A regular expression string matching diacritical mark\n *\n * @type {string}\n * @ignore\n */\nexport const diacriticalMark = '\\\\u0300-\\\\u036F\\\\u1AB0-\\\\u1AFF\\\\u1DC0-\\\\u1DFF\\\\u20D0-\\\\u20FF\\\\uFE20-\\\\uFE2F';\n\n/**\n * A regular expression to match the base character for a combining mark\n *\n * @type {string}\n * @ignore\n */\nexport const base = '\\\\0-\\\\u02FF\\\\u0370-\\\\u1AAF\\\\u1B00-\\\\u1DBF\\\\u1E00-\\\\u20CF\\\\u2100-\\\\uD7FF\\\\uE000-\\\\uFE1F\\\\uFE30-\\\\uFFFF';\n\n/**\n * Regular expression to match combining marks\n *\n * @see http://unicode.org/faq/char_combmark.html\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_COMBINING_MARKS = new RegExp('([' + base + ']|[' + highSurrogate + '][' + lowSurrogate + ']|[' + highSurrogate + '](?![' + lowSurrogate + '])|(?:[^' + highSurrogate + ']|^)[' + lowSurrogate + '])([' + diacriticalMark + ']+)', 'g');\n\n/**\n * Regular expression to match surrogate pairs\n *\n * @see http://www.unicode.org/faq/utf_bom.html#utf16-2\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_SURROGATE_PAIRS = new RegExp('([' + highSurrogate + '])([' + lowSurrogate + '])', 'g');\n\n/**\n * Regular expression to match a unicode character\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_UNICODE_CHARACTER = new RegExp(\n  '((?:[' + base + ']|[' + highSurrogate + '][' + lowSurrogate + ']|[' + highSurrogate + '](?![' + lowSurrogate + '])|(?:[^' + highSurrogate + ']|^)[' + lowSurrogate + '])(?:[' + diacriticalMark + ']+))|\\\n([' + highSurrogate + '][' + lowSurrogate + '])|\\\n([\\\\n\\\\r\\\\u2028\\\\u2029])|\\\n(.)', 'g');\n\n/**\n * Regular expression to match whitespaces\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_WHITESPACE = new RegExp('[' + whitespace + ']');\n\n/**\n * Regular expression to match whitespaces from the left side\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_TRIM_LEFT = new RegExp('^[' + whitespace + ']+');\n\n/**\n * Regular expression to match whitespaces from the right side\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_TRIM_RIGHT = new RegExp('[' + whitespace + ']+$');\n\n/**\n * Regular expression to match digit characters\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_DIGIT = new RegExp('^' + digit + '+$');\n\n/**\n * Regular expression to match regular expression special characters\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_SPECIAL_CHARACTERS = /[-[\\]{}()*+!<=:?./\\\\^$|#,]/g;\n\n/**\n * Regular expression to match not latin characters\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_NON_LATIN = /[^A-Za-z0-9]/g;\n\n/**\n * Regular expression to match HTML special characters.\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_HTML_SPECIAL_CHARACTERS = /[<>&\"'`]/g;\n\n/**\n * Regular expression to match sprintf format string\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_CONVERSION_SPECIFICATION = /(%{1,2})(?:(\\d+)\\$)?(\\+)?([ 0]|'.{1})?(-)?(\\d+)?(?:\\.(\\d+))?([bcdiouxXeEfgGs])?/g;\n\n/**\n * Regular expression to match trailing zeros in a number\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_TRAILING_ZEROS = /\\.?0+$/g;\n\n/**\n * Regular expression to match flags from a regular expression.\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_FLAGS = /[gimuy]*$/;\n\n/**\n * Regular expression to match a list of tags.\n *\n * @see https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-name\n * @type {RegExp}\n * @ignore\n */\n\nexport const REGEXP_TAG_LIST = /<([A-Za-z0-9]+)>/g;","import { diacriticalMark, digit, whitespace  } from 'helper/reg_exp/const';\n\n/**\n * A regular expression to match the General Punctuation Unicode block\n *\n * @type {string}\n * @ignore\n */\nconst generalPunctuationBlock = '\\\\u2000-\\\\u206F';\n\n/**\n * A regular expression to match non characters from from Basic Latin and Latin-1 Supplement Unicode blocks\n *\n * @type {string}\n * @ignore\n */\nconst nonCharacter = '\\\\x00-\\\\x2F\\\\x3A-\\\\x40\\\\x5B-\\\\x60\\\\x7b-\\\\xBF\\\\xD7\\\\xF7';\n\n/**\n * A regular expression to match the dingbat Unicode block\n *\n * @type {string}\n * @ignore\n */\nconst dingbatBlock = '\\\\u2700-\\\\u27BF';\n\n/**\n * A regular expression string that matches lower case letters: LATIN\n *\n * @type {string}\n * @ignore\n */\nconst lowerCaseLetter = 'a-z\\\\xB5\\\\xDF-\\\\xF6\\\\xF8-\\\\xFF\\\\u0101\\\\u0103\\\\u0105\\\\u0107\\\\u0109\\\\u010B\\\\u010D\\\\u010F\\\\u0111\\\\u0113\\\\u0115\\\\u0117\\\\u0119\\\\u011B\\\\u011D\\\\u011F\\\\u0121\\\\u0123\\\\u0125\\\\u0127\\\\u0129\\\\u012B\\\\u012D\\\\u012F\\\\u0131\\\\u0133\\\\u0135\\\\u0137\\\\u0138\\\\u013A\\\\u013C\\\\u013E\\\\u0140\\\\u0142\\\\u0144\\\\u0146\\\\u0148\\\\u0149\\\\u014B\\\\u014D\\\\u014F\\\\u0151\\\\u0153\\\\u0155\\\\u0157\\\\u0159\\\\u015B\\\\u015D\\\\u015F\\\\u0161\\\\u0163\\\\u0165\\\\u0167\\\\u0169\\\\u016B\\\\u016D\\\\u016F\\\\u0171\\\\u0173\\\\u0175\\\\u0177\\\\u017A\\\\u017C\\\\u017E-\\\\u0180\\\\u0183\\\\u0185\\\\u0188\\\\u018C\\\\u018D\\\\u0192\\\\u0195\\\\u0199-\\\\u019B\\\\u019E\\\\u01A1\\\\u01A3\\\\u01A5\\\\u01A8\\\\u01AA\\\\u01AB\\\\u01AD\\\\u01B0\\\\u01B4\\\\u01B6\\\\u01B9\\\\u01BA\\\\u01BD-\\\\u01BF\\\\u01C6\\\\u01C9\\\\u01CC\\\\u01CE\\\\u01D0\\\\u01D2\\\\u01D4\\\\u01D6\\\\u01D8\\\\u01DA\\\\u01DC\\\\u01DD\\\\u01DF\\\\u01E1\\\\u01E3\\\\u01E5\\\\u01E7\\\\u01E9\\\\u01EB\\\\u01ED\\\\u01EF\\\\u01F0\\\\u01F3\\\\u01F5\\\\u01F9\\\\u01FB\\\\u01FD\\\\u01FF\\\\u0201\\\\u0203\\\\u0205\\\\u0207\\\\u0209\\\\u020B\\\\u020D\\\\u020F\\\\u0211\\\\u0213\\\\u0215\\\\u0217\\\\u0219\\\\u021B\\\\u021D\\\\u021F\\\\u0221\\\\u0223\\\\u0225\\\\u0227\\\\u0229\\\\u022B\\\\u022D\\\\u022F\\\\u0231\\\\u0233-\\\\u0239\\\\u023C\\\\u023F\\\\u0240\\\\u0242\\\\u0247\\\\u0249\\\\u024B\\\\u024D\\\\u024F';\n\n/**\n * A regular expression string that matches upper case letters: LATIN\n *\n * @type {string}\n * @ignore\n */\nconst upperCaseLetter = '\\\\x41-\\\\x5a\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\\\\u0100\\\\u0102\\\\u0104\\\\u0106\\\\u0108\\\\u010a\\\\u010c\\\\u010e\\\\u0110\\\\u0112\\\\u0114\\\\u0116\\\\u0118\\\\u011a\\\\u011c\\\\u011e\\\\u0120\\\\u0122\\\\u0124\\\\u0126\\\\u0128\\\\u012a\\\\u012c\\\\u012e\\\\u0130\\\\u0132\\\\u0134\\\\u0136\\\\u0139\\\\u013b\\\\u013d\\\\u013f\\\\u0141\\\\u0143\\\\u0145\\\\u0147\\\\u014a\\\\u014c\\\\u014e\\\\u0150\\\\u0152\\\\u0154\\\\u0156\\\\u0158\\\\u015a\\\\u015c\\\\u015e\\\\u0160\\\\u0162\\\\u0164\\\\u0166\\\\u0168\\\\u016a\\\\u016c\\\\u016e\\\\u0170\\\\u0172\\\\u0174\\\\u0176\\\\u0178\\\\u0179\\\\u017b\\\\u017d\\\\u0181\\\\u0182\\\\u0184\\\\u0186\\\\u0187\\\\u0189-\\\\u018b\\\\u018e-\\\\u0191\\\\u0193\\\\u0194\\\\u0196-\\\\u0198\\\\u019c\\\\u019d\\\\u019f\\\\u01a0\\\\u01a2\\\\u01a4\\\\u01a6\\\\u01a7\\\\u01a9\\\\u01ac\\\\u01ae\\\\u01af\\\\u01b1-\\\\u01b3\\\\u01b5\\\\u01b7\\\\u01b8\\\\u01bc\\\\u01c4\\\\u01c5\\\\u01c7\\\\u01c8\\\\u01ca\\\\u01cb\\\\u01cd\\\\u01cf\\\\u01d1\\\\u01d3\\\\u01d5\\\\u01d7\\\\u01d9\\\\u01db\\\\u01de\\\\u01e0\\\\u01e2\\\\u01e4\\\\u01e6\\\\u01e8\\\\u01ea\\\\u01ec\\\\u01ee\\\\u01f1\\\\u01f2\\\\u01f4\\\\u01f6-\\\\u01f8\\\\u01fa\\\\u01fc\\\\u01fe\\\\u0200\\\\u0202\\\\u0204\\\\u0206\\\\u0208\\\\u020a\\\\u020c\\\\u020e\\\\u0210\\\\u0212\\\\u0214\\\\u0216\\\\u0218\\\\u021a\\\\u021c\\\\u021e\\\\u0220\\\\u0222\\\\u0224\\\\u0226\\\\u0228\\\\u022a\\\\u022c\\\\u022e\\\\u0230\\\\u0232\\\\u023a\\\\u023b\\\\u023d\\\\u023e\\\\u0241\\\\u0243-\\\\u0246\\\\u0248\\\\u024a\\\\u024c\\\\u024e';\n\n/**\n * Regular expression to match Unicode words\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_WORD = new RegExp(\n  '(?:[' + upperCaseLetter + '][' + diacriticalMark + ']*)?(?:[' + lowerCaseLetter + '][' + diacriticalMark + ']*)+|\\\n(?:[' + upperCaseLetter + '][' + diacriticalMark + ']*)+(?![' + lowerCaseLetter + '])|\\\n[' + digit + ']+|\\\n[' + dingbatBlock + ']|\\\n[^' + nonCharacter + generalPunctuationBlock + whitespace + ']+', 'g');\n\n/**\n * Regular expression to match words from Basic Latin and Latin-1 Supplement blocks\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_LATIN_WORD = /[A-Z\\xC0-\\xD6\\xD8-\\xDE]?[a-z\\xDF-\\xF6\\xF8-\\xFF]+|[A-Z\\xC0-\\xD6\\xD8-\\xDE]+(?![a-z\\xDF-\\xF6\\xF8-\\xFF])|\\d+/g;\n\n/**\n * Regular expression to match alpha characters\n *\n * @see http://stackoverflow.com/a/22075070/1894471\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_ALPHA = new RegExp('^(?:[' + lowerCaseLetter + upperCaseLetter + '][' + diacriticalMark + ']*)+$');\n\n/**\n * Regular expression to match alpha and digit characters\n *\n * @see http://stackoverflow.com/a/22075070/1894471\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_ALPHA_DIGIT = new RegExp('^((?:[' + lowerCaseLetter + upperCaseLetter + '][' + diacriticalMark + ']*)|[' + digit + '])+$');\n\n/**\n * Regular expression to match Extended ASCII characters, i.e. the first 255\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_EXTENDED_ASCII = /^[\\x01-\\xFF]*$/;","/**\n * Max save integer value\n *\n * @ignore\n * @type {number}\n */\nexport const MAX_SAFE_INTEGER = 0x1fffffffffffff;","// Type specifiers\nexport const TYPE_INTEGER                       = 'i';\nexport const TYPE_INTEGER_BINARY                = 'b';\nexport const TYPE_INTEGER_ASCII_CHARACTER       = 'c';\nexport const TYPE_INTEGER_DECIMAL               = 'd';\nexport const TYPE_INTEGER_OCTAL                 = 'o';\nexport const TYPE_INTEGER_UNSIGNED_DECIMAL      = 'u';\nexport const TYPE_INTEGER_HEXADECIMAL           = 'x';\nexport const TYPE_INTEGER_HEXADECIMAL_UPPERCASE = 'X';\nexport const TYPE_FLOAT_SCIENTIFIC              = 'e';\nexport const TYPE_FLOAT_SCIENTIFIC_UPPERCASE    = 'E';\nexport const TYPE_FLOAT                         = 'f';\nexport const TYPE_FLOAT_SHORT                   = 'g';\nexport const TYPE_FLOAT_SHORT_UPPERCASE         = 'G';\nexport const TYPE_STRING                        = 's';\n\n// Simple literals\nexport const LITERAL_PERCENT           = '%';\nexport const LITERAL_SINGLE_QUOTE      = \"'\";\nexport const LITERAL_PLUS              = '+';\nexport const LITERAL_MINUS             = '-';\nexport const LITERAL_PERCENT_SPECIFIER = '%%';\n\n// Radix constants to format numbers\nexport const RADIX_BINARY      = 2;\nexport const RADIX_OCTAL       = 8;\nexport const RADIX_DECIMAL     = 10;\nexport const RADIX_HEXADECIMAL = 16;","let globalObject = null;\n\nfunction getGlobalObject() {\n  if (globalObject !== null) {\n    return globalObject;\n  }\n  /* istanbul ignore next */\n  // It's hard to mock the global variables. This code surely works fine. I hope :)\n  if (typeof global === 'object' && global.Object === Object) {\n    // NodeJS global object\n    globalObject = global;\n  } else if (typeof self === 'object' && self.Object === Object) {\n    // self property from Window object\n    globalObject = self;\n  } else {\n    // Other cases. Function constructor always has the context as global object\n    globalObject = new Function('return this')();\n  }\n  return globalObject;\n}\n\nexport default getGlobalObject;","/**\n * A property that contains the library <a href=\"http://semver.org/\">semantic version number</a>.\n * @name version\n * @static\n * @since 1.0.0\n * @memberOf Util\n * @type string\n * @example\n * v.version\n * // => '1.4.0'\n */\nconst version = '1.4.0';\n\nexport default version;"],"names":["isNil","value","undefined","coerceToBoolean","defaultValue","Boolean","isString","subject","coerceToString","String","capitalize","restToLower","subjectString","restToLowerCaseBoolean","toLowerCase","substr","toUpperCase","lowerCase","nilDefault","toString","words","pattern","flags","patternRegExp","REGEXP_EXTENDED_ASCII","test","REGEXP_LATIN_WORD","REGEXP_WORD","RegExp","flagsString","match","wordToCamel","word","index","camelCase","map","join","decapitalize","kebabCase","snakeCase","upperCase","swapCase","split","reduce","swapAndConcat","swapped","character","titleCase","noSplit","noSplitArray","Array","isArray","wordsRegExp","replace","indexOf","clipNumber","downLimit","upLimit","toInteger","Infinity","MAX_SAFE_INTEGER","truncate","length","end","lengthInt","endString","charAt","position","isHighSurrogate","codePoint","HIGH_SURROGATE_START","HIGH_SURROGATE_END","isLowSurrogate","LOW_SURROGATE_START","LOW_SURROGATE_END","getAstralNumberFromSurrogatePair","highSurrogate","lowSurrogate","coerceToNumber","Number","nanDefault","codePointAt","subjectStringLength","positionNumber","firstCodePoint","charCodeAt","secondCodePoint","first","graphemeAt","graphemeMatch","graphemeMatchIndex","REGEXP_UNICODE_CHARACTER","exec","lastIndex","last","prune","truncatedLength","offset","wordInsertLength","slice","start","substring","count","countGrapheme","REGEXP_COMBINING_MARKS","REGEXP_SURROGATE_PAIRS","countSubstrings","substringString","substringLength","matchIndex","countWhere","predicate","context","predicateWithContext","bind","call","countTruthy","countWords","ReplacementIndex","repeat","times","timesInt","repeatString","buildPadding","padCharacters","padLeft","pad","padString","padRight","alignAndPad","conversion","width","alignmentSpecifier","LITERAL_MINUS","getPaddingCharacter","addSignToFormattedNumber","replacementNumber","formattedReplacement","signSpecifier","LITERAL_PLUS","float","replacement","parseFloat","isNaN","precision","typeSpecifier","TYPE_FLOAT","toFixed","TYPE_FLOAT_SCIENTIFIC","toExponential","TYPE_FLOAT_SCIENTIFIC_UPPERCASE","TYPE_FLOAT_SHORT","TYPE_FLOAT_SHORT_UPPERCASE","formatFloatAsShort","nonZeroPrecision","toPrecision","REGEXP_TRAILING_ZEROS","integerBase","integer","parseInt","TYPE_INTEGER_ASCII_CHARACTER","fromCharCode","TYPE_INTEGER_BINARY","RADIX_BINARY","TYPE_INTEGER_OCTAL","RADIX_OCTAL","TYPE_INTEGER_HEXADECIMAL","RADIX_HEXADECIMAL","TYPE_INTEGER_HEXADECIMAL_UPPERCASE","integerDecimal","stringFormat","compute","formatFunction","TYPE_STRING","formatString","TYPE_INTEGER_DECIMAL","TYPE_INTEGER","formatIntegerDecimal","TYPE_INTEGER_UNSIGNED_DECIMAL","formatIntegerBase","formatFloat","ConversionSpecification","properties","percent","paddingSpecifier","validate","replacementsLength","Error","replacementIndex","replacements","conversionSpecification","widthSpecifier","precisionSpecifier","isPercentLiteral","actualReplacementIndex","getIndexByPosition","incrementOnEmptyPosition","computeReplacement","sprintf","format","boundReplacementMatch","replacementMatch","REGEXP_CONVERSION_SPECIFICATION","vprintf","replaceSpecialCharacter","escapeCharactersMap","escapeHtml","REGEXP_HTML_SPECIAL_CHARACTERS","escapeRegExp","REGEXP_SPECIAL_CHARACTERS","reduceUnescapedString","string","key","unescapeCharactersMap","unescapeHtml","characters","search","fromIndex","lastIndexOf","fromIndexNumber","insert","toInsert","toInsertString","getDiacriticsMap","diacriticsMap","keys","diacritics","forEach","getLatinCharacter","characterWithoutDiacritic","removeCombiningMarks","cleanCharacter","latinise","REGEXP_NON_LATIN","paddingLength","paddingSideLength","paddingSideRemainingLength","getRegExpFlags","regExp","REGEXP_FLAGS","includes","searchString","appendFlagToRegExp","appendFlag","regularExpressionFlags","source","replaceAll","global","appendFlagToRegularExpression","reverse","reverseGrapheme","reversedString","$0","$1","$2","slugify","splice","deleteCount","toAdd","toAddString","startPosition","deleteCountNumber","tr","from","to","values","extractKeysAndValues","keysLength","result","valuesLength","isMatch","matchValue","keyIndex","object","Object","sort","sortStringByLength","str1","str2","trimLeft","whitespace","whitespaceString","REGEXP_TRIM_LEFT","matchWhitespace","trimmed","trimRight","REGEXP_TRIM_RIGHT","reduceRight","trim","wordWrap","options","determineOptions","newLine","indent","cut","subjectLength","wrappedLine","spaceToWrapAt","OPTION_WIDTH","OPTION_NEW_LINE","OPTION_INDENT","OPTION_CUT","endsWith","isAlpha","REGEXP_ALPHA","isAlphaDigit","REGEXP_ALPHA_DIGIT","isBlank","isDigit","REGEXP_DIGIT","isEmpty","isLowerCase","valueString","isNumeric","valueNumeric","isUpperCase","matches","patternString","startsWith","startString","chars","codePoints","codePointArray","codePointNumber","push","graphemes","separator","limit","BYRE_ORDER_MARK","hasSubstringAtIndex","indexOffset","parseTagList","tags","tagsList","REGEXP_TAG_LIST","parseTagName","tagContent","state","STATE_START_TAG","tagName","STATE_DONE","char","REGEXP_WHITESPACE","STATE_NON_WHITESPACE","allowableTags","allowableTagsString","replacementString","hasAllowableTags","hasSubstring","STATE_OUTPUT","depth","output","quote","advance","STATE_HTML","STATE_EXCLAMATION","STATE_COMMENT","noConflict","this","globalObject","v","previousV","ChainWrapper","explicitChain","_wrappedValue","_explicitChain","makeFunctionChainable","functionInstance","args","chain","Voca","diacriticalMark","base","lowerCaseLetter","upperCaseLetter","prototype","increment","paddingCharacter","self","Function","valueOf","toJSON","thru","changer","functions","name"],"mappings":"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"}