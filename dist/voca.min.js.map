{"version":3,"file":"voca.min.js","sources":["../src/helper/object/is_nil.js","../src/helper/boolean/coerce_to_boolean.js","../src/query/is_string.js","../src/helper/string/coerce_to_string.js","../src/case/capitalize.js","../src/case/lower_case.js","../src/helper/reg_exp/const.js","../src/helper/reg_exp/const_extended.js","../src/helper/undefined/nil_default.js","../src/helper/string/to_string.js","../src/split/words.js","../src/case/camel_case.js","../src/case/kebab_case.js","../src/case/swap_case.js","../src/helper/number/clip_number.js","../src/helper/number/const.js","../src/helper/number/to_integer.js","../src/chop/truncate.js","../src/helper/string/surrogate_pair.js","../src/helper/number/coerce_to_number.js","../src/helper/number/nan_default.js","../src/chop/code_point_at.js","../src/count/count_where.js","../src/helper/format/replacement/index.js","../src/helper/format/const.js","../src/manipulate/repeat.js","../src/helper/string/build_padding.js","../src/manipulate/pad_left.js","../src/manipulate/pad_right.js","../src/helper/format/type_format/add_sign_to_formatted_number.js","../src/helper/format/type_format/float.js","../src/helper/format/type_format/integer_base.js","../src/helper/format/type_format/integer_decimal.js","../src/helper/format/type_format/string.js","../src/helper/format/replacement/compute.js","../src/helper/format/align_and_pad.js","../src/helper/format/conversion_specification.js","../src/helper/format/replacement/match.js","../src/helper/format/replacement/validate.js","../src/format/sprintf.js","../src/escape/escape_html.js","../src/escape/unescape_html.js","../src/helper/string/diacritics_map.js","../src/manipulate/latinise.js","../src/manipulate/tr.js","../src/query/includes.js","../src/manipulate/trim_left.js","../src/manipulate/trim_right.js","../src/manipulate/word_wrap.js","../src/query/is_alpha.js","../src/helper/strip/parse_tag_name.js","../src/helper/object/get_global.js","../src/util/no_conflict.js","../src/util/version.js","../src/functions.js","../src/case/decapitalize.js","../src/case/snake_case.js","../src/case/title_case.js","../src/case/upper_case.js","../src/count/count.js","../src/count/count_graphemes.js","../src/count/count_substrings.js","../src/count/count_words.js","../src/escape/escape_reg_exp.js","../src/format/vprintf.js","../src/index/index_of.js","../src/index/last_index_of.js","../src/index/search.js","../src/chop/char_at.js","../src/chop/first.js","../src/chop/grapheme_at.js","../src/chop/last.js","../src/chop/prune.js","../src/chop/slice.js","../src/chop/substr.js","../src/chop/substring.js","../src/manipulate/insert.js","../src/manipulate/pad.js","../src/manipulate/replace.js","../src/manipulate/replace_all.js","../src/manipulate/reverse.js","../src/manipulate/reverse_grapheme.js","../src/manipulate/slugify.js","../src/manipulate/splice.js","../src/manipulate/trim.js","../src/query/ends_with.js","../src/query/is_alpha_digit.js","../src/query/is_blank.js","../src/query/is_digit.js","../src/query/is_empty.js","../src/query/is_lower_case.js","../src/query/is_numeric.js","../src/query/is_upper_case.js","../src/query/matches.js","../src/query/starts_with.js","../src/split/chars.js","../src/split/code_points.js","../src/split/graphemes.js","../src/split/split.js","../src/strip/strip_bom.js","../src/strip/strip_tags.js","../src/helper/strip/parse_tag_list.js","../src/helper/string/has_substring_at_index.js","../src/chain/wrapper.js","../src/index.js","../src/chain/chain.js"],"sourcesContent":["/**\n * Checks if `value` is `null` or `undefined`\n *\n * @ignore\n * @function isNil\n * @param {*} value The object to check\n * @return {boolean} Returns `true` is `value` is `undefined` or `null`, `false` otherwise\n */\nexport default function isNil(value) {\n  return value === undefined || value === null;\n}\n","import isNil from 'helper/object/is_nil';\n\n/**\n * Converts the `value` to a boolean. If `value` is `undefined` or `null`, returns `defaultValue`.\n *\n * @ignore\n * @function toBoolean\n * @param {*} value The value to convert.\n * @param {boolean} [defaultValue=false] The default value.\n * @return {boolean} Returns the coercion to boolean.\n */\nexport default function coerceToBoolean(value, defaultValue = false) {\n  if (isNil(value)) {\n    return defaultValue;\n  }\n  return Boolean(value);\n}\n","/**\n * Checks whether `subject` is a string primitive type.\n *\n * @function isString\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} subject The value to verify.\n * @return {boolean} Returns `true` if `subject` is string primitive type or `false` otherwise.\n * @example\n * v.isString('vacation');\n * // => true\n *\n * v.isString(560);\n * // => false\n */\nexport default function isString(subject) {\n  return typeof subject === 'string';\n}\n","import isNil from 'helper/object/is_nil';\nimport isString from 'query/is_string';\n\n/**\n * Get the string representation of the `value`.\n * Converts the `value` to string.\n * If `value` is `null` or `undefined`, return `defaultValue`.\n *\n * @ignore\n * @function toString\n * @param {*} value             The value to convert.\n * @param {*} [defaultValue=''] The default value to return.\n * @return {string|null}        Returns the string representation of `value`. Returns `defaultValue` if `value` is\n *                              `null` or `undefined`.\n */\nexport default function coerceToString(value, defaultValue = '') {\n  if (isNil(value)) {\n    return defaultValue;\n  }\n  if (isString(value)) {\n    return value;\n  }\n  return String(value);\n}\n","import coerceToBoolean from 'helper/boolean/coerce_to_boolean';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the first character of `subject` to upper case. If `restToLower` is `true`, convert the rest of\n * `subject` to lower case.\n *\n * @function capitalize\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string}  [subject='']        The string to capitalize.\n * @param  {boolean} [restToLower=false] Convert the rest of `subject` to lower case.\n * @return {string}                      Returns the capitalized string.\n * @example\n * v.capitalize('apple');\n * // => 'Apple'\n *\n * v.capitalize('aPPle', true);\n * // => 'Apple'\n */\nexport default function capitalize(subject, restToLower) {\n  let subjectString = coerceToString(subject);\n  const restToLowerCaseBoolean = coerceToBoolean(restToLower);\n  if (subjectString === '') {\n    return '';\n  }\n  if (restToLowerCaseBoolean) {\n    subjectString = subjectString.toLowerCase();\n  }\n  return subjectString.substr(0, 1).toUpperCase() + subjectString.substr(1);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the `subject` to lower case.\n *\n * @function lowerCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to lower case.\n * @return {string}              Returns the lower case string.\n * @example\n * v.lowerCase('Green');\n * // => 'green'\n *\n * v.lowerCase('BLUE');\n * // => 'blue'\n */\nexport default function lowerCase(subject) {\n  const subjectString = coerceToString(subject, '');\n  return subjectString.toLowerCase();\n}\n","/**\n * A regular expression string matching digits\n *\n * @type {string}\n * @ignore\n */\nexport const digit = '\\\\d';\n\n/**\n * A regular expression string matching whitespace\n *\n * @type {string}\n * @ignore\n */\nexport const whitespace = '\\\\s\\\\uFEFF\\\\xA0';\n\n/**\n * A regular expression string matching high surrogate\n *\n * @type {string}\n * @ignore\n */\nexport const highSurrogate = '\\\\uD800-\\\\uDBFF';\n\n/**\n * A regular expression string matching low surrogate\n *\n * @type {string}\n * @ignore\n */\nexport const lowSurrogate = '\\\\uDC00-\\\\uDFFF';\n\n/**\n * A regular expression string matching diacritical mark\n *\n * @type {string}\n * @ignore\n */\nexport const diacriticalMark = '\\\\u0300-\\\\u036F\\\\u1AB0-\\\\u1AFF\\\\u1DC0-\\\\u1DFF\\\\u20D0-\\\\u20FF\\\\uFE20-\\\\uFE2F';\n\n/**\n * A regular expression to match the base character for a combining mark\n *\n * @type {string}\n * @ignore\n */\nexport const base =\n  '\\\\0-\\\\u02FF\\\\u0370-\\\\u1AAF\\\\u1B00-\\\\u1DBF\\\\u1E00-\\\\u20CF\\\\u2100-\\\\uD7FF\\\\uE000-\\\\uFE1F\\\\uFE30-\\\\uFFFF';\n\n/**\n * Regular expression to match combining marks\n *\n * @see http://unicode.org/faq/char_combmark.html\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_COMBINING_MARKS = new RegExp(\n  '([' +\n    base +\n    ']|[' +\n    highSurrogate +\n    '][' +\n    lowSurrogate +\n    ']|[' +\n    highSurrogate +\n    '](?![' +\n    lowSurrogate +\n    '])|(?:[^' +\n    highSurrogate +\n    ']|^)[' +\n    lowSurrogate +\n    '])([' +\n    diacriticalMark +\n    ']+)',\n  'g'\n);\n\n/**\n * Regular expression to match surrogate pairs\n *\n * @see http://www.unicode.org/faq/utf_bom.html#utf16-2\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_SURROGATE_PAIRS = new RegExp('([' + highSurrogate + '])([' + lowSurrogate + '])', 'g');\n\n/**\n * Regular expression to match a unicode character\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_UNICODE_CHARACTER = new RegExp(\n  '((?:[' +\n    base +\n    ']|[' +\n    highSurrogate +\n    '][' +\n    lowSurrogate +\n    ']|[' +\n    highSurrogate +\n    '](?![' +\n    lowSurrogate +\n    '])|(?:[^' +\n    highSurrogate +\n    ']|^)[' +\n    lowSurrogate +\n    '])(?:[' +\n    diacriticalMark +\n    ']+))|\\\n([' +\n    highSurrogate +\n    '][' +\n    lowSurrogate +\n    '])|\\\n([\\\\n\\\\r\\\\u2028\\\\u2029])|\\\n(.)',\n  'g'\n);\n\n/**\n * Regular expression to match whitespaces\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_WHITESPACE = new RegExp('[' + whitespace + ']');\n\n/**\n * Regular expression to match whitespaces from the left side\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_TRIM_LEFT = new RegExp('^[' + whitespace + ']+');\n\n/**\n * Regular expression to match whitespaces from the right side\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_TRIM_RIGHT = new RegExp('[' + whitespace + ']+$');\n\n/**\n * Regular expression to match digit characters\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_DIGIT = new RegExp('^' + digit + '+$');\n\n/**\n * Regular expression to match regular expression special characters\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_SPECIAL_CHARACTERS = /[-[\\]{}()*+!<=:?./\\\\^$|#,]/g;\n\n/**\n * Regular expression to match not latin characters\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_NON_LATIN = /[^A-Za-z0-9]/g;\n\n/**\n * Regular expression to match HTML special characters.\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_HTML_SPECIAL_CHARACTERS = /[<>&\"'`]/g;\n\n/**\n * Regular expression to match sprintf format string\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_CONVERSION_SPECIFICATION = /(%{1,2})(?:(\\d+)\\$)?(\\+)?([ 0]|'.{1})?(-)?(\\d+)?(?:\\.(\\d+))?([bcdiouxXeEfgGs])?/g;\n\n/**\n * Regular expression to match trailing zeros in a number\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_TRAILING_ZEROS = /\\.?0+$/g;\n\n/**\n * Regular expression to match flags from a regular expression.\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_FLAGS = /[gimuy]*$/;\n\n/**\n * Regular expression to match a list of tags.\n *\n * @see https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-name\n * @type {RegExp}\n * @ignore\n */\n\nexport const REGEXP_TAG_LIST = /<([A-Za-z0-9]+)>/g;\n","import { diacriticalMark, digit, whitespace } from 'helper/reg_exp/const';\n\n/**\n * A regular expression to match the General Punctuation Unicode block\n *\n * @type {string}\n * @ignore\n */\nconst generalPunctuationBlock = '\\\\u2000-\\\\u206F';\n\n/**\n * A regular expression to match non characters from from Basic Latin and Latin-1 Supplement Unicode blocks\n *\n * @type {string}\n * @ignore\n */\nconst nonCharacter = '\\\\x00-\\\\x2F\\\\x3A-\\\\x40\\\\x5B-\\\\x60\\\\x7b-\\\\xBF\\\\xD7\\\\xF7';\n\n/**\n * A regular expression to match the dingbat Unicode block\n *\n * @type {string}\n * @ignore\n */\nconst dingbatBlock = '\\\\u2700-\\\\u27BF';\n\n/**\n * A regular expression string that matches lower case letters: LATIN\n *\n * @type {string}\n * @ignore\n */\nconst lowerCaseLetter =\n  'a-z\\\\xB5\\\\xDF-\\\\xF6\\\\xF8-\\\\xFF\\\\u0101\\\\u0103\\\\u0105\\\\u0107\\\\u0109\\\\u010B\\\\u010D\\\\u010F\\\\u0111\\\\u0113\\\\u0115\\\\u0117\\\\u0119\\\\u011B\\\\u011D\\\\u011F\\\\u0121\\\\u0123\\\\u0125\\\\u0127\\\\u0129\\\\u012B\\\\u012D\\\\u012F\\\\u0131\\\\u0133\\\\u0135\\\\u0137\\\\u0138\\\\u013A\\\\u013C\\\\u013E\\\\u0140\\\\u0142\\\\u0144\\\\u0146\\\\u0148\\\\u0149\\\\u014B\\\\u014D\\\\u014F\\\\u0151\\\\u0153\\\\u0155\\\\u0157\\\\u0159\\\\u015B\\\\u015D\\\\u015F\\\\u0161\\\\u0163\\\\u0165\\\\u0167\\\\u0169\\\\u016B\\\\u016D\\\\u016F\\\\u0171\\\\u0173\\\\u0175\\\\u0177\\\\u017A\\\\u017C\\\\u017E-\\\\u0180\\\\u0183\\\\u0185\\\\u0188\\\\u018C\\\\u018D\\\\u0192\\\\u0195\\\\u0199-\\\\u019B\\\\u019E\\\\u01A1\\\\u01A3\\\\u01A5\\\\u01A8\\\\u01AA\\\\u01AB\\\\u01AD\\\\u01B0\\\\u01B4\\\\u01B6\\\\u01B9\\\\u01BA\\\\u01BD-\\\\u01BF\\\\u01C6\\\\u01C9\\\\u01CC\\\\u01CE\\\\u01D0\\\\u01D2\\\\u01D4\\\\u01D6\\\\u01D8\\\\u01DA\\\\u01DC\\\\u01DD\\\\u01DF\\\\u01E1\\\\u01E3\\\\u01E5\\\\u01E7\\\\u01E9\\\\u01EB\\\\u01ED\\\\u01EF\\\\u01F0\\\\u01F3\\\\u01F5\\\\u01F9\\\\u01FB\\\\u01FD\\\\u01FF\\\\u0201\\\\u0203\\\\u0205\\\\u0207\\\\u0209\\\\u020B\\\\u020D\\\\u020F\\\\u0211\\\\u0213\\\\u0215\\\\u0217\\\\u0219\\\\u021B\\\\u021D\\\\u021F\\\\u0221\\\\u0223\\\\u0225\\\\u0227\\\\u0229\\\\u022B\\\\u022D\\\\u022F\\\\u0231\\\\u0233-\\\\u0239\\\\u023C\\\\u023F\\\\u0240\\\\u0242\\\\u0247\\\\u0249\\\\u024B\\\\u024D\\\\u024F';\n\n/**\n * A regular expression string that matches upper case letters: LATIN\n *\n * @type {string}\n * @ignore\n */\nconst upperCaseLetter =\n  '\\\\x41-\\\\x5a\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\\\\u0100\\\\u0102\\\\u0104\\\\u0106\\\\u0108\\\\u010a\\\\u010c\\\\u010e\\\\u0110\\\\u0112\\\\u0114\\\\u0116\\\\u0118\\\\u011a\\\\u011c\\\\u011e\\\\u0120\\\\u0122\\\\u0124\\\\u0126\\\\u0128\\\\u012a\\\\u012c\\\\u012e\\\\u0130\\\\u0132\\\\u0134\\\\u0136\\\\u0139\\\\u013b\\\\u013d\\\\u013f\\\\u0141\\\\u0143\\\\u0145\\\\u0147\\\\u014a\\\\u014c\\\\u014e\\\\u0150\\\\u0152\\\\u0154\\\\u0156\\\\u0158\\\\u015a\\\\u015c\\\\u015e\\\\u0160\\\\u0162\\\\u0164\\\\u0166\\\\u0168\\\\u016a\\\\u016c\\\\u016e\\\\u0170\\\\u0172\\\\u0174\\\\u0176\\\\u0178\\\\u0179\\\\u017b\\\\u017d\\\\u0181\\\\u0182\\\\u0184\\\\u0186\\\\u0187\\\\u0189-\\\\u018b\\\\u018e-\\\\u0191\\\\u0193\\\\u0194\\\\u0196-\\\\u0198\\\\u019c\\\\u019d\\\\u019f\\\\u01a0\\\\u01a2\\\\u01a4\\\\u01a6\\\\u01a7\\\\u01a9\\\\u01ac\\\\u01ae\\\\u01af\\\\u01b1-\\\\u01b3\\\\u01b5\\\\u01b7\\\\u01b8\\\\u01bc\\\\u01c4\\\\u01c5\\\\u01c7\\\\u01c8\\\\u01ca\\\\u01cb\\\\u01cd\\\\u01cf\\\\u01d1\\\\u01d3\\\\u01d5\\\\u01d7\\\\u01d9\\\\u01db\\\\u01de\\\\u01e0\\\\u01e2\\\\u01e4\\\\u01e6\\\\u01e8\\\\u01ea\\\\u01ec\\\\u01ee\\\\u01f1\\\\u01f2\\\\u01f4\\\\u01f6-\\\\u01f8\\\\u01fa\\\\u01fc\\\\u01fe\\\\u0200\\\\u0202\\\\u0204\\\\u0206\\\\u0208\\\\u020a\\\\u020c\\\\u020e\\\\u0210\\\\u0212\\\\u0214\\\\u0216\\\\u0218\\\\u021a\\\\u021c\\\\u021e\\\\u0220\\\\u0222\\\\u0224\\\\u0226\\\\u0228\\\\u022a\\\\u022c\\\\u022e\\\\u0230\\\\u0232\\\\u023a\\\\u023b\\\\u023d\\\\u023e\\\\u0241\\\\u0243-\\\\u0246\\\\u0248\\\\u024a\\\\u024c\\\\u024e';\n\n/**\n * Regular expression to match Unicode words\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_WORD = new RegExp(\n  '(?:[' +\n    upperCaseLetter +\n    '][' +\n    diacriticalMark +\n    ']*)?(?:[' +\n    lowerCaseLetter +\n    '][' +\n    diacriticalMark +\n    ']*)+|\\\n(?:[' +\n    upperCaseLetter +\n    '][' +\n    diacriticalMark +\n    ']*)+(?![' +\n    lowerCaseLetter +\n    '])|\\\n[' +\n    digit +\n    ']+|\\\n[' +\n    dingbatBlock +\n    ']|\\\n[^' +\n    nonCharacter +\n    generalPunctuationBlock +\n    whitespace +\n    ']+',\n  'g'\n);\n\n/**\n * Regular expression to match words from Basic Latin and Latin-1 Supplement blocks\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_LATIN_WORD = /[A-Z\\xC0-\\xD6\\xD8-\\xDE]?[a-z\\xDF-\\xF6\\xF8-\\xFF]+|[A-Z\\xC0-\\xD6\\xD8-\\xDE]+(?![a-z\\xDF-\\xF6\\xF8-\\xFF])|\\d+/g;\n\n/**\n * Regular expression to match alpha characters\n *\n * @see http://stackoverflow.com/a/22075070/1894471\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_ALPHA = new RegExp('^(?:[' + lowerCaseLetter + upperCaseLetter + '][' + diacriticalMark + ']*)+$');\n\n/**\n * Regular expression to match alpha and digit characters\n *\n * @see http://stackoverflow.com/a/22075070/1894471\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_ALPHA_DIGIT = new RegExp(\n  '^((?:[' + lowerCaseLetter + upperCaseLetter + '][' + diacriticalMark + ']*)|[' + digit + '])+$'\n);\n\n/**\n * Regular expression to match Extended ASCII characters, i.e. the first 255\n *\n * @type {RegExp}\n * @ignore\n */\nexport const REGEXP_EXTENDED_ASCII = /^[\\x01-\\xFF]*$/;\n","/**\n * Verifies if `value` is `undefined` or `null` and returns `defaultValue`. In other case returns `value`.\n *\n * @ignore\n * @function nilDefault\n * @param {*} value The value to verify.\n * @param {*} defaultValue The default value.\n * @return {*} Returns `defaultValue` if `value` is `undefined` or `null`, otherwise `defaultValue`.\n */\nexport default function nilDefault(value, defaultValue) {\n  return value == null ? defaultValue : value;\n}\n","import isNil from 'helper/object/is_nil';\nimport isString from 'query/is_string';\n\n/**\n * Get the string representation of the `value`.\n * Converts the `value` to string.\n *\n * @ignore\n * @function toString\n * @param {*} value             The value to convert.\n * @return {string|null}        Returns the string representation of `value`.\n */\nexport default function toString(value) {\n  if (isNil(value)) {\n    return null;\n  }\n  if (isString(value)) {\n    return value;\n  }\n  return String(value);\n}\n","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport nilDefault from 'helper/undefined/nil_default';\nimport toString from 'helper/string/to_string';\n\n/**\n * Splits `subject` into an array of words.\n *\n * @function words\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into words.\n * @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\n * @return {Array} Returns the array of words.\n * @example\n * v.words('gravity can cross dimensions');\n * // => ['gravity', 'can', 'cross', 'dimensions']\n *\n * v.words('GravityCanCrossDimensions');\n * // => ['Gravity', 'Can', 'Cross', 'Dimensions']\n *\n * v.words('Gravity - can cross dimensions!');\n * // => ['Gravity', 'can', 'cross', 'dimensions']\n *\n * v.words('Earth gravity', /[^\\s]+/g);\n * // => ['Earth', 'gravity']\n */\nexport default function words(subject, pattern, flags) {\n  const subjectString = coerceToString(subject);\n  let patternRegExp;\n  if (isNil(pattern)) {\n    patternRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\n  } else if (pattern instanceof RegExp) {\n    patternRegExp = pattern;\n  } else {\n    const flagsString = toString(nilDefault(flags, ''));\n    patternRegExp = new RegExp(toString(pattern), flagsString);\n  }\n  return nilDefault(subjectString.match(patternRegExp), []);\n}\n","import capitalize from 'case/capitalize';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport lowerCase from 'case/lower_case';\nimport words from 'split/words';\n\n/**\n * Transforms the `word` into camel case chunk.\n *\n * @param  {string} word  The word string\n * @param  {number} index The index of the word in phrase.\n * @return {string}       The transformed word.\n * @ignore\n */\nfunction wordToCamel(word, index) {\n  return index === 0 ? lowerCase(word) : capitalize(word, true);\n}\n\n/**\n * Converts the `subject` to <a href=\"https://en.wikipedia.org/wiki/CamelCase\">camel case</a>.\n *\n * @function camelCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to camel case.\n * @return {string}              The camel case string.\n * @example\n * v.camelCase('bird flight');\n * // => 'birdFlight'\n *\n * v.camelCase('BirdFlight');\n * // => 'birdFlight'\n *\n * v.camelCase('-BIRD-FLIGHT-');\n * // => 'birdFlight'\n */\nexport default function camelCase(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return words(subjectString)\n    .map(wordToCamel)\n    .join('');\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport lowerCase from 'case/lower_case';\nimport words from 'split/words';\n\n/**\n * Converts the `subject` to <a href=\"https://en.wikipedia.org/wiki/Letter_case#cite_ref-13\">kebab case</a>,\n * also called <i>spinal case</i> or <i>lisp case</i>.\n *\n * @function kebabCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to kebab case.\n * @return {string}              Returns the kebab case string.\n * @example\n * v.kebabCase('goodbye blue sky');\n * // => 'goodbye-blue-sky'\n *\n * v.kebabCase('GoodbyeBlueSky');\n * // => 'goodbye-blue-sky'\n *\n * v.kebabCase('-Goodbye-Blue-Sky-');\n * // => 'goodbye-blue-sky'\n */\nexport default function kebabCase(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return words(subjectString)\n    .map(lowerCase)\n    .join('-');\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the uppercase alpha caracters of `subject` to lowercase and lowercase\n * characters to uppercase.\n *\n * @function swapCase\n * @static\n * @since 1.3.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to swap the case.\n * @return {string}              Returns the converted string.\n * @example\n * v.swapCase('League of Shadows');\n * // => 'lEAGUE OF sHADOWS'\n *\n * v.swapCase('2 Bees');\n * // => '2 bEES'\n */\nexport default function swapCase(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split('').reduce(swapAndConcat, '');\n}\n\nfunction swapAndConcat(swapped, character) {\n  const lowerCase = character.toLowerCase();\n  const upperCase = character.toUpperCase();\n  return swapped + (character === lowerCase ? upperCase : lowerCase);\n}\n","/**\n * Clip the number to interval `downLimit` to `upLimit`.\n *\n * @ignore\n * @function clipNumber\n * @param {number} value The number to clip\n * @param {number} downLimit The down limit\n * @param {number} upLimit The upper limit\n * @return {number} The clipped number\n */\nexport default function clipNumber(value, downLimit, upLimit) {\n  if (value <= downLimit) {\n    return downLimit;\n  }\n  if (value >= upLimit) {\n    return upLimit;\n  }\n  return value;\n}\n","/**\n * Max save integer value\n *\n * @ignore\n * @type {number}\n */\nexport const MAX_SAFE_INTEGER = 0x1fffffffffffff;\n","import { MAX_SAFE_INTEGER } from 'helper/number/const';\n\n/**\n * Transforms `value` to an integer.\n *\n * @ignore\n * @function toInteger\n * @param {number} value The number to transform.\n * @returns {number} Returns the transformed integer.\n */\nexport default function toInteger(value) {\n  if (value === Infinity) {\n    return MAX_SAFE_INTEGER;\n  }\n  if (value === -Infinity) {\n    return -MAX_SAFE_INTEGER;\n  }\n  return ~~value;\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Truncates `subject` to a new `length`.\n *\n * @function truncate\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to truncate.\n * @param  {int}    length       The length to truncate the string.\n * @param  {string} [end='...']  The string to be added at the end.\n * @return {string}              Returns the truncated string.\n * @example\n * v.truncate('Once upon a time', 7);\n * // => 'Once...'\n *\n * v.truncate('Good day, Little Red Riding Hood', 14, ' (...)');\n * // => 'Good day (...)'\n *\n * v.truncate('Once upon', 10);\n * // => 'Once upon'\n */\nexport default function truncate(subject, length, end) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const endString = coerceToString(end, '...');\n  if (lengthInt >= subjectString.length) {\n    return subjectString;\n  }\n  return subjectString.substr(0, length - endString.length) + endString;\n}\n","const HIGH_SURROGATE_START = 0xd800;\nconst HIGH_SURROGATE_END = 0xdbff;\nconst LOW_SURROGATE_START = 0xdc00;\nconst LOW_SURROGATE_END = 0xdfff;\n\n/**\n * Checks if `codePoint` is a high-surrogate number from range 0xD800 to 0xDBFF.\n *\n * @ignore\n * @param {number} codePoint The code point number to be verified\n * @return {boolean} Returns a boolean whether `codePoint` is a high-surrogate number.\n */\nexport function isHighSurrogate(codePoint) {\n  return codePoint >= HIGH_SURROGATE_START && codePoint <= HIGH_SURROGATE_END;\n}\n\n/**\n * Checks if `codePoint` is a low-surrogate number from range 0xDC00 to 0xDFFF.\n *\n * @ignore\n * @param {number} codePoint The code point number to be verified\n * @return {boolean} Returns a boolean whether `codePoint` is a low-surrogate number.\n */\nexport function isLowSurrogate(codePoint) {\n  return codePoint >= LOW_SURROGATE_START && codePoint <= LOW_SURROGATE_END;\n}\n\n/**\n * Get the astral code point number based on surrogate pair numbers.\n *\n * @ignore\n * @param {number} highSurrogate The high-surrogate code point number.\n * @param {number} lowSurrogate The low-surrogate code point number.\n * @return {number} Returns the astral symbol number.\n */\nexport function getAstralNumberFromSurrogatePair(highSurrogate, lowSurrogate) {\n  return (highSurrogate - HIGH_SURROGATE_START) * 0x400 + lowSurrogate - LOW_SURROGATE_START + 0x10000;\n}\n","import isNil from 'helper/object/is_nil';\n\n/**\n * Get the number representation of the `value`.\n * Converts the `value` to number.\n * If `value` is `null` or `undefined`, return `defaultValue`.\n *\n * @ignore\n * @function toString\n * @param {*} value             The value to convert.\n * @param {*} [defaultValue=''] The default value to return.\n * @return {number|null}        Returns the number representation of `value`. Returns `defaultValue` if `value` is\n *                              `null` or `undefined`.\n */\nexport default function coerceToNumber(value, defaultValue = 0) {\n  if (isNil(value)) {\n    return defaultValue;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return Number(value);\n}\n","/**\n * If `value` is `NaN`, return `defaultValue`. In other case returns `value`.\n *\n * @ignore\n * @function nanDefault\n * @param {*} value The value to verify.\n * @param {*} defaultValue The default value.\n * @return {*} Returns `defaultValue` if `value` is `NaN`, otherwise `defaultValue`.\n */\nexport default function nanDefault(value, defaultValue) {\n  return value !== value ? defaultValue : value;\n}\n","import { getAstralNumberFromSurrogatePair, isHighSurrogate, isLowSurrogate } from 'helper/string/surrogate_pair';\nimport coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport nanDefault from 'helper/number/nan_default';\n\n/**\n * Get the Unicode code point value of the character at `position`. <br/>\n * If a valid UTF-16 <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">\n * surrogate pair</a> starts at `position`, the\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#astralplanes\">astral code point</a>\n * value at `position` is returned.\n *\n * @function codePointAt\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {number} position The position to get the code point number.\n * @return {number} Returns a non-negative number less than or equal to `0x10FFFF`.\n * @example\n * v.codePointAt('rain', 1);\n * // => 97, or 0x0061\n *\n * v.codePointAt('\\uD83D\\uDE00 is smile', 0); // or 'ðŸ˜€ is smile'\n * // => 128512, or 0x1F600\n */\nexport default function codePointAt(subject, position) {\n  const subjectString = coerceToString(subject);\n  const subjectStringLength = subjectString.length;\n  let positionNumber = coerceToNumber(position);\n  positionNumber = nanDefault(positionNumber, 0);\n  if (positionNumber < 0 || positionNumber >= subjectStringLength) {\n    return undefined;\n  }\n  const firstCodePoint = subjectString.charCodeAt(positionNumber);\n  let secondCodePoint;\n  if (isHighSurrogate(firstCodePoint) && subjectStringLength > positionNumber + 1) {\n    secondCodePoint = subjectString.charCodeAt(positionNumber + 1);\n    if (isLowSurrogate(secondCodePoint)) {\n      return getAstralNumberFromSurrogatePair(firstCodePoint, secondCodePoint);\n    }\n  }\n  return firstCodePoint;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\nconst reduce = Array.prototype.reduce;\n\n/**\n * Counts the characters in `subject` for which `predicate` returns truthy.\n *\n * @function  countWhere\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string}   [subject=''] The string to count characters.\n * @param  {Function} predicate    The predicate function invoked on each character with parameters `(character, index, string)`.\n * @param  {Object}   [context]    The context to invoke the `predicate`.\n * @return {number}                Returns the number of characters for which `predicate` returns truthy.\n * @example\n * v.countWhere('hola!', v.isAlpha);\n * // => 4\n *\n * v.countWhere('2022', function(character, index, str) {\n *   return character === '2';\n * });\n * // => 3\n */\nexport default function countWhere(subject, predicate, context) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '' || typeof predicate !== 'function') {\n    return 0;\n  }\n  const predicateWithContext = predicate.bind(context);\n  return reduce.call(\n    subjectString,\n    function(countTruthy, character, index) {\n      return predicateWithContext(character, index, subjectString) ? countTruthy + 1 : countTruthy;\n    },\n    0\n  );\n}\n","import isNil from 'helper/object/is_nil';\n\n/**\n * The current index.\n *\n * @ignore\n * @name ReplacementIndex#index\n * @type {number}\n * @return {ReplacementIndex} ReplacementIndex instance.\n */\nfunction ReplacementIndex() {\n  this.index = 0;\n}\n\n/**\n * Increment the current index.\n *\n * @ignore\n * @return {undefined}\n */\nReplacementIndex.prototype.increment = function() {\n  this.index++;\n};\n\n/**\n * Increment the current index by position.\n *\n * @ignore\n * @param {number} [position] The replacement position.\n * @return {undefined}\n */\nReplacementIndex.prototype.incrementOnEmptyPosition = function(position) {\n  if (isNil(position)) {\n    this.increment();\n  }\n};\n\n/**\n * Get the replacement index by position.\n *\n * @ignore\n * @param {number} [position] The replacement position.\n * @return {number} The replacement index.\n */\nReplacementIndex.prototype.getIndexByPosition = function(position) {\n  return isNil(position) ? this.index : position - 1;\n};\n\nexport default ReplacementIndex;\n","// Type specifiers\nexport const TYPE_INTEGER = 'i';\nexport const TYPE_INTEGER_BINARY = 'b';\nexport const TYPE_INTEGER_ASCII_CHARACTER = 'c';\nexport const TYPE_INTEGER_DECIMAL = 'd';\nexport const TYPE_INTEGER_OCTAL = 'o';\nexport const TYPE_INTEGER_UNSIGNED_DECIMAL = 'u';\nexport const TYPE_INTEGER_HEXADECIMAL = 'x';\nexport const TYPE_INTEGER_HEXADECIMAL_UPPERCASE = 'X';\nexport const TYPE_FLOAT_SCIENTIFIC = 'e';\nexport const TYPE_FLOAT_SCIENTIFIC_UPPERCASE = 'E';\nexport const TYPE_FLOAT = 'f';\nexport const TYPE_FLOAT_SHORT = 'g';\nexport const TYPE_FLOAT_SHORT_UPPERCASE = 'G';\nexport const TYPE_STRING = 's';\n\n// Simple literals\nexport const LITERAL_PERCENT = '%';\nexport const LITERAL_SINGLE_QUOTE = \"'\";\nexport const LITERAL_PLUS = '+';\nexport const LITERAL_MINUS = '-';\nexport const LITERAL_PERCENT_SPECIFIER = '%%';\n\n// Radix constants to format numbers\nexport const RADIX_BINARY = 2;\nexport const RADIX_OCTAL = 8;\nexport const RADIX_DECIMAL = 10;\nexport const RADIX_HEXADECIMAL = 16;\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Repeats the `subject` number of `times`.\n *\n * @function repeat\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to repeat.\n * @param {number} [times=1] The number of times to repeat.\n * @return {string} Returns the repeated string.\n * @example\n * v.repeat('w', 3);\n * // => 'www'\n *\n * v.repeat('world', 0);\n * // => ''\n */\nexport default function repeat(subject, times) {\n  let subjectString = coerceToString(subject);\n  let timesInt = isNil(times) ? 1 : clipNumber(toInteger(times), 0, MAX_SAFE_INTEGER);\n  let repeatString = '';\n  while (timesInt) {\n    if (timesInt & 1) {\n      repeatString += subjectString;\n    }\n    if (timesInt > 1) {\n      subjectString += subjectString;\n    }\n    timesInt >>= 1;\n  }\n  return repeatString;\n}\n","import repeat from 'manipulate/repeat';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Creates the padding string.\n *\n * @ignore\n * @param {string} padCharacters The characters to create padding string.\n * @param {number} length The padding string length.\n * @return {string} The padding string.\n */\nexport default function buildPadding(padCharacters, length) {\n  const padStringRepeat = toInteger(length / padCharacters.length);\n  const padStringRest = length % padCharacters.length;\n  return repeat(padCharacters, padStringRepeat + padStringRest).substr(0, length);\n}\n","import buildPadding from 'helper/string/build_padding';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Pads `subject` from left to a new `length`.\n *\n * @function padLeft\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to pad.\n * @param {int} [length=0] The length to left pad the string. No changes are made if `length` is less than `subject.length`.\n * @param {string} [pad=' '] The string to be used for padding.\n * @return {string} Returns the left padded string.\n * @example\n * v.padLeft('dog', 5);\n * // => '  dog'\n *\n * v.padLeft('bird', 6, '-');\n * // => '--bird'\n *\n * v.padLeft('cat', 6, '-=');\n * // => '-=-cat'\n */\nexport default function padLeft(subject, length, pad) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const padString = coerceToString(pad, ' ');\n  if (lengthInt <= subjectString.length) {\n    return subjectString;\n  }\n  return buildPadding(padString, lengthInt - subjectString.length) + subjectString;\n}\n","import buildPadding from 'helper/string/build_padding';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Pads `subject` from right to a new `length`.\n *\n * @function padRight\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to pad.\n * @param {int} [length=0] The length to right pad the string. No changes are made if `length` is less than `subject.length`.\n * @param {string} [pad=' '] The string to be used for padding.\n * @return {string} Returns the right padded string.\n * @example\n * v.padRight('dog', 5);\n * // => 'dog  '\n *\n * v.padRight('bird', 6, '-');\n * // => 'bird--'\n *\n * v.padRight('cat', 6, '-=');\n * // => 'cat-=-'\n */\nexport default function padRight(subject, length, pad) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const padString = coerceToString(pad, ' ');\n  if (lengthInt <= subjectString.length) {\n    return subjectString;\n  }\n  return subjectString + buildPadding(padString, lengthInt - subjectString.length);\n}\n","import { LITERAL_PLUS } from 'helper/format/const';\n\n/**\n * Add sign to the formatted number.\n *\n * @ignore\n * @name addSignToFormattedNumber\n * @param  {number} replacementNumber The number to be replaced.\n * @param  {string} formattedReplacement The formatted version of number.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted number string with a sign.\n */\nexport default function addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion) {\n  if (conversion.signSpecifier === LITERAL_PLUS && replacementNumber >= 0) {\n    formattedReplacement = LITERAL_PLUS + formattedReplacement;\n  }\n  return formattedReplacement;\n}\n","import {\n  TYPE_FLOAT,\n  TYPE_FLOAT_SCIENTIFIC,\n  TYPE_FLOAT_SCIENTIFIC_UPPERCASE,\n  TYPE_FLOAT_SHORT,\n  TYPE_FLOAT_SHORT_UPPERCASE,\n} from 'helper/format/const';\nimport addSignToFormattedNumber from 'helper/format/type_format/add_sign_to_formatted_number';\nimport coerceToNumber from 'helper/number/coerce_to_number';\nimport { REGEXP_TRAILING_ZEROS } from 'helper/reg_exp/const';\nimport toString from 'helper/string/coerce_to_string';\n\n/**\n * Formats a float type according to specifiers.\n *\n * @ignore\n * @param  {string} replacement The string to be formatted.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\n\nexport default function float(replacement, conversion) {\n  let replacementNumber = parseFloat(replacement);\n  let formattedReplacement;\n  if (isNaN(replacementNumber)) {\n    replacementNumber = 0;\n  }\n  const precision = coerceToNumber(conversion.precision, 6);\n  switch (conversion.typeSpecifier) {\n    case TYPE_FLOAT:\n      formattedReplacement = replacementNumber.toFixed(precision);\n      break;\n    case TYPE_FLOAT_SCIENTIFIC:\n      formattedReplacement = replacementNumber.toExponential(precision);\n      break;\n    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:\n      formattedReplacement = replacementNumber.toExponential(precision).toUpperCase();\n      break;\n    case TYPE_FLOAT_SHORT:\n    case TYPE_FLOAT_SHORT_UPPERCASE:\n      formattedReplacement = formatFloatAsShort(replacementNumber, precision, conversion);\n      break;\n  }\n  formattedReplacement = addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion);\n  return toString(formattedReplacement);\n}\n\n/**\n * Formats the short float.\n *\n * @ignore\n * @param  {number} replacementNumber The number to format.\n * @param  {number} precision The precision to format the float.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string}  Returns the formatted short float.\n */\nfunction formatFloatAsShort(replacementNumber, precision, conversion) {\n  if (replacementNumber === 0) {\n    return '0';\n  }\n  const nonZeroPrecision = precision === 0 ? 1 : precision;\n  let formattedReplacement = replacementNumber.toPrecision(nonZeroPrecision).replace(REGEXP_TRAILING_ZEROS, '');\n  if (conversion.typeSpecifier === TYPE_FLOAT_SHORT_UPPERCASE) {\n    formattedReplacement = formattedReplacement.toUpperCase();\n  }\n  return formattedReplacement;\n}\n","import {\n  RADIX_BINARY,\n  RADIX_HEXADECIMAL,\n  RADIX_OCTAL,\n  TYPE_INTEGER_ASCII_CHARACTER,\n  TYPE_INTEGER_BINARY,\n  TYPE_INTEGER_HEXADECIMAL,\n  TYPE_INTEGER_HEXADECIMAL_UPPERCASE,\n  TYPE_INTEGER_OCTAL,\n} from 'helper/format/const';\nimport toString from 'helper/string/coerce_to_string';\n\n/**\n * Formats an integer type according to specifiers.\n *\n * @ignore\n * @param  {string} replacement The string to be formatted.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\n\nexport default function integerBase(replacement, conversion) {\n  let integer = parseInt(replacement);\n  if (isNaN(integer)) {\n    integer = 0;\n  }\n  integer = integer >>> 0;\n  switch (conversion.typeSpecifier) {\n    case TYPE_INTEGER_ASCII_CHARACTER:\n      integer = String.fromCharCode(integer);\n      break;\n    case TYPE_INTEGER_BINARY:\n      integer = integer.toString(RADIX_BINARY);\n      break;\n    case TYPE_INTEGER_OCTAL:\n      integer = integer.toString(RADIX_OCTAL);\n      break;\n    case TYPE_INTEGER_HEXADECIMAL:\n      integer = integer.toString(RADIX_HEXADECIMAL);\n      break;\n    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:\n      integer = integer.toString(RADIX_HEXADECIMAL).toUpperCase();\n      break;\n  }\n  return toString(integer);\n}\n","import addSignToFormattedNumber from 'helper/format/type_format/add_sign_to_formatted_number';\nimport toString from 'helper/string/to_string';\n\n/**\n * Formats a decimal integer type according to specifiers.\n *\n * @ignore\n * @param  {string} replacement The string to be formatted.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\n\nexport default function integerDecimal(replacement, conversion) {\n  let integer = parseInt(replacement);\n  if (isNaN(integer)) {\n    integer = 0;\n  }\n  return addSignToFormattedNumber(integer, toString(integer), conversion);\n}\n","import isNil from 'helper/object/is_nil';\nimport truncate from 'chop/truncate';\n\n/**\n * Formats a string type according to specifiers.\n *\n * @ignore\n * @param {string} replacement The string to be formatted.\n * @param {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the formatted string.\n */\nexport default function stringFormat(replacement, conversion) {\n  let formattedReplacement = replacement;\n  const precision = conversion.precision;\n  if (!isNil(precision) && formattedReplacement.length > precision) {\n    formattedReplacement = truncate(formattedReplacement, precision, '');\n  }\n  return formattedReplacement;\n}\n","import {\n  TYPE_FLOAT,\n  TYPE_FLOAT_SCIENTIFIC,\n  TYPE_FLOAT_SCIENTIFIC_UPPERCASE,\n  TYPE_FLOAT_SHORT,\n  TYPE_FLOAT_SHORT_UPPERCASE,\n  TYPE_INTEGER,\n  TYPE_INTEGER_ASCII_CHARACTER,\n  TYPE_INTEGER_BINARY,\n  TYPE_INTEGER_DECIMAL,\n  TYPE_INTEGER_HEXADECIMAL,\n  TYPE_INTEGER_HEXADECIMAL_UPPERCASE,\n  TYPE_INTEGER_OCTAL,\n  TYPE_INTEGER_UNSIGNED_DECIMAL,\n  TYPE_STRING,\n} from 'helper/format/const';\nimport alignAndPad from 'helper/format/align_and_pad';\nimport formatFloat from 'helper/format/type_format/float';\nimport formatIntegerBase from 'helper/format/type_format/integer_base';\nimport formatIntegerDecimal from 'helper/format/type_format/integer_decimal';\nimport formatString from 'helper/format/type_format/string';\n\n/**\n * Returns the computed string based on format specifiers.\n *\n * @ignore\n * @name computeReplacement\n * @param {string} replacement The replacement value.\n * @param {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the computed string.\n */\nexport default function compute(replacement, conversion) {\n  let formatFunction;\n  switch (conversion.typeSpecifier) {\n    case TYPE_STRING:\n      formatFunction = formatString;\n      break;\n    case TYPE_INTEGER_DECIMAL:\n    case TYPE_INTEGER:\n      formatFunction = formatIntegerDecimal;\n      break;\n    case TYPE_INTEGER_ASCII_CHARACTER:\n    case TYPE_INTEGER_BINARY:\n    case TYPE_INTEGER_OCTAL:\n    case TYPE_INTEGER_HEXADECIMAL:\n    case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:\n    case TYPE_INTEGER_UNSIGNED_DECIMAL:\n      formatFunction = formatIntegerBase;\n      break;\n    case TYPE_FLOAT:\n    case TYPE_FLOAT_SCIENTIFIC:\n    case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:\n    case TYPE_FLOAT_SHORT:\n    case TYPE_FLOAT_SHORT_UPPERCASE:\n      formatFunction = formatFloat;\n      break;\n  }\n  const formattedString = formatFunction(replacement, conversion);\n  return alignAndPad(formattedString, conversion);\n}\n","import isNil from 'helper/object/is_nil';\nimport { LITERAL_MINUS } from 'helper/format/const';\nimport padLeft from 'manipulate/pad_left';\nimport padRight from 'manipulate/pad_right';\n\n/**\n * Aligns and pads `subject` string.\n *\n * @ignore\n * @param {string} subject The subject string.\n * @param {ConversionSpecification} conversion The conversion specification object.\n * @return {string} Returns the aligned and padded string.\n */\nexport default function alignAndPad(subject, conversion) {\n  const width = conversion.width;\n  if (isNil(width) || subject.length >= width) {\n    return subject;\n  }\n  const padType = conversion.alignmentSpecifier === LITERAL_MINUS ? padRight : padLeft;\n  return padType(subject, width, conversion.getPaddingCharacter());\n}\n","import { LITERAL_PERCENT_SPECIFIER, LITERAL_SINGLE_QUOTE } from 'helper/format/const';\nimport nilDefault from 'helper/undefined/nil_default';\n\n/**\n * Construct the new conversion specification object.\n *\n * @ignore\n * @param {Object} properties An object with properties to initialize.\n * @return {ConversionSpecification} ConversionSpecification instance.\n */\nfunction ConversionSpecification(properties) {\n  /**\n   * The percent characters from conversion specification.\n   *\n   * @ignore\n   * @name ConversionSpecification#percent\n   * @type {string}\n   */\n  this.percent = properties.percent;\n\n  /**\n   *  The sign specifier to force a sign to be used on a number.\n   *\n   * @ignore\n   * @name ConversionSpecification#signSpecifier\n   * @type {string}\n   */\n  this.signSpecifier = properties.signSpecifier;\n\n  /**\n   * The padding specifier that says what padding character will be used.\n   *\n   * @ignore\n   * @name ConversionSpecification#paddingSpecifier\n   * @type {string}\n   */\n  this.paddingSpecifier = properties.paddingSpecifier;\n\n  /**\n   * The alignment specifier that says if the result should be left-justified or right-justified.\n   *\n   * @ignore\n   * @name ConversionSpecification#alignmentSpecifier\n   * @type {string}\n   */\n  this.alignmentSpecifier = properties.alignmentSpecifier;\n\n  /**\n   * The width specifier how many characters this conversion should result in.\n   *\n   * @ignore\n   * @name ConversionSpecification#width\n   * @type {number}\n   */\n  this.width = properties.width;\n\n  /**\n   * The precision specifier says how many decimal digits should be displayed for floating-point numbers.\n   *\n   * @ignore\n   * @name ConversionSpecification#precision\n   * @type {number}\n   */\n  this.precision = properties.precision;\n\n  /**\n   * The type specifier says what type the argument data should be treated as.\n   *\n   * @ignore\n   * @name ConversionSpecification#typeSpecifier\n   * @type {string}\n   */\n  this.typeSpecifier = properties.typeSpecifier;\n}\n\n/**\n * Check if the conversion specification is a percent literal \"%%\".\n *\n * @ignore\n * @return {boolean} Returns true if the conversion is a percent literal, false otherwise.\n */\nConversionSpecification.prototype.isPercentLiteral = function() {\n  return LITERAL_PERCENT_SPECIFIER === this.percent;\n};\n\n/**\n * Get the padding character from padding specifier.\n *\n * @ignore\n * @returns {string} Returns the padding character.\n */\nConversionSpecification.prototype.getPaddingCharacter = function() {\n  let paddingCharacter = nilDefault(this.paddingSpecifier, ' ');\n  if (paddingCharacter.length === 2 && paddingCharacter[0] === LITERAL_SINGLE_QUOTE) {\n    paddingCharacter = paddingCharacter[1];\n  }\n  return paddingCharacter;\n};\n\nexport default ConversionSpecification;\n","import coerceToNumber from 'helper/number/coerce_to_number';\nimport computeReplacement from 'helper/format/replacement/compute';\nimport ConversionSpecification from 'helper/format/conversion_specification';\nimport validateReplacement from 'helper/format/replacement/validate';\n\n/**\n * Return the replacement for regular expression match of the conversion specification.\n *\n * @ignore\n * @name matchReplacement\n * @param {ReplacementIndex} replacementIndex The replacement index object.\n * @param {string[]} replacements The array of replacements.\n * @param {string} conversionSpecification The conversion specification.\n * @param {string} percent The percent characters from conversion specification.\n * @param {string} position The position to insert the replacement.\n * @param {string} signSpecifier The sign specifier to force a sign to be used on a number.\n * @param {string} paddingSpecifier The padding specifier that says what padding character will be used.\n * @param {string} alignmentSpecifier The alignment specifier that says if the result should be left-justified or right-justified.\n * @param {string} widthSpecifier The width specifier how many characters this conversion should result in.\n * @param {string} precisionSpecifier The precision specifier says how many decimal digits should be displayed for floating-point numbers.\n * @param {string} typeSpecifier The type specifier says what type the argument data should be treated as.\n * @return {string} Returns the computed replacement.\n */\nexport default function match(\n  replacementIndex,\n  replacements,\n  conversionSpecification,\n  percent,\n  position,\n  signSpecifier,\n  paddingSpecifier,\n  alignmentSpecifier,\n  widthSpecifier,\n  precisionSpecifier,\n  typeSpecifier\n) {\n  const conversion = new ConversionSpecification({\n    percent,\n    signSpecifier,\n    paddingSpecifier,\n    alignmentSpecifier,\n    width: coerceToNumber(widthSpecifier, null),\n    precision: coerceToNumber(precisionSpecifier, null),\n    typeSpecifier,\n  });\n  if (conversion.isPercentLiteral()) {\n    return conversionSpecification.slice(1);\n  }\n  const actualReplacementIndex = replacementIndex.getIndexByPosition(position);\n  replacementIndex.incrementOnEmptyPosition(position);\n  validateReplacement(actualReplacementIndex, replacements.length, conversion);\n  return computeReplacement(replacements[actualReplacementIndex], conversion);\n}\n","import isNil from 'helper/object/is_nil';\n\n/**\n * Validates the specifier type and replacement position.\n *\n * @ignore\n * @throws {Error} Throws an exception on insufficient arguments or unknown specifier.\n * @param  {number} index The index of the matched specifier.\n * @param  {number} replacementsLength The number of replacements.\n * @param  {ConversionSpecification} conversion The conversion specification object.\n * @return {undefined}\n */\nexport default function validate(index, replacementsLength, conversion) {\n  if (isNil(conversion.typeSpecifier)) {\n    throw new Error('sprintf(): Unknown type specifier');\n  }\n  if (index > replacementsLength - 1) {\n    throw new Error('sprintf(): Too few arguments');\n  }\n  if (index < 0) {\n    throw new Error('sprintf(): Argument number must be greater than zero');\n  }\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_CONVERSION_SPECIFICATION } from 'helper/reg_exp/const';\nimport ReplacementIndex from 'helper/format/replacement/index.js';\nimport replacementMatch from 'helper/format/replacement/match';\n\n/**\n * Produces a string according to `format`.\n *\n * <div id=\"sprintf-format\" class=\"smaller\">\n * `format` string is composed of zero or more directives: ordinary characters (not <code>%</code>), which are  copied  unchanged\n * to  the  output string and <i>conversion specifications</i>, each of which results in fetching zero or more subsequent\n * arguments. <br/> <br/>\n *\n * Each <b>conversion specification</b> is introduced by the character <code>%</code>, and ends with a <b>conversion\n * specifier</b>. In between there may be (in this order) zero or more <b>flags</b>, an optional <b>minimum field width</b>\n * and an optional <b>precision</b>.<br/>\n * The syntax is: <b>ConversionSpecification</b> = <b>\"%\"</b> { <b>Flags</b> }\n * [ <b>MinimumFieldWidth</b> ] [ <b>Precision</b> ] <b>ConversionSpecifier</b>, where curly braces { } denote repetition\n * and square brackets [ ] optionality. <br/><br/>\n *\n * By default, the arguments are used in the given order.<br/>\n * For argument numbering and swapping, `%m$` (where `m` is a number indicating the argument order)\n * is used instead of `%` to specify explicitly which argument is taken. For instance `%1$s` fetches the 1st argument,\n * `%2$s` the 2nd and so on, no matter what position  the conversion specification has in `format`.\n * <br/><br/>\n *\n * <b>The flags</b><br/>\n * The character <code>%</code> is followed by zero or more of the following flags:<br/>\n * <table class=\"light-params\">\n *   <tr>\n *     <td><code>+</code></td>\n *     <td>\n *       A  sign (<code>+</code> or <code>-</code>) should always be placed before a number produced by a\n *       signed conversion. By default a sign is used only for negative numbers.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td><code>0</code></td>\n *     <td>The value should be zero padded.</td>\n *   </tr>\n *   <tr>\n *     <td><code>&blank;</code></td>\n *     <td>(a space) The value should be space padded.</td>\n *   </tr>\n *   <tr>\n *    <td><code>'</code></td>\n *    <td>Indicates alternate padding character, specified by prefixing it with a single quote <code>'</code>.</td>\n *   </tr>\n *   <tr>\n *     <td><code>-</code></td>\n *     <td>The converted value is to be left adjusted on the field boundary (the default is right justification).</td>\n *   </tr>\n * </table>\n *\n * <b>The minimum field width</b><br/>\n * An  optional decimal digit string (with nonzero first digit) specifying a minimum field width.  If the converted\n * value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the\n * left-adjustment flag has been given).<br/><br/>\n *\n * <b>The precision</b><br/>\n * An optional precision, in the form of a period `.` followed by an optional decimal digit string.<br/>\n * This gives the number of digits to appear after the radix character for `e`, `E`, `f` and `F` conversions, the\n * maximum number of significant digits for `g` and `G` conversions or the maximum number of characters to be printed\n * from a string for `s` conversion.<br/><br/>\n *\n * <b>The conversion specifier</b><br/>\n * A specifier that mentions what type the argument should be treated as:\n *\n * <table class=\"light-params\">\n *   <tr>\n *     <td>`s`</td>\n *     <td>The string argument is treated as and presented as a string.</td>\n *   </tr>\n *   <tr>\n *     <td>`d` `i`</td>\n *     <td>The integer argument is converted to signed decimal notation.</td>\n *   </tr>\n *   <tr>\n *     <td>`b`</td>\n *     <td>The unsigned integer argument is converted to unsigned binary.</td>\n *   </tr>\n *   <tr>\n *     <td>`c`</td>\n *     <td>The unsigned integer argument is converted to an ASCII character with that number.</td>\n *   </tr>\n *   <tr>\n *     <td>`o`</td>\n *     <td>The unsigned integer argument is converted to unsigned octal.</td>\n *   </tr>\n *   <tr>\n *     <td>`u`</td>\n *     <td>The unsigned integer argument is converted to unsigned decimal.</td>\n *   </tr>\n *   <tr>\n *     <td>`x` `X`</td>\n *     <td>The unsigned integer argument is converted to unsigned hexadecimal. The letters `abcdef` are used for `x`\n *     conversions; the letters `ABCDEF` are used for `X` conversions.</td>\n *   </tr>\n *   <tr>\n *     <td>`f`</td>\n *     <td>\n *      The float argument is rounded and converted to decimal notation in the style `[-]ddd.ddd`, where the number of\n *      digits after the decimal-point character is equal to the precision specification. If the precision is missing,\n *      it is taken as 6; if the precision is explicitly zero, no decimal-point character appears.\n *      If a decimal point appears, at least one digit appears before it.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td>`e` `E`</td>\n *     <td>\n *       The float argument is rounded and converted in the style `[-]d.dddeÂ±dd`, where there is one digit\n *       before the decimal-point character and the number of digits after it is equal to the precision. If\n *       the precision is missing, it is taken as `6`; if the precision is zero, no decimal-point character\n *       appears. An `E` conversion uses the letter `E` (rather than `e`) to introduce the exponent.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td>`g` `G`</td>\n *     <td>\n *       The float argument is converted in style `f` or `e` (or `F` or `E` for `G` conversions). The precision specifies\n *       the number of significant digits. If the precision is missing, `6` digits are given; if the\n *       precision is zero, it is treated as `1`. Style `e` is used if the exponent from its conversion is less\n *       than `-6` or greater than or equal to the precision. Trailing zeros are removed from the fractional\n *       part of the result; a decimal point appears only if it is followed by at least one digit.\n *     </td>\n *   </tr>\n *   <tr>\n *     <td>`%`</td>\n *     <td>A literal `%` is written. No argument is converted. The complete conversion specification is `%%`.</td>\n *   </tr>\n *\n * </table>\n * </div>\n *\n * @function sprintf\n * @static\n * @since 1.0.0\n * @memberOf Format\n * @param  {string} [format=''] The format string.\n * @param  {...*}               replacements The replacements to produce the string.\n * @return {string}             Returns the produced string.\n * @example\n * v.sprintf('%s, %s!', 'Hello', 'World');\n * // => 'Hello World!'\n *\n * v.sprintf('%s costs $%d', 'coffee', 2);\n * // => 'coffee costs $2'\n *\n * v.sprintf('%1$s %2$s %1$s %2$s, watcha gonna %3$s', 'bad', 'boys', 'do')\n * // => 'bad boys bad boys, watcha gonna do'\n *\n * v.sprintf('% 6s', 'bird');\n * // => '  bird'\n *\n * v.sprintf('% -6s', 'crab');\n * // => 'crab  '\n *\n * v.sprintf(\"%'*5s\", 'cat');\n * // => '**cat'\n *\n * v.sprintf(\"%'*-6s\", 'duck');\n * // => 'duck**'\n *\n * v.sprintf('%d %i %+d', 15, -2, 25);\n * // => '15 -2 +25'\n *\n * v.sprintf(\"%06d\", 15);\n * // => '000015'\n *\n * v.sprintf('0b%b 0o%o 0x%X', 12, 9, 155);\n * // => '0b1100 0o11 0x9B'\n *\n * v.sprintf('%.2f', 10.469);\n * // => '10.47'\n *\n * v.sprintf('%.2e %g', 100.5, 0.455);\n * // => '1.01e+2 0.455'\n *\n */\nexport default function sprintf(format, ...replacements) {\n  const formatString = coerceToString(format);\n  if (formatString === '') {\n    return formatString;\n  }\n  const boundReplacementMatch = replacementMatch.bind(undefined, new ReplacementIndex(), replacements);\n  return formatString.replace(REGEXP_CONVERSION_SPECIFICATION, boundReplacementMatch);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_HTML_SPECIAL_CHARACTERS } from 'helper/reg_exp/const';\n\nconst escapeCharactersMap = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;',\n};\n\n/**\n * Return the escaped version of `character`.\n *\n * @ignore\n * @param  {string} character The character to be escape.\n * @return {string}           The escaped version of character.\n */\nfunction replaceSpecialCharacter(character) {\n  return escapeCharactersMap[character];\n}\n\n/**\n * Escapes HTML special characters  <code>< > & ' \" `</code> in <code>subject</code>.\n *\n * @function escapeHtml\n * @static\n * @since 1.0.0\n * @memberOf Escape\n * @param {string} [subject=''] The string to escape.\n * @return {string} Returns the escaped string.\n * @example\n * v.escapeHtml('<p>wonderful world</p>');\n * // => '&lt;p&gt;wonderful world&lt;/p&gt;'\n */\nexport default function escapeHtml(subject) {\n  return coerceToString(subject).replace(REGEXP_HTML_SPECIAL_CHARACTERS, replaceSpecialCharacter);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\nconst unescapeCharactersMap = {\n  '<': /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi,\n  '>': /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi,\n  '&': /(&amp;)|(&#x0*26;)|(&#0*38;)/gi,\n  '\"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi,\n  \"'\": /(&#x0*27;)|(&#0*39;)/gi,\n  '`': /(&#x0*60;)|(&#0*96;)/gi,\n};\nconst characters = Object.keys(unescapeCharactersMap);\n\n/**\n * Replaces the HTML entities with corresponding characters.\n *\n * @ignore\n * @param  {string} string The accumulator string.\n * @param  {string} key    The character.\n * @return {string}        The string with replaced HTML entity\n */\nfunction reduceUnescapedString(string, key) {\n  return string.replace(unescapeCharactersMap[key], key);\n}\n\n/**\n * Unescapes HTML special characters from <code>&amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;#x27; &amp;#x60;</code>\n * to corresponding <code>< > & ' \" `</code> in <code>subject</code>.\n *\n * @function unescapeHtml\n * @static\n * @since 1.0.0\n * @memberOf Escape\n * @param  {string} [subject=''] The string to unescape.\n * @return {string}              Returns the unescaped string.\n * @example\n * v.unescapeHtml('&lt;p&gt;wonderful world&lt;/p&gt;');\n * // => '<p>wonderful world</p>'\n */\nexport default function unescapeHtml(subject) {\n  const subjectString = coerceToString(subject);\n  return characters.reduce(reduceUnescapedString, subjectString);\n}\n","/**\n * Generated diacritics map. See bellow the base code.\n * @ignore\n * @type Object\n */\n\nconst diacritics = {\n  '3': '\\u039e\\u03be',\n  '8': '\\u0398\\u03b8',\n  A: '\\x41\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226\\u023a\\u0386\\u0391\\u0410',\n  B: '\\x42\\u0181\\u0182\\u0243\\u0392\\u0411',\n  C: '\\x43\\xc7\\u0106\\u0108\\u010a\\u010c\\u0187\\u023b\\u0426',\n  D: '\\x44\\u010e\\u0110\\u0189\\u018a\\u018b\\xd0\\u0394\\u0414',\n  E: '\\x45\\xc8\\xc9\\xca\\xcb\\u0112\\u0114\\u0116\\u0118\\u011a\\u018e\\u0190\\u0204\\u0206\\u0228\\u0388\\u0395\\u0415\\u042d',\n  F: '\\x46\\u0191\\u03a6\\u0424',\n  G: '\\x47\\u011c\\u011e\\u0120\\u0122\\u0193\\u01e4\\u01e6\\u01f4\\u0393\\u0413\\u0490',\n  H: '\\x48\\u0124\\u0126\\u021e\\u0389\\u0397\\u0425',\n  I: '\\x49\\xcc\\xcd\\xce\\xcf\\u0128\\u012a\\u012c\\u012e\\u0130\\u0197\\u01cf\\u0208\\u020a\\u038a\\u0399\\u03aa\\u0406\\u0418',\n  J: '\\x4a\\u0134\\u0248\\u0419',\n  K: '\\x4b\\u0136\\u0198\\u01e8\\u039a\\u041a',\n  L: '\\x4c\\u0139\\u013b\\u013d\\u013f\\u0141\\u023d\\u039b\\u041b',\n  M: '\\x4d\\u019c\\u039c\\u041c',\n  N: '\\x4e\\xd1\\u0143\\u0145\\u0147\\u019d\\u01f8\\u0220\\u039d\\u041d',\n  O:\n    '\\x4f\\xd2\\xd3\\xd4\\xd5\\xd6\\xd8\\u014c\\u014e\\u0150\\u0186\\u019f\\u01a0\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\\u022e\\u0230\\u038c\\u039f\\u041e',\n  P: '\\x50\\u01a4\\u03a0\\u041f',\n  Q: '\\x51\\u024a',\n  R: '\\x52\\u0154\\u0156\\u0158\\u0210\\u0212\\u024c\\u03a1\\u0420',\n  S: '\\x53\\u015a\\u015c\\u015e\\u0160\\u0218\\u03a3\\u0421',\n  T: '\\x54\\u0162\\u0164\\u0166\\u01ac\\u01ae\\u021a\\u023e\\u03a4\\u0422',\n  U:\n    '\\x55\\xd9\\xda\\xdb\\xdc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01af\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216\\u0244\\u0423\\u042a',\n  V: '\\x56\\u01b2\\u0245\\u0412',\n  W: '\\x57\\u0174\\u038f\\u03a9',\n  X: '\\x58\\u03a7',\n  Y: '\\x59\\xdd\\u0176\\u0178\\u01b3\\u0232\\u024e\\u038e\\u03a5\\u03ab\\u042b',\n  Z: '\\x5a\\u0179\\u017b\\u017d\\u01b5\\u0224\\u0396\\u0417',\n  a: '\\x61\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227\\u0250\\u03ac\\u03b1\\u0430',\n  b: '\\x62\\u0180\\u0183\\u0253\\u03b2\\u0431',\n  c: '\\x63\\xe7\\u0107\\u0109\\u010b\\u010d\\u0188\\u023c\\u0446',\n  d: '\\x64\\u010f\\u0111\\u018c\\u0256\\u0257\\xf0\\u03b4\\u0434',\n  e: '\\x65\\xe8\\xe9\\xea\\xeb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229\\u0247\\u025b\\u03ad\\u03b5\\u0435\\u044d',\n  f: '\\x66\\u0192\\u03c6\\u0444',\n  g: '\\x67\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5\\u0260\\u03b3\\u0433\\u0491',\n  h: '\\x68\\u0125\\u0127\\u021f\\u0265\\u03ae\\u03b7\\u0445',\n  i: '\\x69\\xec\\xed\\xee\\xef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b\\u0268\\u0390\\u03af\\u03b9\\u03ca\\u0438\\u0456',\n  j: '\\x6a\\u0135\\u01f0\\u0249\\u0439',\n  k: '\\x6b\\u0137\\u0199\\u01e9\\u03ba\\u043a',\n  l: '\\x6c\\u013a\\u013c\\u013e\\u0140\\u0142\\u017f\\u019a\\u026b\\u03bb\\u043b',\n  m: '\\x6d\\u026f\\u0271\\u03bc\\u043c',\n  n: '\\x6e\\xf1\\u0144\\u0146\\u0148\\u0149\\u019e\\u01f9\\u0272\\u03bd\\u043d',\n  o:\n    '\\x6f\\xf2\\xf3\\xf4\\xf5\\xf6\\xf8\\u014d\\u014f\\u0151\\u01a1\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\\u022f\\u0231\\u0254\\u0275\\u03bf\\u03cc\\u043e',\n  p: '\\x70\\u01a5\\u03c0\\u043f',\n  q: '\\x71\\u024b',\n  r: '\\x72\\u0155\\u0157\\u0159\\u0211\\u0213\\u024d\\u027d\\u03c1\\u0440',\n  s: '\\x73\\xdf\\u015b\\u015d\\u015f\\u0161\\u0219\\u023f\\u03c2\\u03c3\\u0441',\n  t: '\\x74\\u0163\\u0165\\u0167\\u01ad\\u021b\\u0288\\u03c4\\u0442',\n  u:\n    '\\x75\\xf9\\xfa\\xfb\\xfc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01b0\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217\\u0289\\u0443\\u044a',\n  v: '\\x76\\u028b\\u028c\\u0432',\n  w: '\\x77\\u0175\\u03c9\\u03ce',\n  x: '\\x78\\u03c7',\n  y: '\\x79\\xfd\\xff\\u0177\\u01b4\\u0233\\u024f\\u03b0\\u03c5\\u03cb\\u03cd\\u044b',\n  z: '\\x7a\\u017a\\u017c\\u017e\\u01b6\\u0225\\u0240\\u03b6\\u0437',\n  OE: '\\x8c\\u0152',\n  oe: '\\x9c\\u0153',\n  AE: '\\xc6\\u01e2\\u01fc',\n  ae: '\\xe6\\u01e3\\u01fd',\n  hv: '\\u0195',\n  OI: '\\u01a2',\n  oi: '\\u01a3',\n  DZ: '\\u01c4\\u01f1',\n  Dz: '\\u01c5\\u01f2',\n  dz: '\\u01c6\\u01f3',\n  LJ: '\\u01c7',\n  Lj: '\\u01c8',\n  lj: '\\u01c9',\n  NJ: '\\u01ca',\n  Nj: '\\u01cb',\n  nj: '\\u01cc',\n  OU: '\\u0222',\n  ou: '\\u0223',\n  TH: '\\xde',\n  th: '\\xfe',\n  PS: '\\u03a8',\n  ps: '\\u03c8',\n  Yo: '\\u0401',\n  Ye: '\\u0404',\n  Yi: '\\u0407',\n  Zh: '\\u0416',\n  Ch: '\\u0427',\n  Sh: '\\u0428\\u0429',\n  '': '\\u042a\\u042c\\u044c',\n  Yu: '\\u042e',\n  Ya: '\\u042f',\n  zh: '\\u0436',\n  ch: '\\u0447',\n  sh: '\\u0448\\u0449',\n  yu: '\\u044e',\n  ya: '\\u044f',\n  yo: '\\u0451',\n  ye: '\\u0454',\n  yi: '\\u0457',\n};\n\nlet diacriticsMap = null;\n\n/**\n * Creates a map of the diacritics.\n *\n * @ignore\n * @returns {Object} Returns the diacritics map.\n */\nfunction getDiacriticsMap() {\n  if (diacriticsMap !== null) {\n    return diacriticsMap;\n  }\n  diacriticsMap = {};\n  Object.keys(diacritics).forEach(function(key) {\n    const characters = diacritics[key];\n    for (let index = 0; index < characters.length; index++) {\n      const character = characters[index];\n      diacriticsMap[character] = key;\n    }\n  });\n  return diacriticsMap;\n}\n\n/**\n * Get the latin character from character with diacritics.\n *\n * @ignore\n * @param   {string} character The character with diacritics.\n * @returns {string}           Returns the character without diacritics.\n */\nexport function getLatinCharacter(character) {\n  const characterWithoutDiacritic = getDiacriticsMap()[character];\n  return characterWithoutDiacritic ? characterWithoutDiacritic : character;\n}\n","import { REGEXP_COMBINING_MARKS, REGEXP_NON_LATIN } from 'helper/reg_exp/const';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport { getLatinCharacter } from 'helper/string/diacritics_map';\n\n/**\n * Returns the `cleanCharacter` from combining marks regular expression match.\n *\n * @ignore\n * @param {string} character The character with combining marks\n * @param {string} cleanCharacter The character without combining marks.\n * @return {string} The character without combining marks.\n */\nfunction removeCombiningMarks(character, cleanCharacter) {\n  return cleanCharacter;\n}\n\n/**\n * Latinises the `subject` by removing diacritic characters.\n *\n * @function latinise\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to latinise.\n * @return {string} Returns the latinised string.\n * @example\n * v.latinise('cafe\\u0301'); // or 'cafeÌ'\n * // => 'cafe'\n *\n * v.latinise('aoÃ»t dÃ©cembre');\n * // => 'aout decembre'\n *\n * v.latinise('ÐºÐ°Ðº Ð¿Ñ€ÐµÐºÑ€Ð°ÑÐµÐ½ ÑÑ‚Ð¾Ñ‚ Ð¼Ð¸Ñ€');\n * // => 'kak prekrasen etot mir'\n */\nexport default function latinise(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return subjectString\n    .replace(REGEXP_NON_LATIN, getLatinCharacter)\n    .replace(REGEXP_COMBINING_MARKS, removeCombiningMarks);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport isString from 'query/is_string';\nimport nilDefault from 'helper/undefined/nil_default';\n\n/**\n * Translates characters or replaces substrings in `subject`.\n *\n * @function tr\n * @static\n * @since 1.3.0\n * @memberOf Manipulate\n * @param  {string} [subject=''] The string to translate.\n * @param  {string|Object} from The string of characters to translate from. Or an object, then the object keys are replaced with corresponding values (longest keys are tried first).\n * @param  {string} to The string of characters to translate to. Ignored when `from` is an object.\n * @return {string} Returns the translated string.\n * @example\n * v.tr('hello', 'el', 'ip');\n * // => 'hippo'\n *\n * v.tr('lÃ©gÃ¨retÃ©', 'Ã©Ã¨', 'ee');\n * // => 'legerete'\n *\n * v.tr('Yes. The fire rises.', {\n *   'Yes': 'Awesome',\n *   'fire': 'flame'\n * })\n * // => 'Awesome. The flame rises.'\n *\n * v.tr(':where is the birthplace of :what', {\n *   ':where': 'Africa',\n *   ':what': 'Humanity'\n * });\n * // => 'Africa is the birthplace of Humanity'\n *\n */\nexport default function tr(subject, from, to) {\n  const subjectString = coerceToString(subject);\n  let keys;\n  let values;\n  if (isString(from) && isString(to)) {\n    keys = from.split('');\n    values = to.split('');\n  } else {\n    [keys, values] = extractKeysAndValues(nilDefault(from, {}));\n  }\n  const keysLength = keys.length;\n  if (keysLength === 0) {\n    return subjectString;\n  }\n  let result = '';\n  const valuesLength = values.length;\n  for (let index = 0; index < subjectString.length; index++) {\n    let isMatch = false;\n    let matchValue;\n    for (let keyIndex = 0; keyIndex < keysLength && keyIndex < valuesLength; keyIndex++) {\n      const key = keys[keyIndex];\n      if (subjectString.substr(index, key.length) === key) {\n        isMatch = true;\n        matchValue = values[keyIndex];\n        index = index + key.length - 1;\n        break;\n      }\n    }\n    result += isMatch ? matchValue : subjectString[index];\n  }\n  return result;\n}\n\nfunction extractKeysAndValues(object) {\n  const keys = Object.keys(object);\n  const values = keys.sort(sortStringByLength).map(function(key) {\n    return object[key];\n  });\n  return [keys, values];\n}\n\nfunction sortStringByLength(str1, str2) {\n  if (str1.length === str2.length) {\n    return 0;\n  }\n  return str1.length < str2.length ? 1 : -1;\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\nimport toString from 'helper/string/to_string';\n\n/**\n * Checks whether `subject` includes `search` starting from `position`.\n *\n * @function includes\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string where to search.\n * @param {string} search The string to search.\n * @param {number} [position=0] The position to start searching.\n * @return {boolean} Returns `true` if `subject` includes `search` or `false` otherwise.\n * @example\n * v.includes('starship', 'star');\n * // => true\n *\n * v.includes('galaxy', 'g', 1);\n * // => false\n */\nexport default function includes(subject, search, position) {\n  const subjectString = coerceToString(subject);\n  const searchString = toString(search);\n  if (searchString === null) {\n    return false;\n  }\n  if (searchString === '') {\n    return true;\n  }\n  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);\n  return subjectString.indexOf(searchString, position) !== -1;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport includes from 'query/includes';\nimport isNil from 'helper/object/is_nil';\nimport { REGEXP_TRIM_LEFT } from 'helper/reg_exp/const';\nimport toString from 'helper/string/to_string';\n\nconst reduce = Array.prototype.reduce;\n\n/**\n * Removes whitespaces from the left side of the `subject`.\n *\n * @function trimLeft\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to trim.\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\n * @return {string} Returns the trimmed string.\n * @example\n * v.trimLeft('  Starship Troopers');\n * // => 'Starship Troopers'\n *\n * v.trimLeft('***Mobile Infantry', '*');\n * // => 'Mobile Infantry'\n */\nexport default function trimLeft(subject, whitespace) {\n  const subjectString = coerceToString(subject);\n  if (whitespace === '' || subjectString === '') {\n    return subjectString;\n  }\n  const whitespaceString = toString(whitespace);\n  if (isNil(whitespaceString)) {\n    return subjectString.replace(REGEXP_TRIM_LEFT, '');\n  }\n  let matchWhitespace = true;\n  return reduce.call(\n    subjectString,\n    function(trimmed, character) {\n      if (matchWhitespace && includes(whitespaceString, character)) {\n        return trimmed;\n      }\n      matchWhitespace = false;\n      return trimmed + character;\n    },\n    ''\n  );\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport includes from 'query/includes';\nimport isNil from 'helper/object/is_nil';\nimport { REGEXP_TRIM_RIGHT } from 'helper/reg_exp/const';\nimport toString from 'helper/string/to_string';\n\nconst reduceRight = Array.prototype.reduceRight;\n\n/**\n * Removes whitespaces from the right side of the `subject`.\n *\n * @function trimRight\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to trim.\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\n * @return {string} Returns the trimmed string.\n * @example\n * v.trimRight('the fire rises   ');\n * // => 'the fire rises'\n *\n * v.trimRight('do you feel in charge?!!!', '!');\n * // => 'do you feel in charge?'\n */\nexport default function trimRight(subject, whitespace) {\n  const subjectString = coerceToString(subject);\n  if (whitespace === '' || subjectString === '') {\n    return subjectString;\n  }\n  const whitespaceString = toString(whitespace);\n  if (isNil(whitespaceString)) {\n    return subjectString.replace(REGEXP_TRIM_RIGHT, '');\n  }\n  let matchWhitespace = true;\n  return reduceRight.call(\n    subjectString,\n    function(trimmed, character) {\n      if (matchWhitespace && includes(whitespaceString, character)) {\n        return trimmed;\n      }\n      matchWhitespace = false;\n      return character + trimmed;\n    },\n    ''\n  );\n}\n","import coerceToBoolean from 'helper/boolean/coerce_to_boolean';\nimport coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\n\nconst OPTION_WIDTH = 'width';\nconst OPTION_NEW_LINE = 'newLine';\nconst OPTION_INDENT = 'indent';\nconst OPTION_CUT = 'cut';\n\n/**\n * Wraps `subject` to a given number of characters using a string break character.\n *\n * @function wordWrap\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param  {string} [subject=''] The string to wrap.\n * @param  {Object} [options={}] The wrap options.\n * @param  {number} [options.width=75] The number of characters at which to wrap.\n * @param  {string} [options.newLine='\\n'] The string to add at the end of line.\n * @param  {string} [options.indent='']  The string to intend the line.\n * @param  {boolean} [options.cut=false] When `false` (default) does not split the word even if word length is bigger than `width`. <br/>\n *                                       When `true` breaks the word that has length bigger than `width`.\n *\n * @return {string} Returns wrapped string.\n * @example\n * v.wordWrap('Hello world', {\n *   width: 5\n * });\n * // => 'Hello\\nworld'\n *\n * v.wordWrap('Hello world', {\n *   width: 5,\n *   newLine: '<br/>',\n *   indent: '__'\n * });\n * // => '__Hello<br/>__world'\n *\n * v.wordWrap('Wonderful world', {\n *   width: 5,\n *   cut: true\n * });\n * // => 'Wonde\\nrful\\nworld'\n *\n */\nexport default function wordWrap(subject, options = {}) {\n  const subjectString = coerceToString(subject);\n  const { width, newLine, indent, cut } = determineOptions(options);\n  if (subjectString === '' || width <= 0) {\n    return indent;\n  }\n  const subjectLength = subjectString.length;\n  const substring = subjectString.substring.bind(subjectString);\n  let offset = 0;\n  let wrappedLine = '';\n  while (subjectLength - offset > width) {\n    if (subjectString[offset] === ' ') {\n      offset++;\n      continue;\n    }\n    let spaceToWrapAt = subjectString.lastIndexOf(' ', width + offset);\n    if (spaceToWrapAt >= offset) {\n      wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;\n      offset = spaceToWrapAt + 1;\n    } else {\n      if (cut) {\n        wrappedLine += indent + substring(offset, width + offset) + newLine;\n        offset += width;\n      } else {\n        spaceToWrapAt = subjectString.indexOf(' ', width + offset);\n        if (spaceToWrapAt >= 0) {\n          wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;\n          offset = spaceToWrapAt + 1;\n        } else {\n          wrappedLine += indent + substring(offset);\n          offset = subjectLength;\n        }\n      }\n    }\n  }\n  if (offset < subjectLength) {\n    wrappedLine += indent + substring(offset);\n  }\n  return wrappedLine;\n}\n\n/**\n * Determine the word wrap options. The missing values are filled with defaults.\n *\n * @param  {Object} options  The options object.\n * @return {Object}          The word wrap options, with default settings if necessary.\n * @ignore\n */\nfunction determineOptions(options) {\n  return {\n    width: coerceToNumber(options[OPTION_WIDTH], 75),\n    newLine: coerceToString(options[OPTION_NEW_LINE], '\\n'),\n    indent: coerceToString(options[OPTION_INDENT], ''),\n    cut: coerceToBoolean(options[OPTION_CUT], false),\n  };\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_ALPHA } from 'helper/reg_exp/const_extended';\n\n/**\n * Checks whether `subject` contains only alpha characters.\n *\n * @function isAlpha\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` contains only alpha characters or `false` otherwise.\n * @example\n * v.isAlpha('bart');\n * // => true\n *\n * v.isAlpha('lisa!');\n * // => false\n *\n * v.isAlpha('lisa and bart');\n * // => false\n */\nexport default function isAlpha(subject) {\n  const subjectString = coerceToString(subject);\n  return REGEXP_ALPHA.test(subjectString);\n}\n","import { REGEXP_WHITESPACE } from 'helper/reg_exp/const';\n\nconst STATE_START_TAG = 0;\nconst STATE_NON_WHITESPACE = 1;\nconst STATE_DONE = 2;\n\n/**\n * Parses the tag name from html content.\n *\n * @ignore\n * @param {string} tagContent The tag content.\n * @return {string} Returns the tag name.\n */\nexport default function parseTagName(tagContent) {\n  let state = STATE_START_TAG;\n  let tagName = '';\n  let index = 0;\n  while (state !== STATE_DONE) {\n    const char = tagContent[index++].toLowerCase();\n    switch (char) {\n      case '<':\n        break;\n      case '>':\n        state = STATE_DONE;\n        break;\n      default:\n        if (REGEXP_WHITESPACE.test(char)) {\n          if (state === STATE_NON_WHITESPACE) {\n            state = STATE_DONE;\n          }\n        } else {\n          if (state === STATE_START_TAG) {\n            state = STATE_NON_WHITESPACE;\n          }\n          if (char !== '/') {\n            tagName += char;\n          }\n        }\n        break;\n    }\n  }\n  return tagName;\n}\n","let globalObject = null;\n\nfunction getGlobalObject() {\n  if (globalObject !== null) {\n    return globalObject;\n  }\n  /* istanbul ignore next */\n  // It's hard to mock the global variables. This code surely works fine. I hope :)\n  if (typeof global === 'object' && global.Object === Object) {\n    // NodeJS global object\n    globalObject = global;\n  } else if (typeof self === 'object' && self.Object === Object) {\n    // self property from Window object\n    globalObject = self;\n  } else {\n    // Other cases. Function constructor always has the context as global object\n    globalObject = new Function('return this')();\n  }\n  return globalObject;\n}\n\nexport default getGlobalObject;\n","import getGlobalObject from 'helper/object/get_global';\n\nconst globalObject = getGlobalObject();\nconst previousV = globalObject.v;\n\n/**\n * Restores `v` variable to previous value and returns Voca library instance.\n *\n * @function noConflict\n * @static\n * @since 1.0.0\n * @memberOf Util\n * @return {Object} Returns Voca library instance.\n * @example\n * var voca = v.noConflict();\n * voca.isAlpha('Hello');\n * // => true\n */\nexport default function noConflict() {\n  if (this === globalObject.v) {\n    globalObject.v = previousV;\n  }\n  return this;\n}\n","/**\n * A property that contains the library <a href=\"http://semver.org/\">semantic version number</a>.\n * @name version\n * @static\n * @since 1.0.0\n * @memberOf Util\n * @type string\n * @example\n * v.version\n * // => '1.4.0'\n */\nconst version = '1.4.0';\n\nexport default version;\n","/* eslint sort-imports: \"off\" */\n\n/**\n * Functions to change the case\n * @namespace Case\n */\nimport camelCase from './case/camel_case';\nimport capitalize from './case/capitalize';\nimport decapitalize from './case/decapitalize';\nimport kebabCase from './case/kebab_case';\nimport lowerCase from './case/lower_case';\nimport snakeCase from './case/snake_case';\nimport upperCase from './case/upper_case';\nimport swapCase from './case/swap_case';\nimport titleCase from './case/title_case';\nimport truncate from './chop/truncate';\n\n/**\n * Chain functions\n * @namespace Chain\n */\n\n/**\n * Functions to cut a string\n * @namespace Chop\n */\nimport charAt from './chop/char_at';\nimport codePointAt from './chop/code_point_at';\nimport first from './chop/first';\nimport graphemeAt from './chop/grapheme_at';\nimport last from './chop/last';\nimport prune from './chop/prune';\nimport slice from './chop/slice';\nimport substr from './chop/substr';\nimport substring from './chop/substring';\n\n/**\n * Functions to count characters in a string\n * @namespace Count\n */\nimport count from './count/count';\nimport countGraphemes from './count/count_graphemes';\nimport countSubstrings from './count/count_substrings';\nimport countWhere from './count/count_where';\nimport countWords from './count/count_words';\n\n/**\n * Functions to format\n * @namespace Format\n */\nimport sprintf from './format/sprintf';\nimport vprintf from './format/vprintf';\n\n/**\n * Functions to escape RegExp special characters\n * @namespace Escape\n */\nimport escapeHtml from './escape/escape_html';\nimport escapeRegExp from './escape/escape_reg_exp';\nimport unescapeHtml from './escape/unescape_html';\n\n/**\n * Functions to find index\n * @namespace Index\n */\nimport indexOf from './index/index_of';\nimport lastIndexOf from './index/last_index_of';\nimport search from './index/search';\n\n/**\n * Functions to manipulate a string\n * @namespace Manipulate\n */\nimport insert from './manipulate/insert';\nimport latinise from './manipulate/latinise';\nimport pad from './manipulate/pad';\nimport padLeft from './manipulate/pad_left';\nimport padRight from './manipulate/pad_right';\nimport repeat from './manipulate/repeat';\nimport replace from './manipulate/replace';\nimport replaceAll from './manipulate/replace_all';\nimport reverse from './manipulate/reverse';\nimport reverseGrapheme from './manipulate/reverse_grapheme';\nimport slugify from './manipulate/slugify';\nimport splice from './manipulate/splice';\nimport tr from './manipulate/tr';\nimport trim from './manipulate/trim';\nimport trimLeft from './manipulate/trim_left';\nimport trimRight from './manipulate/trim_right';\nimport wordWrap from './manipulate/word_wrap';\n\n/**\n * Functions to query a string\n * @namespace Query\n */\nimport endsWith from './query/ends_with';\nimport includes from './query/includes';\nimport isAlpha from './query/is_alpha';\nimport isAlphaDigit from './query/is_alpha_digit';\nimport isBlank from './query/is_blank';\nimport isDigit from './query/is_digit';\nimport isEmpty from './query/is_empty';\nimport isLowerCase from './query/is_lower_case';\nimport isNumeric from './query/is_numeric';\nimport isString from './query/is_string';\nimport isUpperCase from './query/is_upper_case';\nimport matches from './query/matches';\nimport startsWith from './query/starts_with';\n\n/**\n * Functions to split a string\n * @namespace Split\n */\nimport chars from './split/chars';\nimport codePoints from './split/code_points';\nimport graphemes from './split/graphemes';\nimport split from './split/split';\nimport words from './split/words';\n\n/**\n * Functions to strip a string\n * @namespace Strip\n */\nimport stripBom from './strip/strip_bom';\nimport stripTags from './strip/strip_tags';\n\n/**\n * Util functions and properties\n * @namespace Util\n */\nimport noConflict from './util/no_conflict';\nimport version from './util/version';\n\nexport default {\n  camelCase,\n  capitalize,\n  decapitalize,\n  kebabCase,\n  lowerCase,\n  snakeCase,\n  swapCase,\n  titleCase,\n  upperCase,\n\n  count,\n  countGraphemes,\n  countSubstrings,\n  countWhere,\n  countWords,\n\n  escapeHtml,\n  escapeRegExp,\n  unescapeHtml,\n\n  sprintf,\n  vprintf,\n\n  indexOf,\n  lastIndexOf,\n  search,\n\n  charAt,\n  codePointAt,\n  first,\n  graphemeAt,\n  last,\n  prune,\n  slice,\n  substr,\n  substring,\n  truncate,\n\n  insert,\n  latinise,\n  pad,\n  padLeft,\n  padRight,\n  repeat,\n  replace,\n  replaceAll,\n  reverse,\n  reverseGrapheme,\n  slugify,\n  splice,\n  tr,\n  trim,\n  trimLeft,\n  trimRight,\n  wordWrap,\n\n  endsWith,\n  includes,\n  isAlpha,\n  isAlphaDigit,\n  isBlank,\n  isDigit,\n  isEmpty,\n  isLowerCase,\n  isNumeric,\n  isString,\n  isUpperCase,\n  matches,\n  startsWith,\n\n  chars,\n  codePoints,\n  graphemes,\n  split,\n  words,\n\n  stripBom,\n  stripTags,\n\n  noConflict,\n  version,\n};\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the first character of `subject` to lower case.\n *\n * @function decapitalize\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to decapitalize.\n * @return {string}              Returns the decapitalized string.\n * @example\n * v.decapitalize('Sun');\n * // => 'sun'\n *\n * v.decapitalize('moon');\n * // => 'moon'\n */\nexport default function decapitalize(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return subjectString.substr(0, 1).toLowerCase() + subjectString.substr(1);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport lowerCase from 'case/lower_case';\nimport words from 'split/words';\n\n/**\n * Converts the `subject` to <a href=\"https://en.wikipedia.org/wiki/Snake_case\">snake case</a>.\n *\n * @function snakeCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to snake case.\n * @return {string}              Returns the snake case string.\n * @example\n * v.snakeCase('learning to fly');\n * // => 'learning_to_fly'\n *\n * v.snakeCase('LearningToFly');\n * // => 'learning_to_fly'\n *\n * v.snakeCase('-Learning-To-Fly-');\n * // => 'learning_to_fly'\n */\nexport default function snakeCase(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  return words(subjectString)\n    .map(lowerCase)\n    .join('_');\n}\n","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\nimport capitalize from 'case/capitalize';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the subject to title case.\n *\n * @function titleCase\n * @static\n * @since 1.4.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to title case.\n * @param  {Array}  [noSplit]    Do not split words at the specified characters.\n * @return {string}              Returns the title case string.\n * @example\n * v.titleCase('learning to fly');\n * // => 'Learning To Fly'\n *\n * v.titleCase('jean-luc is good-looking', ['-']);\n * // => 'Jean-luc Is Good-looking'\n */\nexport default function titleCase(subject, noSplit) {\n  const subjectString = coerceToString(subject);\n  const noSplitArray = Array.isArray(noSplit) ? noSplit : [];\n  const wordsRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\n  return subjectString.replace(wordsRegExp, function(word, index) {\n    const isNoSplit = index > 0 && noSplitArray.indexOf(subjectString[index - 1]) >= 0;\n    return isNoSplit ? word.toLowerCase() : capitalize(word, true);\n  });\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Converts the `subject` to upper case.\n *\n * @function upperCase\n * @static\n * @since 1.0.0\n * @memberOf Case\n * @param  {string} [subject=''] The string to convert to upper case.\n * @return {string}              Returns the upper case string.\n * @example\n * v.upperCase('school');\n * // => 'SCHOOL'\n */\nexport default function upperCase(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.toUpperCase();\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Counts the characters in `subject`.<br/>\n *\n * @function count\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string} [subject=''] The string to count characters.\n * @return {number}              Returns the number of characters in `subject`.\n * @example\n * v.count('rain');\n * // => 4\n */\nexport default function count(subject) {\n  return coerceToString(subject).length;\n}\n","import { REGEXP_COMBINING_MARKS, REGEXP_SURROGATE_PAIRS } from 'helper/reg_exp/const';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Counts the graphemes in `subject` taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function  countGraphemes\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string} [subject=''] The string to count graphemes.\n * @return {number}              Returns the number of graphemes in `subject`.\n * @example\n * v.countGraphemes('cafe\\u0301'); // or 'cafeÌ'\n * // => 4\n *\n * v.countGraphemes('\\uD835\\uDC00\\uD835\\uDC01'); // or 'ð€ð'\n * // => 2\n *\n * v.countGraphemes('rain');\n * // => 4\n */\nexport default function countGrapheme(subject) {\n  return coerceToString(subject)\n    .replace(REGEXP_COMBINING_MARKS, '*')\n    .replace(REGEXP_SURROGATE_PAIRS, '*').length;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Counts the number of `substring` appearances in `subject`.\n *\n * @function countSubstrings\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param  {string} [subject=''] The string where to count.\n * @param  {string} substring    The substring to be counted.\n * @return {number}              Returns the number of `substring` appearances.\n * @example\n * v.countSubstrings('bad boys, bad boys whatcha gonna do?', 'boys');\n * // => 2\n *\n * v.countSubstrings('every dog has its day', 'cat');\n * // => 0\n */\nexport default function countSubstrings(subject, substring) {\n  const subjectString = coerceToString(subject);\n  const substringString = coerceToString(substring);\n  const substringLength = substringString.length;\n  let count = 0;\n  let matchIndex = 0;\n  if (subjectString === '' || substringString === '') {\n    return count;\n  }\n  do {\n    matchIndex = subjectString.indexOf(substringString, matchIndex);\n    if (matchIndex !== -1) {\n      count++;\n      matchIndex += substringLength;\n    }\n  } while (matchIndex !== -1);\n  return count;\n}\n","import words from 'split/words';\n\n/**\n * Counts the number of words in `subject`.\n *\n * @function countWords\n * @static\n * @since 1.0.0\n * @memberOf Count\n * @param {string} [subject=''] The string to split into words.\n * @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\n * @return {number} Returns the number of words.\n * @example\n * v.countWords('gravity can cross dimensions');\n * // => 4\n *\n * v.countWords('GravityCanCrossDimensions');\n * // => 4\n *\n * v.countWords('Gravity - can cross dimensions!');\n * // => 4\n *\n * v.words('Earth gravity', /[^\\s]+/g);\n * // => 2\n */\nexport default function countWords(subject, pattern, flags) {\n  return words(subject, pattern, flags).length;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_SPECIAL_CHARACTERS } from 'helper/reg_exp/const';\n\n/**\n * Escapes the regular expression special characters `- [ ] / { } ( ) * + ? . \\ ^ $ |` in `subject`.\n *\n * @function escapeRegExp\n * @static\n * @since 1.0.0\n * @memberOf Escape\n * @param {string} [subject=''] The string to escape.\n * @return {string} Returns the escaped string.\n * @example\n * v.escapeRegExp('(hours)[minutes]{seconds}');\n * // => '\\(hours\\)\\[minutes\\]\\{seconds\\}'\n */\nexport default function escapeRegExp(subject) {\n  return coerceToString(subject).replace(REGEXP_SPECIAL_CHARACTERS, '\\\\$&');\n}\n","import nilDefault from 'helper/undefined/nil_default';\nimport sprintf from 'format/sprintf';\n\n/**\n * Produces a string according to `format`. Works exactly like <a href=\"#sprintf\"><code>sprintf()</code></a>,\n * with the only difference that accepts the formatting arguments in an array `values`.<br/>\n * See <a href=\"#sprintf-format\">here</a> `format` string specifications.\n *\n * @function vprintf\n * @static\n * @since 1.0.0\n * @memberOf Format\n * @param  {string} format='']  The format string.\n * @param  {Array} replacements The array of replacements to produce the string.\n * @return {string}             Returns the produced string.\n * @example\n * v.vprintf('%s', ['Welcome'])\n * // => 'Welcome'\n *\n * v.vprintf('%s has %d apples', ['Alexandra', 3]);\n * // => 'Alexandra has 3 apples'\n */\nexport default function vprintf(format, replacements) {\n  return sprintf(format, ...nilDefault(replacements, []));\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Returns the first occurrence index of `search` in `subject`.\n *\n * @function indexOf\n * @static\n * @since 1.0.0\n * @memberOf Index\n * @param {string} [subject=''] The string where to search.\n * @param {string} search The string to search.\n * @param {number} [fromIndex=0] The index to start searching.\n * @return {number} Returns the first occurrence index or `-1` if not found.\n * @example\n * v.indexOf('morning', 'n');\n * // => 3\n *\n * v.indexOf('evening', 'o');\n * // => -1\n */\nexport default function indexOf(subject, search, fromIndex) {\n  const subjectString = coerceToString(subject);\n  return subjectString.indexOf(search, fromIndex);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Returns the last occurrence index of `search` in `subject`.\n *\n * @function lastIndexOf\n * @static\n * @since 1.0.0\n * @memberOf Index\n * @param {string} [subject=''] The string where to search.\n * @param {string} search The string to search.\n * @param {number} [fromIndex=subject.length - 1] The index to start searching backward in the string.\n * @return {number} Returns the last occurrence index or `-1` if not found.\n * @example\n * v.lastIndexOf('morning', 'n');\n * // => 5\n *\n * v.lastIndexOf('evening', 'o');\n * // => -1\n */\nexport default function lastIndexOf(subject, search, fromIndex) {\n  const subjectString = coerceToString(subject);\n  return subjectString.lastIndexOf(search, fromIndex);\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Returns the first index of a `pattern` match in `subject`.\n *\n * @function search\n * @static\n * @since 1.0.0\n * @memberOf Index\n * @param {string} [subject=''] The string where to search.\n * @param {string|RegExp} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern)`.\n * @param {number} [fromIndex=0] The index to start searching.\n * @return {number} Returns the first match index or `-1` if not found.\n * @example\n * v.search('morning', /rn/);\n * // => 2\n *\n * v.search('evening', '/\\d/');\n * // => -1\n */\nexport default function search(subject, pattern, fromIndex) {\n  const subjectString = coerceToString(subject);\n  const fromIndexNumber = isNil(fromIndex) ? 0 : clipNumber(toInteger(fromIndex), 0, subjectString.length);\n  let matchIndex = subjectString.substr(fromIndexNumber).search(pattern);\n  if (matchIndex !== -1 && !isNaN(fromIndexNumber)) {\n    matchIndex += fromIndexNumber;\n  }\n  return matchIndex;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Access a character from `subject` at specified `position`.\n *\n * @function charAt\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {numbers} position The position to get the character.\n * @return {string} Returns the character at specified position.\n * @example\n * v.charAt('helicopter', 0);\n * // => 'h'\n *\n * v.charAt('helicopter', 1);\n * // => 'e'\n */\nexport default function charAt(subject, position) {\n  const subjectString = coerceToString(subject);\n  return subjectString.charAt(position);\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Extracts the first `length` characters from `subject`.\n *\n * @function first\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {int}    [length=1]   The number of characters to extract.\n * @return {string}              Returns the first characters string.\n * @example\n * v.first('helicopter');\n * // => 'h'\n *\n * v.first('vehicle', 2);\n * // => 've'\n *\n * v.first('car', 5);\n * // => 'car'\n */\nexport default function first(subject, length) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  if (subjectString.length <= lengthInt) {\n    return subjectString;\n  }\n  return subjectString.substr(0, lengthInt);\n}\n","import coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport nanDefault from 'helper/number/nan_default';\nimport { REGEXP_UNICODE_CHARACTER } from 'helper/reg_exp/const';\n\n/**\n * Get a grapheme from `subject` at specified `position` taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function graphemeAt\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {number} position The position to get the grapheme.\n * @return {string} Returns the grapheme at specified position.\n * @example\n * v.graphemeAt('\\uD835\\uDC00\\uD835\\uDC01', 0); // or 'ð€ð'\n * // => 'A'\n *\n * v.graphemeAt('cafe\\u0301', 3); // or 'cafeÌ'\n * // => 'eÌ'\n */\nexport default function graphemeAt(subject, position) {\n  const subjectString = coerceToString(subject);\n  let positionNumber = coerceToNumber(position);\n  let graphemeMatch;\n  let graphemeMatchIndex = 0;\n  positionNumber = nanDefault(positionNumber, 0);\n  while ((graphemeMatch = REGEXP_UNICODE_CHARACTER.exec(subjectString)) !== null) {\n    if (graphemeMatchIndex === positionNumber) {\n      REGEXP_UNICODE_CHARACTER.lastIndex = 0;\n      return graphemeMatch[0];\n    }\n    graphemeMatchIndex++;\n  }\n  return '';\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Extracts the last `length` characters from `subject`.\n *\n * @function last\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to extract from.\n * @param  {int}    [length=1]   The number of characters to extract.\n * @return {string}              Returns the last characters string.\n * @example\n * v.last('helicopter');\n * // => 'r'\n *\n * v.last('vehicle', 2);\n * // => 'le'\n *\n * v.last('car', 5);\n * // => 'car'\n */\nexport default function last(subject, length) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  if (subjectString.length <= lengthInt) {\n    return subjectString;\n  }\n  return subjectString.substr(subjectString.length - lengthInt, lengthInt);\n}\n","import { REGEXP_EXTENDED_ASCII, REGEXP_LATIN_WORD, REGEXP_WORD } from 'helper/reg_exp/const_extended';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Truncates `subject` to a new `length` and does not break the words. Guarantees that the truncated string is no longer\n * than `length`.\n *\n * @static\n * @function prune\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject=''] The string to prune.\n * @param  {int}    length       The length to prune the string.\n * @param  {string} [end='...']  The string to be added at the end.\n * @return {string}              Returns the pruned string.\n * @example\n * v.prune('Once upon a time', 7);\n * // => 'Once...'\n *\n * v.prune('Good day, Little Red Riding Hood', 16, ' (more)');\n * // => 'Good day (more)'\n *\n * v.prune('Once upon', 10);\n * // => 'Once upon'\n */\nexport default function prune(subject, length, end) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const endString = coerceToString(end, '...');\n  if (lengthInt >= subjectString.length) {\n    return subjectString;\n  }\n  const pattern = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;\n  let truncatedLength = 0;\n  subjectString.replace(pattern, function(word, offset) {\n    const wordInsertLength = offset + word.length;\n    if (wordInsertLength <= lengthInt - endString.length) {\n      truncatedLength = wordInsertLength;\n    }\n  });\n  return subjectString.substr(0, truncatedLength) + endString;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Extracts from `subject` a string from `start` position up to `end` position. The character at `end` position is not\n * included.\n *\n * @function slice\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject='']         The string to extract from.\n * @param  {number} start                The position to start extraction. If negative use `subject.length + start`.\n * @param  {number} [end=subject.length] The position to end extraction. If negative use `subject.length + end`.\n * @return {string}                      Returns the extracted string.\n * @note Uses native `String.prototype.slice()`\n * @example\n * v.slice('miami', 1);\n * // => 'iami'\n *\n * v.slice('florida', -4);\n * // => 'rida'\n *\n * v.slice('florida', 1, 4);\n * // => \"lor\"\n */\nexport default function slice(subject, start, end) {\n  return coerceToString(subject).slice(start, end);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Extracts from `subject` a string from `start` position a number of `length` characters.\n *\n * @function substr\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject='']                 The string to extract from.\n * @param  {number} start                        The position to start extraction.\n * @param  {number} [length=subject.endOfString] The number of characters to extract. If omitted, extract to the end of `subject`.\n * @return {string}                              Returns the extracted string.\n * @note Uses native `String.prototype.substr()`\n * @example\n * v.substr('infinite loop', 9);\n * // => 'loop'\n *\n * v.substr('dreams', 2, 2);\n * // => 'ea'\n */\nexport default function substr(subject, start, length) {\n  return coerceToString(subject).substr(start, length);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Extracts from `subject` a string from `start` position up to `end` position. The character at `end` position is not\n * included.\n *\n * @function substring\n * @static\n * @since 1.0.0\n * @memberOf Chop\n * @param  {string} [subject='']         The string to extract from.\n * @param  {number} start                The position to start extraction.\n * @param  {number} [end=subject.length] The position to end extraction.\n * @return {string}                      Returns the extracted string.\n * @note Uses native `String.prototype.substring()`\n * @example\n * v.substring('beach', 1);\n * // => 'each'\n *\n * v.substring('ocean', 1, 3);\n * // => 'ea'\n */\nexport default function substring(subject, start, end) {\n  return coerceToString(subject).substring(start, end);\n}\n","import coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Inserts into `subject` a string `toInsert` at specified `position`.\n *\n * @function insert\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string where to insert.\n * @param {string} [toInsert=''] The string to be inserted.\n * @param {number} [position=0] The position to insert.\n * @return {string} Returns the string after insertion.\n * @example\n * v.insert('ct', 'a', 1);\n * // => 'cat'\n *\n * v.insert('sunny', ' day', 5);\n * // => 'sunny day'\n */\nexport default function insert(subject, toInsert, position) {\n  const subjectString = coerceToString(subject);\n  const toInsertString = coerceToString(toInsert);\n  const positionNumber = coerceToNumber(position);\n  if (positionNumber < 0 || positionNumber > subjectString.length || toInsertString === '') {\n    return subjectString;\n  }\n  return subjectString.slice(0, positionNumber) + toInsertString + subjectString.slice(positionNumber);\n}\n","import buildPadding from 'helper/string/build_padding';\nimport clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport { MAX_SAFE_INTEGER } from 'helper/number/const';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Pads `subject` to a new `length`.\n *\n * @function pad\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to pad.\n * @param {int} [length=0] The length to pad the string. No changes are made if `length` is less than `subject.length`.\n * @param {string} [pad=' '] The string to be used for padding.\n * @return {string} Returns the padded string.\n * @example\n * v.pad('dog', 5);\n * // => ' dog '\n *\n * v.pad('bird', 6, '-');\n * // => '-bird-'\n *\n * v.pad('cat', 6, '-=');\n * // => '-cat-='\n */\nexport default function pad(subject, length, pad) {\n  const subjectString = coerceToString(subject);\n  const lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);\n  const padString = coerceToString(pad, ' ');\n  if (lengthInt <= subjectString.length) {\n    return subjectString;\n  }\n  const paddingLength = lengthInt - subjectString.length;\n  const paddingSideLength = toInteger(paddingLength / 2);\n  const paddingSideRemainingLength = paddingLength % 2;\n  return (\n    buildPadding(padString, paddingSideLength) +\n    subjectString +\n    buildPadding(padString, paddingSideLength + paddingSideRemainingLength)\n  );\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Replaces the matches of `search` with `replace`. <br/>\n *\n * @function replace\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to verify.\n * @param {string|RegExp} search The search pattern to replace. If `search` is a string,\n * a simple string match is evaluated and only the first occurrence replaced.\n * @param {string|Function} replace The string or function which invocation result replaces `search` match.\n * @return {string} Returns the replacement result.\n * @example\n * v.replace('swan', 'wa', 'u');\n * // => 'sun'\n *\n * v.replace('domestic duck', /domestic\\s/, '');\n * // => 'duck'\n *\n * v.replace('nice duck', /(nice)(duck)/, function(match, nice, duck) {\n *   return 'the ' + duck + ' is ' + nice;\n * });\n * // => 'the duck is nice'\n */\nexport default function replace(subject, search, replace) {\n  const subjectString = coerceToString(subject);\n  return subjectString.replace(search, replace);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Replaces all occurrences of `search` with `replace`. <br/>\n *\n * @function replaceAll\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to verify.\n * @param {string|RegExp} search The search pattern to replace. If `search` is a string, a simple string match is evaluated.\n * All matches are replaced.\n * @param {string|Function} replace The string or function which invocation result replaces all `search` matches.\n * @return {string} Returns the replacement result.\n * @example\n * v.replaceAll('good morning', 'o', '*');\n * // => 'g**d m*rning'\n * v.replaceAll('evening', /n/g, 's');\n * // => 'evesisg'\n *\n */\nexport default function replaceAll(subject, search, replace) {\n  const subjectString = coerceToString(subject);\n  if (search instanceof RegExp) {\n    if (search.flags.indexOf('g') === -1) {\n      throw new TypeError('search argument is a non-global regular expression');\n    }\n    return subjectString.replace(search, replace);\n  }\n  const searchString = coerceToString(search);\n  const isFunctionalReplace = typeof replace === 'function';\n  if (!isFunctionalReplace) {\n    replace = coerceToString(replace);\n  }\n  const searchLength = searchString.length;\n  if (searchLength === 0) {\n    return replaceAll(subject, /(?:)/g, replace);\n  }\n  const advanceBy = searchLength > 1 ? searchLength : 1;\n  const matchPositions = [];\n  let position = subjectString.indexOf(searchString, 0);\n  while (position !== -1) {\n    matchPositions.push(position);\n    position = subjectString.indexOf(searchString, position + advanceBy);\n  }\n  let endOfLastMatch = 0;\n  let result = '';\n  for (let i = 0; i < matchPositions.length; i++) {\n    const position = matchPositions[i];\n    let replacement = replace;\n    if (isFunctionalReplace) {\n      replacement = coerceToString(replace.call(undefined, searchString, position, subjectString));\n    }\n    result += subjectString.slice(endOfLastMatch, position) + replacement;\n    endOfLastMatch = position + searchLength;\n  }\n  if (endOfLastMatch < subjectString.length) {\n    result += subjectString.slice(endOfLastMatch);\n  }\n  return result;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Reverses the `subject`.\n *\n * @function reverse\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to reverse.\n * @return {string} Returns the reversed string.\n * @example\n * v.reverse('winter');\n * // => 'retniw'\n */\nexport default function reverse(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString\n    .split('')\n    .reverse()\n    .join('');\n}\n","import { REGEXP_COMBINING_MARKS, REGEXP_SURROGATE_PAIRS } from 'helper/reg_exp/const';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Reverses the `subject` taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function reverseGrapheme\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to reverse.\n * @return {string} Returns the reversed string.\n * @example\n * v.reverseGrapheme('summer');\n * // => 'remmus'\n *\n * v.reverseGrapheme('ðŒ† bar maÃ±ana manÌƒana');\n * // => 'ananÌƒam anaÃ±am rab ðŒ†'\n */\nexport default function reverseGrapheme(subject) {\n  let subjectString = coerceToString(subject);\n  /**\n   * @see https://github.com/mathiasbynens/esrever\n   */\n  subjectString = subjectString\n    .replace(REGEXP_COMBINING_MARKS, function($0, $1, $2) {\n      return reverseGrapheme($2) + $1;\n    })\n    .replace(REGEXP_SURROGATE_PAIRS, '$2$1');\n  let reversedString = '';\n  let index = subjectString.length;\n  while (index--) {\n    reversedString += subjectString.charAt(index);\n  }\n  return reversedString;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport kebabCase from 'case/kebab_case';\nimport latinise from 'manipulate/latinise';\nimport { REGEXP_NON_LATIN } from 'helper/reg_exp/const';\n\n/**\n * Slugifies the `subject`. Cleans the `subject` by replacing diacritics with corresponding latin characters.\n *\n * @function slugify\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to slugify.\n * @return {string} Returns the slugified string.\n * @example\n * v.slugify('Italian cappuccino drink');\n * // => 'italian-cappuccino-drink'\n *\n * v.slugify('caffÃ© lattÃ©');\n * // => 'caffe-latte'\n *\n * v.slugify('Ñ…Ð¾Ñ€Ð¾ÑˆÐ°Ñ Ð¿Ð¾Ð³Ð¾Ð´Ð°');\n * // => 'horoshaya-pogoda'\n */\nexport default function slugify(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  const cleanSubjectString = latinise(subjectString).replace(REGEXP_NON_LATIN, '-');\n  return kebabCase(cleanSubjectString);\n}\n","import coerceToNumber from 'helper/number/coerce_to_number';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Changes `subject` by deleting `deleteCount` of characters starting at position `start`. Places a new string\n * `toAdd` instead of deleted characters.\n *\n * @function splice\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string where to insert.\n * @param {string} start The position to start changing the string. For a negative position will start from the end of\n * the string.\n * @param {number} [deleteCount=subject.length-start] The number of characters to delete from string.\n * @param {string} [toAdd=''] The string to be added instead of deleted characters.\n * @return {string} Returns the modified string.\n * @example\n * v.splice('new year', 0, 4);\n * // => 'year'\n *\n * v.splice('new year', 0, 3, 'happy');\n * // => 'happy year'\n *\n * v.splice('new year', -4, 4, 'day');\n * // => 'new day'\n */\nexport default function splice(subject, start, deleteCount, toAdd) {\n  const subjectString = coerceToString(subject);\n  const toAddString = coerceToString(toAdd);\n  let startPosition = coerceToNumber(start);\n  if (startPosition < 0) {\n    startPosition = subjectString.length + startPosition;\n    if (startPosition < 0) {\n      startPosition = 0;\n    }\n  } else if (startPosition > subjectString.length) {\n    startPosition = subjectString.length;\n  }\n  let deleteCountNumber = coerceToNumber(deleteCount, subjectString.length - startPosition);\n  if (deleteCountNumber < 0) {\n    deleteCountNumber = 0;\n  }\n  return subjectString.slice(0, startPosition) + toAddString + subjectString.slice(startPosition + deleteCountNumber);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toString from 'helper/string/to_string';\nimport trimLeft from 'manipulate/trim_left';\nimport trimRight from 'manipulate/trim_right';\n\n/**\n * Removes whitespaces from left and right sides of the `subject`.\n *\n * @function trim\n * @static\n * @since 1.0.0\n * @memberOf Manipulate\n * @param {string} [subject=''] The string to trim.\n * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.\n * @return {string} Returns the trimmed string.\n * @example\n * v.trim(' Mother nature ');\n * // => 'Mother nature'\n *\n * v.trim('--Earth--', '-');\n * // => 'Earth'\n */\nexport default function trim(subject, whitespace) {\n  const subjectString = coerceToString(subject);\n  if (whitespace === '' || subjectString === '') {\n    return subjectString;\n  }\n  const whitespaceString = toString(whitespace);\n  if (isNil(whitespaceString)) {\n    return subjectString.trim();\n  }\n  return trimRight(trimLeft(subjectString, whitespaceString), whitespaceString);\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\n\n/**\n * Checks whether `subject` ends with `end`.\n *\n * @function endsWith\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @param {string} end The ending string.\n * @param {number} [position=subject.length] Search within `subject` as if the string were only `position` long.\n * @return {boolean} Returns `true` if `subject` ends with `end` or `false` otherwise.\n * @example\n * v.endsWith('red alert', 'alert');\n * // => true\n *\n * v.endsWith('metro south', 'metro');\n * // => false\n *\n * v.endsWith('Murphy', 'ph', 5);\n * // => true\n */\nexport default function endsWith(subject, end, position) {\n  if (isNil(end)) {\n    return false;\n  }\n  const subjectString = coerceToString(subject);\n  const endString = coerceToString(end);\n  if (endString === '') {\n    return true;\n  }\n  position = isNil(position) ? subjectString.length : clipNumber(toInteger(position), 0, subjectString.length);\n  position -= endString.length;\n  const lastIndex = subjectString.indexOf(endString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_ALPHA_DIGIT } from 'helper/reg_exp/const_extended';\n\n/**\n * Checks whether `subject` contains only alpha and digit characters.\n *\n * @function isAlphaDigit\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` contains only alpha and digit characters or `false` otherwise.\n * @example\n * v.isAlphaDigit('year2020');\n * // => true\n *\n * v.isAlphaDigit('1448');\n * // => true\n *\n * v.isAlphaDigit('40-20');\n * // => false\n */\nexport default function isAlphaDigit(subject) {\n  const subjectString = coerceToString(subject);\n  return REGEXP_ALPHA_DIGIT.test(subjectString);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Checks whether `subject` is empty or contains only whitespaces.\n *\n * @function isBlank\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is empty or contains only whitespaces or `false` otherwise.\n * @example\n * v.isBlank('');\n * // => true\n *\n * v.isBlank('  ');\n * // => true\n *\n * v.isBlank('World');\n * // => false\n */\nexport default function isBlank(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.trim().length === 0;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport { REGEXP_DIGIT } from 'helper/reg_exp/const';\n\n/**\n * Checks whether `subject` contains only digit characters.\n *\n * @function isDigit\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` contains only digit characters or `false` otherwise.\n * @example\n * v.isDigit('35');\n * // => true\n *\n * v.isDigit('1.5');\n * // => false\n *\n * v.isDigit('ten');\n * // => false\n */\nexport default function isDigit(subject) {\n  const subjectString = coerceToString(subject);\n  return REGEXP_DIGIT.test(subjectString);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Checks whether `subject` is empty.\n *\n * @function isEmpty\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is empty or `false` otherwise\n * @example\n * v.isEmpty('');\n * // => true\n *\n * v.isEmpty('  ');\n * // => false\n *\n * v.isEmpty('sun');\n * // => false\n */\nexport default function isEmpty(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.length === 0;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport isAlpha from 'query/is_alpha';\n\n/**\n * Checks whether `subject` has only lower case characters.\n *\n * @function isLowerCase\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is lower case or `false` otherwise.\n * @example\n * v.isLowerCase('motorcycle');\n * // => true\n *\n * v.isLowerCase('John');\n * // => false\n *\n * v.isLowerCase('T1000');\n * // => false\n */\nexport default function isLowerCase(subject) {\n  const valueString = coerceToString(subject);\n  return isAlpha(valueString) && valueString.toLowerCase() === valueString;\n}\n","import isNil from 'helper/object/is_nil';\n\n/**\n * Checks whether `subject` is numeric.\n *\n * @function isNumeric\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is numeric or `false` otherwise.\n * @example\n * v.isNumeric('350');\n * // => true\n *\n * v.isNumeric('-20.5');\n * // => true\n *\n * v.isNumeric('1.5E+2');\n * // => true\n *\n * v.isNumeric('five');\n * // => false\n */\nexport default function isNumeric(subject) {\n  const valueNumeric = typeof subject === 'object' && !isNil(subject) ? Number(subject) : subject;\n  return (\n    (typeof valueNumeric === 'number' || typeof valueNumeric === 'string') &&\n    !isNaN(valueNumeric - parseFloat(valueNumeric))\n  );\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport isAlpha from 'query/is_alpha';\n\n/**\n * Checks whether `subject` contains only upper case characters.\n *\n * @function isUpperCase\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @return {boolean} Returns `true` if `subject` is upper case or `false` otherwise.\n * @example\n * v.isUpperCase('ACDC');\n * // => true\n *\n * v.isUpperCase('Morning');\n * // => false\n */\nexport default function isUpperCase(subject) {\n  const subjectString = coerceToString(subject);\n  return isAlpha(subjectString) && subjectString.toUpperCase() === subjectString;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport toString from 'helper/string/to_string';\n\n/**\n * Checks whether `subject` matches the regular expression `pattern`.\n *\n * @function matches\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @param {RegExp|string} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags)`.\n * @param {string} [flags=''] The regular expression flags. Applies when `pattern` is string type.\n * @return {boolean} Returns `true` if `subject` matches `pattern` or `false` otherwise.\n * @example\n * v.matches('pluto', /plu.{2}/);\n * // => true\n *\n * v.matches('sun', 'S', 'i');\n * // => true\n *\n * v.matches('apollo 11', '\\\\d{3}');\n * // => false\n */\nexport default function matches(subject, pattern, flags) {\n  const subjectString = coerceToString(subject);\n  const flagsString = coerceToString(flags);\n  let patternString;\n  if (!(pattern instanceof RegExp)) {\n    patternString = toString(pattern);\n    if (patternString === null) {\n      return false;\n    }\n    pattern = new RegExp(patternString, flagsString);\n  }\n  return pattern.test(subjectString);\n}\n","import clipNumber from 'helper/number/clip_number';\nimport coerceToString from 'helper/string/coerce_to_string';\nimport isNil from 'helper/object/is_nil';\nimport toInteger from 'helper/number/to_integer';\nimport toString from 'helper/string/to_string';\n\n/**\n * Checks whether `subject` starts with `start`.\n *\n * @function startsWith\n * @static\n * @since 1.0.0\n * @memberOf Query\n * @param {string} [subject=''] The string to verify.\n * @param {string} start The starting string.\n * @param {number} [position=0] The position to start searching.\n * @return {boolean} Returns `true` if `subject` starts with `start` or `false` otherwise.\n * @example\n * v.startsWith('say hello to my little friend', 'say hello');\n * // => true\n *\n * v.startsWith('tony', 'on', 1);\n * // => true\n *\n * v.startsWith('the world is yours', 'world');\n * // => false\n */\nexport default function startsWith(subject, start, position) {\n  const subjectString = coerceToString(subject);\n  const startString = toString(start);\n  if (startString === null) {\n    return false;\n  }\n  if (startString === '') {\n    return true;\n  }\n  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);\n  return subjectString.substr(position, startString.length) === startString;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Splits `subject` into an array of characters.\n *\n * @function chars\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into characters.\n * @return {Array} Returns the array of characters.\n * @example\n * v.chars('cloud');\n * // => ['c', 'l', 'o', 'u', 'd']\n */\nexport default function chars(subject) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split('');\n}\n","import codePointAt from 'chop/code_point_at';\nimport coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Returns an array of Unicode code point values from characters of `subject`.\n *\n * @function codePoints\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param  {string} [subject=''] The string to extract from.\n * @return {Array} Returns an array of non-negative numbers less than or equal to `0x10FFFF`.\n * @example\n * v.codePoints('rain');\n * // => [114, 97, 105, 110], or\n * //    [0x72, 0x61, 0x69, 0x6E]\n *\n * v.codePoints('\\uD83D\\uDE00 smile'); // or 'ðŸ˜€ smile'\n * // => [128512, 32, 115, 109, 105, 108, 101], or\n * //    [0x1F600, 0x20, 0x73, 0x6D, 0x69, 0x6C, 0x65]\n */\nexport default function codePoints(subject) {\n  const subjectString = coerceToString(subject);\n  const subjectStringLength = subjectString.length;\n  const codePointArray = [];\n  let index = 0;\n  let codePointNumber;\n  while (index < subjectStringLength) {\n    codePointNumber = codePointAt(subjectString, index);\n    codePointArray.push(codePointNumber);\n    index += codePointNumber > 0xffff ? 2 : 1;\n  }\n  return codePointArray;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport nilDefault from 'helper/undefined/nil_default';\nimport { REGEXP_UNICODE_CHARACTER } from 'helper/reg_exp/const';\n\n/**\n * Splits `subject` into an array of graphemes taking care of\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#24surrogatepairs\">surrogate pairs</a> and\n * <a href=\"https://rainsoft.io/what-every-javascript-developer-should-know-about-unicode/#25combiningmarks\">combining marks</a>.\n *\n * @function graphemes\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into characters.\n * @return {Array} Returns the array of graphemes.\n * @example\n * v.graphemes('\\uD835\\uDC00\\uD835\\uDC01'); // or 'ð€ð'\n * // => ['\\uD835\\uDC00', '\\uD835\\uDC01'], or\n * //    ['ð€', 'ð']\n *\n * v.graphemes('cafe\\u0301'); // or 'cafeÌ'\n * // => ['c', 'a', 'f', 'e\\u0301'], or\n * //    ['c', 'a', 'f', 'eÌ']\n */\nexport default function graphemes(subject) {\n  const subjectString = coerceToString(subject);\n  return nilDefault(subjectString.match(REGEXP_UNICODE_CHARACTER), []);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\n/**\n * Splits `subject` into an array of chunks by `separator`.\n *\n * @function split\n * @static\n * @since 1.0.0\n * @memberOf Split\n * @param {string} [subject=''] The string to split into characters.\n * @param {string|RegExp} [separator] The pattern to match the separator.\n * @param {number} [limit] Limit the number of chunks to be found.\n * @return {Array} Returns the array of chunks.\n * @example\n * v.split('rage against the dying of the light', ' ');\n * // => ['rage', 'against', 'the', 'dying', 'of', 'the', 'light']\n *\n * v.split('the dying of the light', /\\s/, 3);\n * // => ['the', 'dying', 'of']\n */\nexport default function split(subject, separator, limit) {\n  const subjectString = coerceToString(subject);\n  return subjectString.split(separator, limit);\n}\n","import coerceToString from 'helper/string/coerce_to_string';\n\nconst BYRE_ORDER_MARK = '\\uFEFF';\n\n/**\n * Strips the byte order mark (BOM) from the beginning of `subject`.\n *\n * @function stripBom\n * @static\n * @since 1.2.0\n * @memberOf Strip\n * @param {string} [subject=''] The string to strip from.\n * @return {string} Returns the stripped string.\n * @example\n *\n * v.stripBom('\\uFEFFsummertime sadness');\n * // => 'summertime sadness'\n *\n * v.stripBom('summertime happiness');\n * // => 'summertime happiness'\n *\n */\nexport default function trim(subject) {\n  const subjectString = coerceToString(subject);\n  if (subjectString === '') {\n    return '';\n  }\n  if (subjectString[0] === BYRE_ORDER_MARK) {\n    return subjectString.substring(1);\n  }\n  return subjectString;\n}\n","import coerceToString from 'helper/string/coerce_to_string';\nimport hasSubstringAtIndex from 'helper/string/has_substring_at_index';\nimport parseTagList from 'helper/strip/parse_tag_list';\nimport parseTagName from 'helper/strip/parse_tag_name';\n\nconst STATE_OUTPUT = 0;\nconst STATE_HTML = 1;\nconst STATE_EXCLAMATION = 2;\nconst STATE_COMMENT = 3;\n\n/**\n * Strips HTML tags from `subject`.\n *\n * @function stripTags\n * @static\n * @since 1.1.0\n * @memberOf Strip\n * @param {string} [subject=''] The string to strip from.\n * @param {string|Array} [allowableTags] The string `'<tag1><tag2>'` or array `['tag1', 'tag2']` of tags that should not be stripped.\n * @param {string} [replacement=''] The string to replace the stripped tag.\n * @return {string} Returns the stripped string.\n * @example\n *\n * v.stripTags('<span><a href=\"#\">Summer</a> is nice</span>');\n * // => 'Summer is nice'\n *\n * v.stripTags('<span><i>Winter</i> is <b>cold</b></span>', ['b', 'i']);\n * // => '<i>Winter</i> is <b>cold</b>'\n *\n * v.stripTags('Sun<br/>set', '', '-');\n * // => 'Sun-set'\n */\nexport default function trim(subject, allowableTags, replacement) {\n  subject = coerceToString(subject);\n  if (subject === '') {\n    return '';\n  }\n  if (!Array.isArray(allowableTags)) {\n    const allowableTagsString = coerceToString(allowableTags);\n    allowableTags = allowableTagsString === '' ? [] : parseTagList(allowableTagsString);\n  }\n  const replacementString = coerceToString(replacement);\n  const length = subject.length;\n  const hasAllowableTags = allowableTags.length > 0;\n  const hasSubstring = hasSubstringAtIndex.bind(null, subject);\n  let state = STATE_OUTPUT;\n  let depth = 0;\n  let output = '';\n  let tagContent = '';\n  let quote = null;\n  for (let index = 0; index < length; index++) {\n    const char = subject[index];\n    let advance = false;\n    switch (char) {\n      case '<':\n        if (quote) {\n          break;\n        }\n        if (hasSubstring('< ', index, false)) {\n          advance = true;\n          break;\n        }\n        if (state === STATE_OUTPUT) {\n          advance = true;\n          state = STATE_HTML;\n          break;\n        }\n        if (state === STATE_HTML) {\n          depth++;\n          break;\n        }\n        advance = true;\n        break;\n      case '!':\n        if (state === STATE_HTML && hasSubstring('<!', index)) {\n          state = STATE_EXCLAMATION;\n          break;\n        }\n        advance = true;\n        break;\n      case '-':\n        if (state === STATE_EXCLAMATION && hasSubstring('!--', index)) {\n          state = STATE_COMMENT;\n          break;\n        }\n        advance = true;\n        break;\n      case '\"':\n      case \"'\":\n        if (state === STATE_HTML) {\n          if (quote === char) {\n            quote = null;\n          } else if (!quote) {\n            quote = char;\n          }\n        }\n        advance = true;\n        break;\n      case 'E':\n      case 'e':\n        if (state === STATE_EXCLAMATION && hasSubstring('doctype', index)) {\n          state = STATE_HTML;\n          break;\n        }\n        advance = true;\n        break;\n      case '>':\n        if (depth > 0) {\n          depth--;\n          break;\n        }\n        if (quote) {\n          break;\n        }\n        if (state === STATE_HTML) {\n          quote = null;\n          state = STATE_OUTPUT;\n          if (hasAllowableTags) {\n            tagContent += '>';\n            const tagName = parseTagName(tagContent);\n            if (allowableTags.indexOf(tagName.toLowerCase()) !== -1) {\n              output += tagContent;\n            } else {\n              output += replacementString;\n            }\n            tagContent = '';\n          } else {\n            output += replacementString;\n          }\n          break;\n        }\n        if (state === STATE_EXCLAMATION || (state === STATE_COMMENT && hasSubstring('-->', index))) {\n          quote = null;\n          state = STATE_OUTPUT;\n          tagContent = '';\n          break;\n        }\n        advance = true;\n        break;\n      default:\n        advance = true;\n    }\n    if (advance) {\n      switch (state) {\n        case STATE_OUTPUT:\n          output += char;\n          break;\n        case STATE_HTML:\n          if (hasAllowableTags) {\n            tagContent += char;\n          }\n          break;\n      }\n    }\n  }\n  return output;\n}\n","import { REGEXP_TAG_LIST } from 'helper/reg_exp/const';\n\n/**\n * Parses the tags from the string '<tag1><tag2>...<tagN>'.\n *\n * @ignore\n * @param {string} tags The string that contains the tags.\n * @return {string[]} Returns the array of tag names.\n */\nexport default function parseTagList(tags) {\n  const tagsList = [];\n  let match;\n  while ((match = REGEXP_TAG_LIST.exec(tags)) !== null) {\n    tagsList.push(match[1]);\n  }\n  return tagsList;\n}\n","/**\n * Checks whether `subject` contains substring at specific `index`.\n *\n * @ignore\n * @param {string} subject The subject to search in.\n * @param {string} substring The substring to search/\n * @param {number} index The index to search substring.\n * @param {boolean} lookBehind Whether to look behind (true) or ahead (false).\n * @return {boolean} Returns a boolean whether the substring exists.\n */\nexport default function hasSubstringAtIndex(subject, substring, index, lookBehind = true) {\n  let indexOffset = 0;\n  if (lookBehind) {\n    indexOffset = -substring.length + 1;\n  }\n  const extractedSubstring = subject.substr(index + indexOffset, substring.length);\n  return extractedSubstring.toLowerCase() === substring;\n}\n","import functions from 'functions';\n\n/**\n * The chain wrapper constructor.\n *\n * @ignore\n * @param  {string}       subject               The string to be wrapped.\n * @param  {boolean}      [explicitChain=false] A boolean that indicates if the chain sequence is explicit or implicit.\n * @return {ChainWrapper}                       Returns a new instance of `ChainWrapper`\n * @constructor\n */\nfunction ChainWrapper(subject, explicitChain) {\n  this._wrappedValue = subject;\n  this._explicitChain = explicitChain;\n}\n\n/**\n * Unwraps the chain sequence wrapped value.\n *\n * @memberof Chain\n * @since 1.0.0\n * @function __proto__value\n * @return {*} Returns the unwrapped value.\n * @example\n * v\n *  .chain('Hello world')\n *  .replace('Hello', 'Hi')\n *  .lowerCase()\n *  .slugify()\n *  .value()\n * // => 'hi-world'\n *\n * v(' Space travel ')\n *  .trim()\n *  .truncate(8)\n *  .value()\n * // => 'Space...'\n */\nChainWrapper.prototype.value = function() {\n  return this._wrappedValue;\n};\n\n/**\n * Override the default object valueOf().\n *\n * @ignore\n * @return {*} Returns the wrapped value.\n */\nChainWrapper.prototype.valueOf = function() {\n  return this.value();\n};\n\n/**\n * Returns the wrapped value to be used in JSON.stringify().\n *\n * @ignore\n * @return {*} Returns the wrapped value.\n */\nChainWrapper.prototype.toJSON = function() {\n  return this.value();\n};\n\n/**\n * Returns the string representation of the wrapped value.\n *\n * @ignore\n * @return {string} Returns the string representation.\n */\nChainWrapper.prototype.toString = function() {\n  return String(this.value());\n};\n\n/**\n * Creates a new chain object that enables <i>explicit</i> chain sequences.\n * Use `v.prototype.value()` to unwrap the result. <br/>\n * Does not modify the wrapped value.\n *\n * @memberof Chain\n * @since 1.0.0\n * @function __proto__chain\n * @return {Object} Returns the wrapper in <i>explicit</i> mode.\n * @example\n * v('Back to School')\n *  .chain()\n *  .lowerCase()\n *  .words()\n *  .value()\n * // => ['back', 'to', 'school']\n *\n * v(\" Back to School \")\n *  .chain()\n *  .trim()\n *  .truncate(7)\n *  .value()\n * // => 'Back...'\n */\nChainWrapper.prototype.chain = function() {\n  return new ChainWrapper(this._wrappedValue, true);\n};\n\n/**\n * Modifies the wrapped value with the invocation result of `changer` function. The current wrapped value is the\n * argument of `changer` invocation.\n *\n * @memberof Chain\n * @since 1.0.0\n * @function __proto__thru\n * @param  {Function} changer The function to invoke.\n * @return {Object}           Returns the new wrapper that wraps the invocation result of `changer`.\n * @example\n * v\n *  .chain('sun is shining')\n *  .words()\n *  .thru(function(words) {\n *    return words[0];\n *  })\n *  .value()\n * // => 'sun'\n *\n */\nChainWrapper.prototype.thru = function(changer) {\n  if (typeof changer === 'function') {\n    return new ChainWrapper(changer(this._wrappedValue), this._explicitChain);\n  }\n  return this;\n};\n\n/**\n * A boolean that indicates if the chain sequence is explicit or implicit.\n * @ignore\n * @type {boolean}\n * @private\n */\nChainWrapper.prototype._explicitChain = true;\n\n/**\n * Make a voca function chainable.\n *\n * @ignore\n * @param  {Function} functionInstance The function to make chainable\n * @return {Function}                  Returns the chainable function\n */\nfunction makeFunctionChainable(functionInstance) {\n  return function(...args) {\n    const result = functionInstance(this._wrappedValue, ...args);\n    if (this._explicitChain || typeof result === 'string') {\n      return new ChainWrapper(result, this._explicitChain);\n    } else {\n      return result;\n    }\n  };\n}\n\nObject.keys(functions).forEach(function(name) {\n  ChainWrapper.prototype[name] = makeFunctionChainable(functions[name]);\n});\n\nexport default ChainWrapper;\n","import chain from './chain/chain'; // include chain here to resolve af circular reference\nimport ChainWrapper from './chain/wrapper';\nimport functions from './functions';\n\n/**\n * Creates a chain object that wraps `subject`, enabling <i>implicit</i> chain sequences.<br/>\n * A function that returns `number`, `boolean` or `array` type <i>terminates</i> the chain sequence and returns the unwrapped value.\n * Otherwise use `v.prototype.value()` to unwrap the result.\n *\n * @memberOf Chain\n * @since 1.0.0\n * @function v\n * @param {string} subject The string to wrap.\n * @return {Object}  Returns the new wrapper object.\n * @example\n * v('Back to School')\n *  .lowerCase()\n *  .words()\n * // => ['back', 'to', 'school']\n *\n * v(\" Back to School \")\n *  .trim()\n *  .truncate(7)\n *  .value()\n * // => 'Back...'\n */\nfunction Voca(subject) {\n  return new ChainWrapper(subject, false);\n}\n\nObject.assign(Voca, functions, {\n  chain: chain,\n});\n\nexport default Voca;\n","import ChainWrapper from 'chain/wrapper';\n\n/**\n * Creates a chain object that wraps `subject`, enabling <i>explicit</i> chain sequences. <br/>\n * Use `v.prototype.value()` to unwrap the result.\n *\n * @memberOf Chain\n * @since 1.0.0\n * @function chain\n * @param  {string} subject The string to wrap.\n * @return {Object}         Returns the new wrapper object.\n * @example\n * v\n *  .chain('Back to School')\n *  .lowerCase()\n *  .words()\n *  .value()\n * // => ['back', 'to', 'school']\n */\nexport default function chain(subject) {\n  return new ChainWrapper(subject, true);\n}\n"],"names":["isNil","value","coerceToBoolean","defaultValue","Boolean","isString","subject","coerceToString","String","capitalize","restToLower","subjectString","restToLowerCaseBoolean","toLowerCase","substr","toUpperCase","lowerCase","digit","whitespace","highSurrogate","lowSurrogate","diacriticalMark","base","REGEXP_COMBINING_MARKS","RegExp","REGEXP_SURROGATE_PAIRS","REGEXP_UNICODE_CHARACTER","REGEXP_WHITESPACE","REGEXP_TRIM_LEFT","REGEXP_TRIM_RIGHT","REGEXP_DIGIT","REGEXP_SPECIAL_CHARACTERS","REGEXP_NON_LATIN","REGEXP_HTML_SPECIAL_CHARACTERS","REGEXP_CONVERSION_SPECIFICATION","REGEXP_TRAILING_ZEROS","REGEXP_TAG_LIST","lowerCaseLetter","upperCaseLetter","REGEXP_WORD","REGEXP_LATIN_WORD","REGEXP_ALPHA","REGEXP_ALPHA_DIGIT","REGEXP_EXTENDED_ASCII","nilDefault","toString","words","pattern","flags","patternRegExp","test","flagsString","match","wordToCamel","word","index","kebabCase","map","join","swapAndConcat","swapped","character","upperCase","clipNumber","downLimit","upLimit","MAX_SAFE_INTEGER","toInteger","Infinity","truncate","length","end","lengthInt","endString","HIGH_SURROGATE_START","HIGH_SURROGATE_END","LOW_SURROGATE_START","LOW_SURROGATE_END","coerceToNumber","Number","nanDefault","codePointAt","position","subjectStringLength","positionNumber","secondCodePoint","codePoint","firstCodePoint","charCodeAt","reduce","Array","prototype","ReplacementIndex","increment","incrementOnEmptyPosition","getIndexByPosition","this","TYPE_INTEGER","TYPE_INTEGER_BINARY","TYPE_INTEGER_ASCII_CHARACTER","TYPE_INTEGER_DECIMAL","TYPE_INTEGER_OCTAL","TYPE_INTEGER_UNSIGNED_DECIMAL","TYPE_INTEGER_HEXADECIMAL","TYPE_INTEGER_HEXADECIMAL_UPPERCASE","TYPE_FLOAT_SCIENTIFIC","TYPE_FLOAT_SCIENTIFIC_UPPERCASE","TYPE_FLOAT","TYPE_FLOAT_SHORT","TYPE_FLOAT_SHORT_UPPERCASE","TYPE_STRING","LITERAL_PLUS","LITERAL_MINUS","RADIX_BINARY","RADIX_OCTAL","RADIX_HEXADECIMAL","repeat","times","timesInt","repeatString","buildPadding","padCharacters","padLeft","pad","padString","padRight","addSignToFormattedNumber","replacementNumber","formattedReplacement","conversion","signSpecifier","float","replacement","parseFloat","isNaN","precision","typeSpecifier","toFixed","toExponential","nonZeroPrecision","toPrecision","replace","formatFloatAsShort","integerBase","integer","parseInt","fromCharCode","integerDecimal","stringFormat","compute","formatFunction","formatString","formatIntegerDecimal","formatIntegerBase","formatFloat","width","formattedString","alignmentSpecifier","getPaddingCharacter","ConversionSpecification","properties","percent","paddingSpecifier","replacementIndex","replacements","conversionSpecification","widthSpecifier","precisionSpecifier","isPercentLiteral","slice","actualReplacementIndex","replacementsLength","Error","validateReplacement","computeReplacement","sprintf","format","boundReplacementMatch","replacementMatch","bind","undefined","paddingCharacter","escapeCharactersMap","replaceSpecialCharacter","unescapeCharactersMap","characters","Object","keys","reduceUnescapedString","string","key","diacritics","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","OE","oe","AE","ae","hv","OI","oi","DZ","Dz","dz","LJ","Lj","lj","NJ","Nj","nj","OU","ou","TH","th","PS","ps","Yo","Ye","Yi","Zh","Ch","Sh","Yu","Ya","zh","ch","sh","yu","ya","yo","ye","yi","diacriticsMap","getLatinCharacter","characterWithoutDiacritic","forEach","removeCombiningMarks","cleanCharacter","latinise","sortStringByLength","str1","str2","includes","search","searchString","indexOf","trimLeft","whitespaceString","matchWhitespace","call","trimmed","reduceRight","trimRight","OPTION_WIDTH","OPTION_NEW_LINE","OPTION_INDENT","OPTION_CUT","isAlpha","STATE_START_TAG","STATE_NON_WHITESPACE","STATE_DONE","parseTagName","tagContent","state","tagName","char","globalObject","global","self","Function","previousV","camelCase","decapitalize","snakeCase","swapCase","split","titleCase","noSplit","noSplitArray","isArray","wordsRegExp","count","countGraphemes","countSubstrings","substring","substringString","substringLength","matchIndex","countWhere","predicate","context","predicateWithContext","countTruthy","countWords","escapeHtml","escapeRegExp","unescapeHtml","vprintf","fromIndex","lastIndexOf","fromIndexNumber","charAt","first","graphemeAt","graphemeMatch","graphemeMatchIndex","exec","lastIndex","last","prune","truncatedLength","offset","wordInsertLength","start","insert","toInsert","toInsertString","paddingLength","paddingSideLength","paddingSideRemainingLength","replaceAll","TypeError","isFunctionalReplace","searchLength","advanceBy","matchPositions","push","endOfLastMatch","result","reverse","reverseGrapheme","reversedString","$0","$1","$2","slugify","splice","deleteCount","toAdd","toAddString","startPosition","deleteCountNumber","tr","from","to","values","object","sort","keysLength","valuesLength","isMatch","matchValue","keyIndex","trim","wordWrap","options","newLine","indent","cut","subjectLength","wrappedLine","spaceToWrapAt","endsWith","isAlphaDigit","isBlank","isDigit","isEmpty","isLowerCase","valueString","isNumeric","valueNumeric","isUpperCase","matches","patternString","startsWith","startString","chars","codePoints","codePointNumber","codePointArray","graphemes","separator","limit","stripBom","stripTags","allowableTags","allowableTagsString","tags","tagsList","parseTagList","replacementString","hasAllowableTags","hasSubstring","indexOffset","depth","output","quote","advance","noConflict","version","ChainWrapper","explicitChain","_wrappedValue","_explicitChain","Voca","valueOf","toJSON","chain","thru","changer","functions","name","functionInstance","args","_extends"],"mappings":";;;;;;;itCAQe,SAASA,EAAMC,UACrBA,MAAAA,ECEM,SAASC,EAAgBD,EAAzB,OAAgCE,+BAAhC,GAAA,SACTH,EAAMC,GACDE,EAEFC,QAAQH,GCCF,SAASI,EAASC,SACL,iBAAZA,ECFD,SAASC,EAAeN,EAAxB,OAA+BE,+BAA/B,EAAA,EAA8C,UACvDH,EAAMC,GACDE,EAELE,EAASJ,GACJA,EAEFO,OAAOP,GCDD,SAASQ,EAAWH,EAASI,OACtCC,EAAgBJ,EAAeD,GAC7BM,EAAyBV,EAAgBQ,SACzB,KAAlBC,EACK,IAELC,IACFD,EAAgBA,EAAcE,eAEzBF,EAAcG,OAAO,EAAG,GAAGC,cAAgBJ,EAAcG,OAAO,ICZ1D,SAASE,EAAUV,UACVC,EAAeD,EAAS,IACzBO,cCdhB,IAAMI,EAAQ,MAQRC,EAAa,kBAQbC,EAAgB,kBAQhBC,EAAe,kBAQfC,EAAkB,8EAQlBC,EACX,wGASWC,EAAyB,IAAIC,OACxC,KACEF,EACA,MACAH,EACA,KACAC,EACA,MACAD,EACA,QACAC,EACA,WACAD,EACA,QACAC,EACA,OACAC,EACA,MACF,KAUWI,EAAyB,IAAID,OAAO,KAAOL,EAAgB,OAASC,EAAe,KAAM,KAQzFM,EAA2B,IAAIF,OAC1C,QACEF,EACA,MACAH,EACA,KACAC,EACA,MACAD,EACA,QACAC,EACA,WACAD,EACA,QACAC,EACA,SACAC,EACA,UAEAF,EACA,KACAC,EACA,kCAGF,KASWO,EAAoB,IAAIH,OAAO,IAAMN,EAAa,KAQlDU,EAAmB,IAAIJ,OAAO,KAAON,EAAa,MAQlDW,EAAoB,IAAIL,OAAO,IAAMN,EAAa,OAQlDY,EAAe,IAAIN,OAAO,UAQ1BO,EAA4B,8BAQ5BC,EAAmB,gBAQnBC,EAAiC,YAQjCC,EAAkC,mFAQlCC,EAAwB,UAkBxBC,EAAkB,oBChLzBC,EACJ,olCAQIC,EACJ,wpCAQWC,EAAc,IAAIf,OAC7B,OACEc,EACA,KACAjB,EACA,WACAgB,EACA,KACAhB,EACA,YAEAiB,EACA,KACAjB,EACA,WACAgB,EACA,OAEApB,EACA,+FAOAC,EACA,KACF,KASWsB,EAAoB,4GASpBC,EAAe,IAAIjB,OAAO,QAAUa,EAAkBC,EAAkB,KAAOjB,EAAkB,SASjGqB,EAAqB,IAAIlB,OACpC,SAAWa,EAAkBC,EAAkB,KAAOjB,EAAkB,QAAUJ,EAAQ,QAS/E0B,EAAwB,iBC1GtB,SAASC,EAAW3C,EAAOE,UACxB,MAATF,EAAgBE,EAAeF,ECEzB,SAAS4C,EAAS5C,UAC3BD,EAAMC,GACD,KAELI,EAASJ,GACJA,EAEFO,OAAOP,GCWD,SAAS6C,EAAMxC,EAASyC,EAASC,OAE1CC,EADEtC,EAAgBJ,EAAeD,MAEjCN,EAAM+C,GACRE,EAAgBN,EAAsBO,KAAKvC,GAAiB6B,EAAoBD,OAC3E,GAAIQ,aAAmBvB,OAC5ByB,EAAgBF,MACX,KACCI,EAAcN,EAASD,EAAWI,EAAO,KAC/CC,EAAgB,IAAIzB,OAAOqB,EAASE,GAAUI,UAEzCP,EAAWjC,EAAcyC,MAAMH,GAAgB,IC5BxD,SAASI,EAAYC,EAAMC,UACR,IAAVA,EAAcvC,EAAUsC,GAAQ7C,EAAW6C,GAAM,GCU3C,SAASE,EAAUlD,OAC1BK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAEFmC,EAAMnC,GACV8C,IAAIzC,GACJ0C,KAAK,KCPV,SAASC,EAAcC,EAASC,OACxB7C,EAAY6C,EAAUhD,cACtBiD,EAAYD,EAAU9C,qBACrB6C,GAAWC,IAAc7C,EAAY8C,EAAY9C,GCjB3C,SAAS+C,EAAW9D,EAAO+D,EAAWC,UAC/ChE,GAAS+D,EACJA,EAEIC,GAAThE,EACKgE,EAEFhE,ECXF,IAAMiE,EAAmB,iBCIjB,SAASC,EAAUlE,UAC5BA,IAAUmE,EAAAA,EACLF,EAELjE,KAAWmE,EAAAA,GACLF,IAEDjE,ECUI,SAASoE,EAAS/D,EAASgE,EAAQC,OAC1C5D,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU3D,EAAc2D,OAASP,EAAWI,EAAUG,GAAS,EAAGJ,GACpFO,EAAYlE,EAAegE,EAAK,cAClCC,GAAa7D,EAAc2D,OACtB3D,EAEFA,EAAcG,OAAO,EAAGwD,EAASG,EAAUH,QAAUG,EClC9D,IAAMC,EAAuB,MACvBC,EAAqB,MACrBC,EAAsB,MACtBC,EAAoB,MCWX,SAASC,EAAe7E,EAAxB,OAA+BE,+BAA/B,EAAA,EAA8C,SACvDH,EAAMC,GACDE,EAEY,iBAAVF,EACFA,EAEF8E,OAAO9E,GCZD,SAAS+E,EAAW/E,EAAOE,UACjCF,GAAUA,EAAQE,EAAeF,ECgB3B,SAASgF,EAAY3E,EAAS4E,OACrCvE,EAAgBJ,EAAeD,GAC/B6E,EAAsBxE,EAAc2D,OACtCc,EAAiBN,EAAeI,SACpCE,EAAiBJ,EAAWI,EAAgB,IACvB,GAAuBD,GAAlBC,QAItBC,EHZyBC,EAXCA,EGsBxBC,EAAiB5E,EAAc6E,WAAWJ,UHrB5BV,IADUY,EGwBVC,IHvBwBD,GAAaX,GGuBIS,EAAiB,EAAvCD,IACrCE,EAAkB1E,EAAc6E,WAAWJ,EAAiB,GHb1CR,IADSU,EGeRD,IHdsBC,GAAaT,GAYR,MGGJU,EHHpBb,GGGoCW,EHHWT,EAAsB,MGMtFW,OCxCHE,EAASC,MAAMC,UAAUF,OCQ/B,SAASG,SACFrC,MAAQ,EASfqC,EAAiBD,UAAUE,UAAY,gBAChCtC,SAUPqC,EAAiBD,UAAUG,yBAA2B,SAASZ,GACzDlF,EAAMkF,SACHW,aAWTD,EAAiBD,UAAUI,mBAAqB,SAASb,UAChDlF,EAAMkF,GAAYc,KAAKzC,MAAQ2B,EAAW,GC5C5C,IAAMe,GAAe,IACfC,GAAsB,IACtBC,GAA+B,IAC/BC,GAAuB,IACvBC,GAAqB,IACrBC,GAAgC,IAChCC,GAA2B,IAC3BC,GAAqC,IACrCC,GAAwB,IACxBC,GAAkC,IAClCC,GAAa,IACbC,GAAmB,IACnBC,GAA6B,IAC7BC,GAAc,IAKdC,GAAe,IACfC,GAAgB,IAIhBC,GAAe,EACfC,GAAc,EAEdC,GAAoB,GCJlB,SAASC,GAAO9G,EAAS+G,WAClC1G,EAAgBJ,EAAeD,GAC/BgH,EAAWtH,EAAMqH,GAAS,EAAItD,EAAWI,EAAUkD,GAAQ,EAAGnD,GAC9DqD,EAAe,GACZD,GACU,EAAXA,IACFC,GAAgB5G,GAEH,EAAX2G,IACF3G,GAAiBA,GAEnB2G,IAAa,SAERC,ECzBM,SAASC,GAAaC,EAAenD,UAG3C8C,GAAOK,EAFUtD,EAAUG,EAASmD,EAAcnD,QACnCA,EAASmD,EAAcnD,QACiBxD,OAAO,EAAGwD,GCc3D,SAASoD,GAAQpH,EAASgE,EAAQqD,OACzChH,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU,EAAIP,EAAWI,EAAUG,GAAS,EAAGJ,GACjE0D,EAAYrH,EAAeoH,EAAK,YAClCnD,GAAa7D,EAAc2D,OACtB3D,EAEF6G,GAAaI,EAAWpD,EAAY7D,EAAc2D,QAAU3D,ECPtD,SAASkH,GAASvH,EAASgE,EAAQqD,OAC1ChH,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU,EAAIP,EAAWI,EAAUG,GAAS,EAAGJ,GACjE0D,EAAYrH,EAAeoH,EAAK,YAClCnD,GAAa7D,EAAc2D,OACtB3D,EAEFA,EAAgB6G,GAAaI,EAAWpD,EAAY7D,EAAc2D,QCvB5D,SAASwD,GAAyBC,EAAmBC,EAAsBC,UACpFA,EAAWC,gBAAkBnB,IAAqC,GAArBgB,IAC/CC,EAAuBjB,GAAeiB,GAEjCA,ECKM,SAASG,GAAMC,EAAaH,OAErCD,EADAD,EAAoBM,WAAWD,GAE/BE,MAAMP,KACRA,EAAoB,OAEhBQ,EAAYzD,EAAemD,EAAWM,UAAW,UAC/CN,EAAWO,oBACZ7B,GACHqB,EAAuBD,EAAkBU,QAAQF,cAE9C9B,GACHuB,EAAuBD,EAAkBW,cAAcH,cAEpD7B,GACHsB,EAAuBD,EAAkBW,cAAcH,GAAWxH,yBAE/D6F,QACAC,GACHmB,EAgBN,SAA4BD,EAAmBQ,EAAWN,MAC9B,IAAtBF,QACK,QAEHY,EAAiC,IAAdJ,EAAkB,EAAIA,EAC3CP,EAAuBD,EAAkBa,YAAYD,GAAkBE,QAAQ1G,EAAuB,IACtG8F,EAAWO,gBAAkB3B,KAC/BmB,EAAuBA,EAAqBjH,sBAEvCiH,EAzBoBc,CAAmBf,EAAmBQ,EAAWN,UAIrEpF,EADPmF,EAAuBF,GAAyBC,EAAmBC,EAAsBC,ICtB5E,SAASc,GAAYX,EAAaH,OAC3Ce,EAAUC,SAASb,UACnBE,MAAMU,KACRA,EAAU,GAEZA,KAAsB,EACdf,EAAWO,oBACZrC,GACH6C,EAAUxI,OAAO0I,aAAaF,cAE3B9C,GACH8C,EAAUA,EAAQnG,SAASoE,eAExBZ,GACH2C,EAAUA,EAAQnG,SAASqE,eAExBX,GACHyC,EAAUA,EAAQnG,SAASsE,eAExBX,GACHwC,EAAUA,EAAQnG,SAASsE,IAAmBpG,qBAG3C8B,EAASmG,GChCH,SAASG,GAAef,EAAaH,OAC9Ce,EAAUC,SAASb,UACnBE,MAAMU,KACRA,EAAU,GAELlB,GAAyBkB,EAASnG,EAASmG,GAAUf,GCN/C,SAASmB,GAAahB,EAAaH,OAC5CD,EAAuBI,EACrBG,EAAYN,EAAWM,iBACxBvI,EAAMuI,IAAcP,EAAqB1D,OAASiE,IACrDP,EAAuB3D,EAAS2D,EAAsBO,EAAW,KAE5DP,ECcM,SAASqB,GAAQjB,EAAaH,OACvCqB,SACIrB,EAAWO,oBACZ1B,GACHwC,EAAiBC,cAEdnD,QACAH,GACHqD,EAAiBE,cAEdrD,QACAD,QACAG,QACAE,QACAC,QACAF,GACHgD,EAAiBG,cAEd9C,QACAF,QACAC,QACAE,QACAC,GACHyC,EAAiBI,OCzCapJ,EAAS2H,EACrC0B,ED2CAC,EAAkBN,EAAelB,EAAaH,UC5ClB3H,ED6CfsJ,EC3Cf5J,EADE2J,GADqC1B,ED6CPA,GC5CX0B,QACLrJ,EAAQgE,QAAUqF,EAC7BrJ,GAEO2H,EAAW4B,qBAAuB7C,GAAgBa,GAAWH,IAC9DpH,EAASqJ,EAAO1B,EAAW6B,uBCT5C,SAASC,GAAwBC,QAQ1BC,QAAUD,EAAWC,aASrB/B,cAAgB8B,EAAW9B,mBAS3BgC,iBAAmBF,EAAWE,sBAS9BL,mBAAqBG,EAAWH,wBAShCF,MAAQK,EAAWL,WASnBpB,UAAYyB,EAAWzB,eASvBC,cAAgBwB,EAAWxB,cCjDnB,SAASpF,GACtB+G,EACAC,EACAC,EACAJ,EACA/E,EACAgD,EACAgC,EACAL,EACAS,EACAC,EACA/B,OAEMP,EAAa,IAAI8B,GAAwB,CAC7CE,QAAAA,EACA/B,cAAAA,EACAgC,iBAAAA,EACAL,mBAAAA,EACAF,MAAO7E,EAAewF,EAAgB,MACtC/B,UAAWzD,EAAeyF,EAAoB,MAC9C/B,cAAAA,OAEEP,EAAWuC,0BACNH,EAAwBI,MAAM,OAEjCC,EAAyBP,EAAiBpE,mBAAmBb,UACnEiF,EAAiBrE,yBAAyBZ,GCrC7B,SAAkB3B,EAAOoH,EAAoB1C,MACtDjI,EAAMiI,EAAWO,qBACb,IAAIoC,MAAM,wCAEND,EAAqB,EAA7BpH,QACI,IAAIqH,MAAM,mCAEdrH,EAAQ,QACJ,IAAIqH,MAAM,wDD8BlBC,CAAoBH,EAAwBN,EAAa9F,OAAQ2D,GAC1D6C,GAAmBV,EAAaM,GAAyBzC,GEgInD,SAAS8C,GAAQC,OACxBzB,EAAehJ,EAAeyK,MACf,KAAjBzB,SACKA,6BAHgCa,mCAAAA,wBAKnCa,EAAwBC,GAAiBC,UAAKC,EAAW,IAAIxF,EAAoBwE,UAChFb,EAAaV,QAAQ3G,EAAiC+I,GHxG/DlB,GAAwBpE,UAAU6E,iBAAmB,iBZ5DZ,OY6DFxE,KAAKiE,SAS5CF,GAAwBpE,UAAUmE,oBAAsB,eAClDuB,EAAmBzI,EAAWoD,KAAKkE,iBAAkB,YACzB,IAA5BmB,EAAiB/G,QZ3Ea,MY2EG+G,EAAiB,KACpDA,EAAmBA,EAAiB,IAE/BA,OI7FHC,GAAsB,KACrB,WACA,WACA,YACA,aACA,aACA,UAUP,SAASC,GAAwB1H,UACxByH,GAAoBzH,OClBvB2H,GAAwB,KACvB,oCACA,oCACA,qCACA,sCACA,6BACA,0BAEDC,GAAaC,OAAOC,KAAKH,IAU/B,SAASI,GAAsBC,EAAQC,UAC9BD,EAAOhD,QAAQ2C,GAAsBM,GAAMA,GCfpD,IAAMC,GAAa,GACZ,OACA,KACLC,EAAG,wBACHC,EAAG,SACHC,EAAG,YACHC,EAAG,YACHC,EAAG,sBACHC,EAAG,OACHC,EAAG,eACHC,EAAG,UACHC,EAAG,sBACHC,EAAG,OACHC,EAAG,SACHC,EAAG,YACHC,EAAG,OACHC,EAAG,aACHC,EACE,6BACFC,EAAG,OACHC,EAAG,KACHC,EAAG,YACHC,EAAG,WACHC,EAAG,aACHC,EACE,yBACFC,EAAG,OACHC,EAAG,OACHC,EAAG,KACHC,EAAG,cACHC,EAAG,WACHC,EAAG,wBACHC,EAAG,SACHC,EAAG,YACHC,EAAG,YACHC,EAAG,uBACHC,EAAG,OACHC,EAAG,eACHC,EAAG,WACHC,EAAG,uBACHC,EAAG,QACHC,EAAG,SACHC,EAAG,cACHC,EAAG,QACHC,EAAG,cACHC,EACE,6BACFC,EAAG,OACHC,EAAG,KACHC,EAAG,aACHC,EAAG,cACHC,EAAG,YACHC,EACE,yBACFC,EAAG,OACHC,EAAG,OACHC,EAAG,KACHC,EAAG,eACHC,EAAG,YACHC,GAAI,KACJC,GAAI,KACJC,GAAI,MACJC,GAAI,MACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,KACJC,GAAI,KACJC,GAAI,KACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,QACA,MACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,KACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,KAGFC,GAAgB,KA8Bb,SAASC,GAAkB9N,OAC1B+N,GAtBgB,OAAlBF,KAGJA,GAAgB,GAChBhG,OAAOC,KAAKI,IAAY8F,QAAQ,SAAS/F,WACjCL,EAAaM,GAAWD,GACrBvI,EAAQ,EAAGA,EAAQkI,EAAWnH,OAAQf,IAAS,KAChDM,EAAY4H,EAAWlI,GAC7BmO,GAAc7N,GAAaiI,MAPtB4F,IAqB4C7N,UAC9C+N,GAAwD/N,EC9HjE,SAASiO,GAAqBjO,EAAWkO,UAChCA,EAsBM,SAASC,GAAS1R,OACzBK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAEFA,EACJkI,QAAQ7G,EAAkB2P,IAC1B9I,QAAQtH,EAAwBuQ,ICkCrC,SAASG,GAAmBC,EAAMC,UAC5BD,EAAK5N,SAAW6N,EAAK7N,OAChB,EAEF4N,EAAK5N,OAAS6N,EAAK7N,OAAS,GAAK,ECxD3B,SAAS8N,GAAS9R,EAAS+R,EAAQnN,OAC1CvE,EAAgBJ,EAAeD,GAC/BgS,EAAezP,EAASwP,UACT,OAAjBC,IAGiB,KAAjBA,IAGJpN,EAAWlF,EAAMkF,GAAY,EAAInB,EAAWI,EAAUe,GAAW,EAAGvE,EAAc2D,SACxB,IAAnD3D,EAAc4R,QAAQD,EAAcpN,SC5BvCO,GAASC,MAAMC,UAAUF,OAmBhB,SAAS+M,GAASlS,EAASY,OAClCP,EAAgBJ,EAAeD,MAClB,KAAfY,GAAuC,KAAlBP,SAChBA,MAEH8R,EAAmB5P,EAAS3B,MAC9BlB,EAAMyS,UACD9R,EAAckI,QAAQjH,EAAkB,QAE7C8Q,GAAkB,SACfjN,GAAOkN,KACZhS,EACA,SAASiS,EAAS/O,UACZ6O,GAAmBN,GAASK,EAAkB5O,GACzC+O,GAETF,GAAkB,EACXE,EAAU/O,IAEnB,QCtCEgP,GAAcnN,MAAMC,UAAUkN,YAmBrB,SAASC,GAAUxS,EAASY,OACnCP,EAAgBJ,EAAeD,MAClB,KAAfY,GAAuC,KAAlBP,SAChBA,MAEH8R,EAAmB5P,EAAS3B,MAC9BlB,EAAMyS,UACD9R,EAAckI,QAAQhH,EAAmB,QAE9C6Q,GAAkB,SACfG,GAAYF,KACjBhS,EACA,SAASiS,EAAS/O,UACZ6O,GAAmBN,GAASK,EAAkB5O,GACzC+O,GAETF,GAAkB,EACX7O,EAAY+O,IAErB,ICxCJ,IAAMG,GAAe,QACfC,GAAkB,UAClBC,GAAgB,SAChBC,GAAa,MCeJ,SAASC,GAAQ7S,OACxBK,EAAgBJ,EAAeD,UAC9BmC,EAAaS,KAAKvC,GCtB3B,IAAMyS,GAAkB,EAClBC,GAAuB,EACvBC,GAAa,EASJ,SAASC,GAAaC,WAC/BC,EAAQL,GACRM,EAAU,GACVnQ,EAAQ,EACLkQ,IAAUH,IAAY,KACrBK,EAAOH,EAAWjQ,KAAS1C,qBACzB8S,OACD,cAEA,IACHF,EAAQH,iBAGJ3R,EAAkBuB,KAAKyQ,GACrBF,IAAUJ,KACZI,EAAQH,KAGNG,IAAUL,KACZK,EAAQJ,IAEG,MAATM,IACFD,GAAWC,YAMdD,ECzCT,IAAIE,GAAe,KCEnB,IAAMA,GDCiB,OAAjBA,GACKA,GAMPA,GAFoB,iBAAXC,QAAuBA,OAAOnI,SAAWA,OAEnCmI,OACU,iBAATC,MAAqBA,KAAKpI,SAAWA,OAEtCoI,KAGA,IAAIC,SAAS,cAAb,GCbbC,GAAYJ,GAAa7E,ECQ/B,OC0He,CACbkF,U3ClGa,SAAmB3T,OAC1BK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAEFmC,EAAMnC,GACV8C,IAAIJ,GACJK,KAAK,K2C4FRjD,WAAAA,EACAyT,aCtHa,SAAsB5T,OAC7BK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAEFA,EAAcG,OAAO,EAAG,GAAGD,cAAgBF,EAAcG,OAAO,IDkHvE0C,UAAAA,EACAxC,UAAAA,EACAmT,UEpHa,SAAmB7T,OAC1BK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAEFmC,EAAMnC,GACV8C,IAAIzC,GACJ0C,KAAK,MF8GR0Q,SzCzHa,SAAkB9T,UACTC,EAAeD,GAChB+T,MAAM,IAAI5O,OAAO9B,EAAe,KyCwHrD2Q,UGxHa,SAAmBhU,EAASiU,OACnC5T,EAAgBJ,EAAeD,GAC/BkU,EAAe9O,MAAM+O,QAAQF,GAAWA,EAAU,GAClDG,EAAc/R,EAAsBO,KAAKvC,GAAiB6B,EAAoBD,SAC7E5B,EAAckI,QAAQ6L,EAAa,SAASpR,EAAMC,UAC7B,EAARA,GAA+D,GAAlDiR,EAAajC,QAAQ5R,EAAc4C,EAAQ,IACvDD,EAAKzC,cAAgBJ,EAAW6C,GAAM,MHmH3DQ,UI/Ha,SAAmBxD,UACVC,EAAeD,GAChBS,eJ+HrB4T,MKjIa,SAAerU,UACrBC,EAAeD,GAASgE,QLiI/BsQ,eMzHa,SAAuBtU,UAC7BC,EAAeD,GACnBuI,QAAQtH,EAAwB,KAChCsH,QAAQpH,EAAwB,KAAK6C,QNuHxCuQ,gBO/Ha,SAAyBvU,EAASwU,OACzCnU,EAAgBJ,EAAeD,GAC/ByU,EAAkBxU,EAAeuU,GACjCE,EAAkBD,EAAgBzQ,OACpCqQ,EAAQ,EACRM,EAAa,KACK,KAAlBtU,GAA4C,KAApBoU,SACnBJ,QAIa,KADpBM,EAAatU,EAAc4R,QAAQwC,EAAiBE,MAElDN,IACAM,GAAcD,IAEO,IAAhBC,WACFN,GPgHPO,WhC3Ha,SAAoB5U,EAAS6U,EAAWC,OAC/CzU,EAAgBJ,EAAeD,MACf,KAAlBK,GAA6C,mBAAdwU,SAC1B,MAEHE,EAAuBF,EAAUhK,KAAKiK,UACrC3P,EAAOkN,KACZhS,EACA,SAAS2U,EAAazR,EAAWN,UACxB8R,EAAqBxR,EAAWN,EAAO5C,GAAiB2U,EAAc,EAAIA,GAEnF,IgCiHFC,WQ1Ha,SAAoBjV,EAASyC,EAASC,UAC5CF,EAAMxC,EAASyC,EAASC,GAAOsB,QR2HtCkR,WdlHa,SAAoBlV,UAC1BC,EAAeD,GAASuI,QAAQ5G,EAAgCsJ,KckHvEkK,aSvIa,SAAsBnV,UAC5BC,EAAeD,GAASuI,QAAQ9G,EAA2B,STuIlE2T,ablHa,SAAsBpV,OAC7BK,EAAgBJ,EAAeD,UAC9BmL,GAAWhG,OAAOmG,GAAuBjL,IakHhDoK,QAAAA,GACA4K,QUrIa,SAAiB3K,EAAQZ,UAC/BW,iBAAQC,YAAWpI,EAAWwH,EAAc,QVsInDmI,QWzIa,SAAiBjS,EAAS+R,EAAQuD,UACzBrV,EAAeD,GAChBiS,QAAQF,EAAQuD,IXwIrCC,YY1Ia,SAAqBvV,EAAS+R,EAAQuD,UAC7BrV,EAAeD,GAChBuV,YAAYxD,EAAQuD,IZyIzCvD,OaxIa,SAAgB/R,EAASyC,EAAS6S,OACzCjV,EAAgBJ,EAAeD,GAC/BwV,EAAkB9V,EAAM4V,GAAa,EAAI7R,EAAWI,EAAUyR,GAAY,EAAGjV,EAAc2D,QAC7F2Q,EAAatU,EAAcG,OAAOgV,GAAiBzD,OAAOtP,UAC1C,IAAhBkS,GAAsB3M,MAAMwN,KAC9Bb,GAAca,GAETb,GbmIPc,Oc9Ia,SAAgBzV,EAAS4E,UAChB3E,EAAeD,GAChByV,OAAO7Q,Id6I5BD,YAAAA,EACA+Q,MezIa,SAAe1V,EAASgE,OAC/B3D,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU,EAAIP,EAAWI,EAAUG,GAAS,EAAGJ,UACnEvD,EAAc2D,QAAUE,EACnB7D,EAEFA,EAAcG,OAAO,EAAG0D,IfoI/ByR,WgB5Ia,SAAoB3V,EAAS4E,OAGtCgR,EAFEvV,EAAgBJ,EAAeD,GACjC8E,EAAiBN,EAAeI,GAEhCiR,EAAqB,MACzB/Q,EAAiBJ,EAAWI,EAAgB,GAC8B,QAAlE8Q,EAAgBxU,EAAyB0U,KAAKzV,KAA0B,IAC1EwV,IAAuB/Q,SAElB8Q,EADPxU,EAAyB2U,UAAY,GAGvCF,UAEK,IhBgIPG,KiB3Ia,SAAchW,EAASgE,OAC9B3D,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU,EAAIP,EAAWI,EAAUG,GAAS,EAAGJ,UACnEvD,EAAc2D,QAAUE,EACnB7D,EAEFA,EAAcG,OAAOH,EAAc2D,OAASE,EAAWA,IjBsI9D+R,MkBzIa,SAAejW,EAASgE,EAAQC,OACvC5D,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU3D,EAAc2D,OAASP,EAAWI,EAAUG,GAAS,EAAGJ,GACpFO,EAAYlE,EAAegE,EAAK,UAClCC,GAAa7D,EAAc2D,cACtB3D,MAEHoC,EAAUJ,EAAsBO,KAAKvC,GAAiB6B,EAAoBD,EAC5EiU,EAAkB,SACtB7V,EAAckI,QAAQ9F,EAAS,SAASO,EAAMmT,OACtCC,EAAmBD,EAASnT,EAAKgB,OACnCoS,GAAoBlS,EAAYC,EAAUH,SAC5CkS,EAAkBE,KAGf/V,EAAcG,OAAO,EAAG0V,GAAmB/R,GlB2HlDgG,MmB9Ia,SAAenK,EAASqW,EAAOpS,UACrChE,EAAeD,GAASmK,MAAMkM,EAAOpS,InB8I5CzD,OoBnJa,SAAgBR,EAASqW,EAAOrS,UACtC/D,EAAeD,GAASQ,OAAO6V,EAAOrS,IpBmJ7CwQ,UqBnJa,SAAmBxU,EAASqW,EAAOpS,UACzChE,EAAeD,GAASwU,UAAU6B,EAAOpS,IrBmJhDF,SAAAA,EAEAuS,OsBvJa,SAAgBtW,EAASuW,EAAU3R,OAC1CvE,EAAgBJ,EAAeD,GAC/BwW,EAAiBvW,EAAesW,GAChCzR,EAAiBN,EAAeI,UAClCE,EAAiB,GAAKA,EAAiBzE,EAAc2D,QAA6B,KAAnBwS,EAC1DnW,EAEFA,EAAc8J,MAAM,EAAGrF,GAAkB0R,EAAiBnW,EAAc8J,MAAMrF,ItBiJrF4M,SAAAA,GACArK,IuBlJa,SAAarH,EAASgE,EAAQqD,OACrChH,EAAgBJ,EAAeD,GAC/BkE,EAAYxE,EAAMsE,GAAU,EAAIP,EAAWI,EAAUG,GAAS,EAAGJ,GACjE0D,EAAYrH,EAAeoH,EAAK,QAClCnD,GAAa7D,EAAc2D,cACtB3D,MAEHoW,EAAgBvS,EAAY7D,EAAc2D,OAC1C0S,EAAoB7S,EAAU4S,EAAgB,GAC9CE,EAA6BF,EAAgB,SAEjDvP,GAAaI,EAAWoP,GACxBrW,EACA6G,GAAaI,EAAWoP,EAAoBC,IvBsI9CvP,QAAAA,GACAG,SAAAA,GACAT,OAAAA,GACAyB,QwBxJa,SAAiBvI,EAAS+R,EAAQxJ,UACzBtI,EAAeD,GAChBuI,QAAQwJ,EAAQxJ,IxBuJrCqO,WyB9Ja,SAASA,EAAW5W,EAAS+R,EAAQxJ,OAC5ClI,EAAgBJ,EAAeD,MACjC+R,aAAkB7Q,OAAQ,KACO,IAA/B6Q,EAAOrP,MAAMuP,QAAQ,WACjB,IAAI4E,UAAU,6DAEfxW,EAAckI,QAAQwJ,EAAQxJ,OAEjCyJ,EAAe/R,EAAe8R,GAC9B+E,EAAyC,mBAAZvO,EAC9BuO,IACHvO,EAAUtI,EAAesI,QAErBwO,EAAe/E,EAAahO,UACb,IAAjB+S,SACKH,EAAW5W,EAAS,QAASuI,WAEhCyO,EAA2B,EAAfD,EAAmBA,EAAe,EAC9CE,EAAiB,GACnBrS,EAAWvE,EAAc4R,QAAQD,EAAc,IAC9B,IAAdpN,GACLqS,EAAeC,KAAKtS,GACpBA,EAAWvE,EAAc4R,QAAQD,EAAcpN,EAAWoS,WAExDG,EAAiB,EACjBC,EAAS,GACJxJ,EAAI,EAAGA,EAAIqJ,EAAejT,OAAQ4J,IAAK,KACxChJ,EAAWqS,EAAerJ,GAC5B9F,EAAcS,EACduO,IACFhP,EAAc7H,EAAesI,EAAQ8J,UAAKvH,EAAWkH,EAAcpN,EAAUvE,KAE/E+W,GAAU/W,EAAc8J,MAAMgN,EAAgBvS,GAAYkD,EAC1DqP,EAAiBvS,EAAWmS,SAE1BI,EAAiB9W,EAAc2D,SACjCoT,GAAU/W,EAAc8J,MAAMgN,IAEzBC,GzByHPC,Q0BrKa,SAAiBrX,UACRC,EAAeD,GAElC+T,MAAM,IACNsD,UACAjU,KAAK,K1BiKRkU,gB2BhKa,SAASA,EAAgBtX,WAClCK,EAAgBJ,EAAeD,GAS/BuX,EAAiB,GACjBtU,GANJ5C,EAAgBA,EACbkI,QAAQtH,EAAwB,SAASuW,EAAIC,EAAIC,UACzCJ,EAAgBI,GAAMD,IAE9BlP,QAAQpH,EAAwB,SAET6C,OACnBf,KACLsU,GAAkBlX,EAAcoV,OAAOxS,UAElCsU,G3BkJPI,Q4B9Ja,SAAiB3X,OACxBK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAGF6C,EADoBwO,GAASrR,GAAekI,QAAQ7G,EAAkB,O5B0J7EkW,O6B5Ja,SAAgB5X,EAASqW,EAAOwB,EAAaC,OACpDzX,EAAgBJ,EAAeD,GAC/B+X,EAAc9X,EAAe6X,GAC/BE,EAAgBxT,EAAe6R,GAC/B2B,EAAgB,GAClBA,EAAgB3X,EAAc2D,OAASgU,GACnB,IAClBA,EAAgB,GAETA,EAAgB3X,EAAc2D,SACvCgU,EAAgB3X,EAAc2D,YAE5BiU,EAAoBzT,EAAeqT,EAAaxX,EAAc2D,OAASgU,UACvEC,EAAoB,IACtBA,EAAoB,GAEf5X,EAAc8J,MAAM,EAAG6N,GAAiBD,EAAc1X,EAAc8J,MAAM6N,EAAgBC,I7B6IjGC,GVrJa,SAAYlY,EAASmY,EAAMC,OAEpC/M,EACAgN,EA8BwBC,EACtBjN,EACAgN,EAlCAhY,EAAgBJ,EAAeD,MAGjCD,EAASoY,IAASpY,EAASqY,GAC7B/M,EAAO8M,EAAKpE,MAAM,IAClBsE,EAASD,EAAGrE,MAAM,QACb,UA0BqBuE,EAzBYhW,EAAW6V,EAAM,IA0BnD9M,EAAOD,OAAOC,KAAKiN,GACnBD,EAAShN,EAAKkN,KAAK5G,IAAoBxO,IAAI,SAASqI,UACjD8M,EAAO9M,KAET,CAACH,EAAMgN,OA9BXhN,OAAMgN,WAEHG,EAAanN,EAAKrH,UACL,IAAfwU,SACKnY,UAEL+W,EAAS,GACPqB,EAAeJ,EAAOrU,OACnBf,EAAQ,EAAGA,EAAQ5C,EAAc2D,OAAQf,IAAS,SACrDyV,GAAU,EACVC,SACKC,EAAW,EAAGA,EAAWJ,GAAcI,EAAWH,EAAcG,IAAY,KAC7EpN,EAAMH,EAAKuN,MACbvY,EAAcG,OAAOyC,EAAOuI,EAAIxH,UAAYwH,EAAK,CACnDkN,GAAU,EACVC,EAAaN,EAAOO,GACpB3V,EAAQA,EAAQuI,EAAIxH,OAAS,SAIjCoT,GAAUsB,EAAUC,EAAatY,EAAc4C,UAE1CmU,GUwHPyB,K8BlKa,SAAc7Y,EAASY,OAC9BP,EAAgBJ,EAAeD,MAClB,KAAfY,GAAuC,KAAlBP,SAChBA,MAEH8R,EAAmB5P,EAAS3B,UAC9BlB,EAAMyS,GACD9R,EAAcwY,OAEhBrG,GAAUN,GAAS7R,EAAe8R,GAAmBA,I9B0J5DD,SAAAA,GACAM,UAAAA,GACAsG,SN/Ia,SAAkB9Y,OAgDP+Y,EAhDgBA,yDAAU,GAC5C1Y,EAAgBJ,EAAeD,KAgD9B,CACLqJ,MAAO7E,GAFeuU,EA9CiCA,GAgDzBtG,IAAe,IAC7CuG,QAAS/Y,EAAe8Y,EAAQrG,IAAkB,MAClDuG,OAAQhZ,EAAe8Y,EAAQpG,IAAgB,IAC/CuG,IAAKtZ,EAAgBmZ,EAAQnG,KAAa,IAnDpCvJ,IAAAA,MAAO2P,IAAAA,QAASC,IAAAA,OAAQC,IAAAA,OACV,KAAlB7Y,GAAwBgJ,GAAS,SAC5B4P,UAEHE,EAAgB9Y,EAAc2D,OAC9BwQ,EAAYnU,EAAcmU,UAAU3J,KAAKxK,GAC3C8V,EAAS,EACTiD,EAAc,GACc/P,EAAzB8P,EAAgBhD,MACS,MAA1B9V,EAAc8V,QAIdkD,EAAgBhZ,EAAckV,YAAY,IAAKlM,EAAQ8M,GACtCA,GAAjBkD,GACFD,GAAeH,EAASzE,EAAU2B,EAAQkD,GAAiBL,EAC3D7C,EAASkD,EAAgB,GAErBH,GACFE,GAAeH,EAASzE,EAAU2B,EAAQ9M,EAAQ8M,GAAU6C,EAC5D7C,GAAU9M,GAKR8M,EAFmB,IADrBkD,EAAgBhZ,EAAc4R,QAAQ,IAAK5I,EAAQ8M,KAEjDiD,GAAeH,EAASzE,EAAU2B,EAAQkD,GAAiBL,EAClDK,EAAgB,IAEzBD,GAAeH,EAASzE,EAAU2B,GACzBgD,QAlBbhD,WAuBAA,EAASgD,IACXC,GAAeH,EAASzE,EAAU2B,IAE7BiD,GM2GPE,S+BpKa,SAAkBtZ,EAASiE,EAAKW,MACzClF,EAAMuE,UACD,MAEH5D,EAAgBJ,EAAeD,GAC/BmE,EAAYlE,EAAegE,MACf,KAAdE,SACK,EAETS,EAAWlF,EAAMkF,GAAYvE,EAAc2D,OAASP,EAAWI,EAAUe,GAAW,EAAGvE,EAAc2D,QACrGY,GAAYT,EAAUH,WAChB+R,EAAY1V,EAAc4R,QAAQ9N,EAAWS,UAC7B,IAAfmR,GAAoBA,IAAcnR,G/ByJzCkN,SAAAA,GACAe,QAAAA,GACA0G,agC3Ka,SAAsBvZ,OAC7BK,EAAgBJ,EAAeD,UAC9BoC,EAAmBQ,KAAKvC,IhC0K/BmZ,QiC7Ka,SAAiBxZ,UAES,IADjBC,EAAeD,GAChB6Y,OAAO7U,QjC4K5ByV,QkC7Ka,SAAiBzZ,OACxBK,EAAgBJ,EAAeD,UAC9BwB,EAAaoB,KAAKvC,IlC4KzBqZ,QmC/Ka,SAAiB1Z,UAEE,IADVC,EAAeD,GAChBgE,QnC8KrB2V,YoC/Ka,SAAqB3Z,OAC5B4Z,EAAc3Z,EAAeD,UAC5B6S,GAAQ+G,IAAgBA,EAAYrZ,gBAAkBqZ,GpC8K7DC,UqC9Ka,SAAmB7Z,OAC1B8Z,EAAkC,iBAAZ9Z,GAAyBN,EAAMM,GAA6BA,EAAlByE,OAAOzE,UAElD,iBAAjB8Z,GAAqD,iBAAjBA,KAC3C9R,MAAM8R,EAAe/R,WAAW+R,KrC2KnC/Z,SAAAA,EACAga,YsCrLa,SAAqB/Z,OAC5BK,EAAgBJ,EAAeD,UAC9B6S,GAAQxS,IAAkBA,EAAcI,gBAAkBJ,GtCoLjE2Z,QuCjLa,SAAiBha,EAASyC,EAASC,OAG5CuX,EAFE5Z,EAAgBJ,EAAeD,GAC/B6C,EAAc5C,EAAeyC,QAE7BD,aAAmBvB,QAAS,IAEV,QADtB+Y,EAAgB1X,EAASE,WAEhB,EAETA,EAAU,IAAIvB,OAAO+Y,EAAepX,UAE/BJ,EAAQG,KAAKvC,IvCuKpB6Z,WwC/Ka,SAAoBla,EAASqW,EAAOzR,OAC3CvE,EAAgBJ,EAAeD,GAC/Bma,EAAc5X,EAAS8T,UACT,OAAhB8D,IAGgB,KAAhBA,IAGJvV,EAAWlF,EAAMkF,GAAY,EAAInB,EAAWI,EAAUe,GAAW,EAAGvE,EAAc2D,QAC3E3D,EAAcG,OAAOoE,EAAUuV,EAAYnW,UAAYmW,KxCuK9DC,MyC7La,SAAepa,UACNC,EAAeD,GAChB+T,MAAM,KzC4L3BsG,W0CxLa,SAAoBra,WAK7Bsa,EAJEja,EAAgBJ,EAAeD,GAC/B6E,EAAsBxE,EAAc2D,OACpCuW,EAAiB,GACnBtX,EAAQ,EAELA,EAAQ4B,GACbyV,EAAkB3V,EAAYtE,EAAe4C,GAC7CsX,EAAerD,KAAKoD,GACpBrX,GAA2B,MAAlBqX,EAA2B,EAAI,SAEnCC,G1C8KPC,U2CtLa,SAAmBxa,UAEzBsC,EADerC,EAAeD,GACL8C,MAAM1B,GAA2B,K3CqLjE2S,M4C3La,SAAe/T,EAASya,EAAWC,UAC1Bza,EAAeD,GAChB+T,MAAM0G,EAAWC,I5C0LtClY,MAAAA,EAEAmY,S6C5La,SAAc3a,OACrBK,EAAgBJ,EAAeD,SACf,KAAlBK,EACK,GAvBa,WAyBlBA,EAAc,GACTA,EAAcmU,UAAU,GAE1BnU,G7CqLPua,U8CnLa,SAAc5a,EAAS6a,EAAe/S,MAEnC,MADhB9H,EAAUC,EAAeD,UAEhB,OAEJoF,MAAM+O,QAAQ0G,GAAgB,KAC3BC,EAAsB7a,EAAe4a,GAC3CA,EAAwC,KAAxBC,EAA6B,GC9BlC,SAAsBC,WAE/BjY,EADEkY,EAAW,GAE+B,QAAxClY,EAAQhB,EAAgBgU,KAAKiF,KACnCC,EAAS9D,KAAKpU,EAAM,WAEfkY,EDwB6CC,CAAaH,WAE3DI,EAAoBjb,EAAe6H,GACnC9D,EAAShE,EAAQgE,OACjBmX,EAA0C,EAAvBN,EAAc7W,OACjCoX,EElCO,SAA6Bpb,EAASwU,EAAWvR,OAC1DoY,EAAc,oEAEhBA,EAAkC,EAAnB7G,EAAUxQ,QAEAhE,EAAQQ,OAAOyC,EAAQoY,EAAa7G,EAAUxQ,QAC/CzD,gBAAkBiU,GF4BH3J,KAAK,KAAM7K,GAChDmT,EAxCe,EAyCfmI,EAAQ,EACRC,EAAS,GACTrI,EAAa,GACbsI,EAAQ,KACHvY,EAAQ,EAAGA,EAAQe,EAAQf,IAAS,KACrCoQ,EAAOrT,EAAQiD,GACjBwY,GAAU,SACNpI,OACD,OACCmI,WAGAJ,EAAa,KAAMnY,GAAO,GAAQ,CACpCwY,GAAU,WAtDC,IAyDTtI,EAAwB,CAC1BsI,GAAU,EACVtI,EA1DS,WAAA,IA6DPA,EAAsB,CACxBmI,UAGFG,GAAU,YAEP,OAnEQ,IAoEPtI,GAAwBiI,EAAa,KAAMnY,GAAQ,CACrDkQ,EApEgB,QAuElBsI,GAAU,YAEP,OAzEe,IA0EdtI,GAA+BiI,EAAa,MAAOnY,GAAQ,CAC7DkQ,EA1EY,QA6EdsI,GAAU,YAEP,QACA,IAlFQ,IAmFPtI,IAEAqI,EADEA,IAAUnI,EACJ,KACEmI,GACFnI,GAGZoI,GAAU,YAEP,QACA,OA5Fe,IA6FdtI,GAA+BiI,EAAa,UAAWnY,GAAQ,CACjEkQ,EA/FS,QAkGXsI,GAAU,YAEP,OACS,EAARH,EAAW,CACbA,aAGEE,WAzGO,IA4GPrI,EAAsB,IACxBqI,EAAQ,KACRrI,EA/GW,EAgHPgI,EAAkB,KAEd/H,EAAUH,GADhBC,GAAc,MAEwC,IAAlD2H,EAAc5I,QAAQmB,EAAQ7S,eAChCgb,GAAUrI,EAEVqI,GAAUL,EAEZhI,EAAa,QAEbqI,GAAUL,WAxHI,IA4Hd/H,GA3HU,IA2HsBA,GAA2BiI,EAAa,SAAOnY,GAAS,CAC1FuY,EAAQ,KACRrI,EAhIW,EAiIXD,EAAa,SAGfuI,GAAU,gBAGVA,GAAU,KAEVA,SACMtI,QA1IO,EA4IXoI,GAAUlI,aA3ID,EA8IL8H,IACFjI,GAAcG,WAMjBkI,G9C0DPG,WFnMa,kBACThW,OAAS4N,GAAa7E,IACxB6E,GAAa7E,EAAIiF,IAEZhO,MEgMPiW,QD3Mc,SkDAhB,SAASC,GAAa5b,EAAS6b,QACxBC,cAAgB9b,OAChB+b,eAAiBF,ECaxB,SAASG,GAAKhc,UACL,IAAI4b,GAAa5b,GAAS,UDWnC4b,GAAavW,UAAU1F,MAAQ,kBACtB+F,KAAKoW,eASdF,GAAavW,UAAU4W,QAAU,kBACxBvW,KAAK/F,SASdic,GAAavW,UAAU6W,OAAS,kBACvBxW,KAAK/F,SASdic,GAAavW,UAAU9C,SAAW,kBACzBrC,OAAOwF,KAAK/F,UA2BrBic,GAAavW,UAAU8W,MAAQ,kBACtB,IAAIP,GAAalW,KAAKoW,eAAe,IAuB9CF,GAAavW,UAAU+W,KAAO,SAASC,SACd,mBAAZA,EACF,IAAIT,GAAaS,EAAQ3W,KAAKoW,eAAgBpW,KAAKqW,gBAErDrW,MASTkW,GAAavW,UAAU0W,gBAAiB,EAoBxC3Q,OAAOC,KAAKiR,IAAW/K,QAAQ,SAASgL,GAXxC,IAA+BC,EAY7BZ,GAAavW,UAAUkX,IAZMC,EAYwBF,GAAUC,GAXxD,sCAAYE,2BAAAA,sBACXrF,EAASoF,gBAAiB9W,KAAKoW,sBAAkBW,WACnD/W,KAAKqW,gBAAoC,iBAAX3E,EACzB,IAAIwE,GAAaxE,EAAQ1R,KAAKqW,gBAE9B3E,MCtHbsF,EAAcV,GAAMM,GAAW,CAC7BH,MCZa,SAAenc,UACrB,IAAI4b,GAAa5b,GAAS"}